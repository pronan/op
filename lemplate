#!/usr/bin/env perl

#BOOTSTRAP-BEGIN
# This is the standalone Lemplate compiler.
#
# All you need is this program and the program called `perl`. You don't need
# to install any Perl modules.
#
# If you downloaded this program from the internet, don't forget to put it in
# your path and make sure it is executable. Like this:
#
#     mv lemplate /usr/local/bin/
#     chmod +x /usr/local/bin/lemplate
#
# Try this command to make sure it works:
#
#     lemplate --help

use Config;
BEGIN {
    @INC = (
        $Config::Config{archlib},
        $Config::Config{privlib},
    );
}
use strict;
use warnings;

#
# Inline include of Number/Compare.pm
#
BEGIN { $INC{'Number/Compare.pm'} = 'dummy/Number/Compare.pm'; }
BEGIN {
#line 0 "Number/Compare.pm"
package Number::Compare;
use strict;
use Carp qw(croak);
use vars qw/$VERSION/;
$VERSION = '0.03';

sub new  {
    my $referent = shift;
    my $class = ref $referent || $referent;
    my $expr = $class->parse_to_perl( shift );

    bless eval "sub { \$_[0] $expr }", $class;
}

sub parse_to_perl {
    shift;
    my $test = shift;

    $test =~ m{^
               ([<>]=?)?   # comparison
               (.*?)       # value
               ([kmg]i?)?  # magnitude
              $}ix
       or croak "don't understand '$test' as a test";

    my $comparison = $1 || '==';
    my $target     = $2;
    my $magnitude  = $3 || '';
    $target *=           1000 if lc $magnitude eq 'k';
    $target *=           1024 if lc $magnitude eq 'ki';
    $target *=        1000000 if lc $magnitude eq 'm';
    $target *=      1024*1024 if lc $magnitude eq 'mi';
    $target *=     1000000000 if lc $magnitude eq 'g';
    $target *= 1024*1024*1024 if lc $magnitude eq 'gi';

    return "$comparison $target";
}

sub test { $_[0]->( $_[1] ) }

1;


}
#
# Inline include of Text/Glob.pm
#
BEGIN { $INC{'Text/Glob.pm'} = 'dummy/Text/Glob.pm'; }
BEGIN {
#line 0 "Text/Glob.pm"
package Text::Glob;
use strict;
use Exporter;
use vars qw/$VERSION @ISA @EXPORT_OK
            $strict_leading_dot $strict_wildcard_slash/;
$VERSION = '0.09';
@ISA = 'Exporter';
@EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );

$strict_leading_dot    = 1;
$strict_wildcard_slash = 1;

use constant debug => 0;

sub glob_to_regex {
    my $glob = shift;
    my $regex = glob_to_regex_string($glob);
    return qr/^$regex$/;
}

sub glob_to_regex_string
{
    my $glob = shift;
    my ($regex, $in_curlies, $escaping);
    local $_;
    my $first_byte = 1;
    for ($glob =~ m/(.)/gs) {
        if ($first_byte) {
            if ($strict_leading_dot) {
                $regex .= '(?=[^\.])' unless $_ eq '.';
            }
            $first_byte = 0;
        }
        if ($_ eq '/') {
            $first_byte = 1;
        }
        if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
            $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
            $regex .= "\\$_";
        }
        elsif ($_ eq '*') {
            $regex .= $escaping ? "\\*" :
              $strict_wildcard_slash ? "[^/]*" : ".*";
        }
        elsif ($_ eq '?') {
            $regex .= $escaping ? "\\?" :
              $strict_wildcard_slash ? "[^/]" : ".";
        }
        elsif ($_ eq '{') {
            $regex .= $escaping ? "\\{" : "(";
            ++$in_curlies unless $escaping;
        }
        elsif ($_ eq '}' && $in_curlies) {
            $regex .= $escaping ? "}" : ")";
            --$in_curlies unless $escaping;
        }
        elsif ($_ eq ',' && $in_curlies) {
            $regex .= $escaping ? "," : "|";
        }
        elsif ($_ eq "\\") {
            if ($escaping) {
                $regex .= "\\\\";
                $escaping = 0;
            }
            else {
                $escaping = 1;
            }
            next;
        }
        else {
            $regex .= $_;
            $escaping = 0;
        }
        $escaping = 0;
    }
    print "# $glob $regex\n" if debug;

    return $regex;
}

sub match_glob {
    print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
    my $glob = shift;
    my $regex = glob_to_regex $glob;
    local $_;
    grep { $_ =~ $regex } @_;
}

1;

}
#
# Inline include of File/Find/Rule.pm
#
BEGIN { $INC{'File/Find/Rule.pm'} = 'dummy/File/Find/Rule.pm'; }
BEGIN {
#line 0 "File/Find/Rule.pm"

package File::Find::Rule;
use strict;
use File::Spec;
use Text::Glob 'glob_to_regex';
use Number::Compare;
use Carp qw/croak/;
use File::Find (); # we're only wrapping for now

our $VERSION = '0.34';

sub import {
    my $pkg = shift;
    my $to  = caller;
    for my $sym ( qw( find rule ) ) {
        no strict 'refs';
        *{"$to\::$sym"} = \&{$sym};
    }
    for (grep /^:/, @_) {
        my ($extension) = /^:(.*)/;
        eval "require File::Find::Rule::$extension";
        croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
    }
}



*rule = \&find;
sub find {
    my $object = __PACKAGE__->new();
    my $not = 0;

    while (@_) {
        my $method = shift;
        my @args;

        if ($method =~ s/^\!//) {
            # jinkies, we're really negating this
            unshift @_, $method;
            $not = 1;
            next;
        }
        unless (defined prototype $method) {
            my $args = shift;
            @args = ref $args eq 'ARRAY' ? @$args : $args;
        }
        if ($not) {
            $not = 0;
            @args = $object->new->$method(@args);
            $method = "not";
        }

        my @return = $object->$method(@args);
        return @return if $method eq 'in';
    }
    $object;
}



sub new {
    my $referent = shift;
    my $class = ref $referent || $referent;
    bless {
        rules    => [],
        subs     => {},
        iterator => [],
        extras   => {},
        maxdepth => undef,
        mindepth => undef,
    }, $class;
}

sub _force_object {
    my $object = shift;
    $object = $object->new()
      unless ref $object;
    $object;
}


sub _flatten {
    my @flat;
    while (@_) {
        my $item = shift;
        ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
    }
    return @flat;
}

sub name {
    my $self = _force_object shift;
    my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );

    push @{ $self->{rules} }, {
        rule => 'name',
        code => join( ' || ', map { "m{$_}" } @names ),
        args => \@_,
    };

    $self;
}


use vars qw( %X_tests );
%X_tests = (
    -r  =>  readable           =>  -R  =>  r_readable      =>
    -w  =>  writeable          =>  -W  =>  r_writeable     =>
    -w  =>  writable           =>  -W  =>  r_writable      =>
    -x  =>  executable         =>  -X  =>  r_executable    =>
    -o  =>  owned              =>  -O  =>  r_owned         =>

    -e  =>  exists             =>  -f  =>  file            =>
    -z  =>  empty              =>  -d  =>  directory       =>
    -s  =>  nonempty           =>  -l  =>  symlink         =>
                               =>  -p  =>  fifo            =>
    -u  =>  setuid             =>  -S  =>  socket          =>
    -g  =>  setgid             =>  -b  =>  block           =>
    -k  =>  sticky             =>  -c  =>  character       =>
                               =>  -t  =>  tty             =>
    -M  =>  modified                                       =>
    -A  =>  accessed           =>  -T  =>  ascii           =>
    -C  =>  changed            =>  -B  =>  binary          =>
   );

for my $test (keys %X_tests) {
    my $sub = eval 'sub () {
        my $self = _force_object shift;
        push @{ $self->{rules} }, {
            code => "' . $test . ' \$_",
            rule => "'.$X_tests{$test}.'",
        };
        $self;
    } ';
    no strict 'refs';
    *{ $X_tests{$test} } = $sub;
}



use vars qw( @stat_tests );
@stat_tests = qw( dev ino mode nlink uid gid rdev
                  size atime mtime ctime blksize blocks );
{
    my $i = 0;
    for my $test (@stat_tests) {
        my $index = $i++; # to close over
        my $sub = sub {
            my $self = _force_object shift;

            my @tests = map { Number::Compare->parse_to_perl($_) } @_;

            push @{ $self->{rules} }, {
                rule => $test,
                args => \@_,
                code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                  join ('||', map { "(\$val $_)" } @tests ).' }',
            };
            $self;
        };
        no strict 'refs';
        *$test = $sub;
    }
}


sub any {
    my $self = _force_object shift;
    # compile all the subrules to code fragments
    push @{ $self->{rules} }, {
        rule => "any",
        code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
        args => \@_,
    };

    # merge all the subs hashes of the kids into ourself
    %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
    $self;
}

*or = \&any;


sub not {
    my $self = _force_object shift;

    push @{ $self->{rules} }, {
        rule => 'not',
        args => \@_,
        code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
    };

    # merge all the subs hashes into us
    %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
    $self;
}

*none = \&not;


sub prune () {
    my $self = _force_object shift;

    push @{ $self->{rules} },
      {
       rule => 'prune',
       code => '$File::Find::prune = 1'
      };
    $self;
}


sub discard () {
    my $self = _force_object shift;

    push @{ $self->{rules} }, {
        rule => 'discard',
        code => '$discarded = 1',
    };
    $self;
}


sub exec {
    my $self = _force_object shift;
    my $code = shift;

    push @{ $self->{rules} }, {
        rule => 'exec',
        code => $code,
    };
    $self;
}


sub grep {
    my $self = _force_object shift;
    my @pattern = map {
        ref $_
          ? ref $_ eq 'ARRAY'
            ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
            : [ $_ => 1 ]
          : [ qr/$_/ => 1 ]
      } @_;

    $self->exec( sub {
        local *FILE;
        open FILE, $_ or return;
        local ($_, $.);
        while (<FILE>) {
            for my $p (@pattern) {
                my ($rule, $ret) = @$p;
                return $ret
                  if ref $rule eq 'Regexp'
                    ? /$rule/
                      : $rule->(@_);
            }
        }
        return;
    } );
}


for my $setter (qw( maxdepth mindepth extras )) {
    my $sub = sub {
        my $self = _force_object shift;
        $self->{$setter} = shift;
        $self;
    };
    no strict 'refs';
    *$setter = $sub;
}



sub relative () {
    my $self = _force_object shift;
    $self->{relative} = 1;
    $self;
}


sub canonpath () {
    my $self = _force_object shift;
    $self->{canonpath} = 1;
    $self;
}


sub DESTROY {}
sub AUTOLOAD {
    our $AUTOLOAD;
    $AUTOLOAD =~ /::not_([^:]*)$/
      or croak "Can't locate method $AUTOLOAD";
    my $method = $1;

    my $sub = sub {
        my $self = _force_object shift;
        $self->not( $self->new->$method(@_) );
    };
    {
        no strict 'refs';
        *$AUTOLOAD = $sub;
    }
    &$sub;
}


sub in {
    my $self = _force_object shift;

    my @found;
    my $fragment = $self->_compile;
    my %subs = %{ $self->{subs} };

    warn "relative mode handed multiple paths - that's a bit silly\n"
      if $self->{relative} && @_ > 1;

    my $topdir;
    my $code = 'sub {
        (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
        my @args = ($_, $File::Find::dir, $path);
        my $maxdepth = $self->{maxdepth};
        my $mindepth = $self->{mindepth};
        my $relative = $self->{relative};
        my $canonpath = $self->{canonpath};

        # figure out the relative path and depth
        my $relpath = $File::Find::name;
        $relpath =~ s{^\Q$topdir\E/?}{};
        my $depth = scalar File::Spec->splitdir($relpath);
        #print "name: \'$File::Find::name\' ";
        #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";

        defined $maxdepth && $depth >= $maxdepth
           and $File::Find::prune = 1;

        defined $mindepth && $depth < $mindepth
           and return;

        #print "Testing \'$_\'\n";

        my $discarded;
        return unless ' . $fragment . ';
        return if $discarded;
        if ($relative) {
            if ($relpath ne "") {
                push @found, $canonpath ? File::Spec->canonpath($relpath) : $relpath;
            }
        }
        else {
            push @found, $canonpath ? File::Spec->canonpath($path) : $path;
        }
    }';

    #use Data::Dumper;
    #print Dumper \%subs;
    #warn "Compiled sub: '$code'\n";

    my $sub = eval "$code" or die "compile error '$code' $@";
    for my $path (@_) {
        # $topdir is used for relative and maxdepth
        $topdir = $path;
        # slice off the trailing slash if there is one (the
        # maxdepth/mindepth code is fussy)
        $topdir =~ s{/?$}{}
          unless $topdir eq '/';
        $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
    }

    return @found;
}

sub _call_find {
    my $self = shift;
    File::Find::find( @_ );
}

sub _compile {
    my $self = shift;

    return '1' unless @{ $self->{rules} };
    my $code = join " && ", map {
        if (ref $_->{code}) {
            my $key = "$_->{code}";
            $self->{subs}{$key} = $_->{code};
            "\$subs{'$key'}->(\@args) # $_->{rule}\n";
        }
        else {
            "( $_->{code} ) # $_->{rule}\n";
        }
    } @{ $self->{rules} };

    #warn $code;
    return $code;
}


sub start {
    my $self = _force_object shift;

    $self->{iterator} = [ $self->in( @_ ) ];
    $self;
}


sub match {
    my $self = _force_object shift;

    return shift @{ $self->{iterator} };
}

1;


}
#
# Inline include of Template/Constants.pm
#
BEGIN { $INC{'Template/Constants.pm'} = 'dummy/Template/Constants.pm'; }
BEGIN {
#line 0 "Template/Constants.pm"
 
package Template::Constants;

require Exporter;
use strict;
use warnings;
use Exporter;
use vars qw( @EXPORT_OK %EXPORT_TAGS );
use vars qw( $DEBUG_OPTIONS @STATUS @ERROR @CHOMP @DEBUG @ISA );
@ISA = qw( Exporter );

our $VERSION = 2.75;



use constant STATUS_OK       =>   0;      # ok
use constant STATUS_RETURN   =>   1;      # ok, block ended by RETURN
use constant STATUS_STOP     =>   2;      # ok, stopped by STOP 
use constant STATUS_DONE     =>   3;      # ok, iterator done
use constant STATUS_DECLINED =>   4;      # ok, declined to service request
use constant STATUS_ERROR    => 255;      # error condition

use constant ERROR_RETURN    =>  'return'; # return a status code
use constant ERROR_FILE      =>  'file';   # file error: I/O, parse, recursion
use constant ERROR_VIEW      =>  'view';   # view error
use constant ERROR_UNDEF     =>  'undef';  # undefined variable value used
use constant ERROR_PERL      =>  'perl';   # error in [% PERL %] block
use constant ERROR_FILTER    =>  'filter'; # filter error
use constant ERROR_PLUGIN    =>  'plugin'; # plugin error

use constant CHOMP_NONE      => 0; # do not remove whitespace
use constant CHOMP_ALL       => 1; # remove whitespace up to newline
use constant CHOMP_ONE       => 1; # new name for CHOMP_ALL
use constant CHOMP_COLLAPSE  => 2; # collapse whitespace to a single space
use constant CHOMP_GREEDY    => 3; # remove all whitespace including newlines

use constant DEBUG_OFF       =>    0; # do nothing
use constant DEBUG_ON        =>    1; # basic debugging flag
use constant DEBUG_UNDEF     =>    2; # throw undef on undefined variables
use constant DEBUG_VARS      =>    4; # general variable debugging
use constant DEBUG_DIRS      =>    8; # directive debugging
use constant DEBUG_STASH     =>   16; # general stash debugging
use constant DEBUG_CONTEXT   =>   32; # context debugging
use constant DEBUG_PARSER    =>   64; # parser debugging
use constant DEBUG_PROVIDER  =>  128; # provider debugging
use constant DEBUG_PLUGINS   =>  256; # plugins debugging
use constant DEBUG_FILTERS   =>  512; # filters debugging
use constant DEBUG_SERVICE   => 1024; # context debugging
use constant DEBUG_ALL       => 2047; # everything

use constant DEBUG_CALLER    => 4096; # add caller file/line
use constant DEBUG_FLAGS     => 4096; # bitmask to extract flags

$DEBUG_OPTIONS  = {
    &DEBUG_OFF      => off      => off      => &DEBUG_OFF,
    &DEBUG_ON       => on       => on       => &DEBUG_ON,
    &DEBUG_UNDEF    => undef    => undef    => &DEBUG_UNDEF,
    &DEBUG_VARS     => vars     => vars     => &DEBUG_VARS,
    &DEBUG_DIRS     => dirs     => dirs     => &DEBUG_DIRS,
    &DEBUG_STASH    => stash    => stash    => &DEBUG_STASH,
    &DEBUG_CONTEXT  => context  => context  => &DEBUG_CONTEXT,
    &DEBUG_PARSER   => parser   => parser   => &DEBUG_PARSER,
    &DEBUG_PROVIDER => provider => provider => &DEBUG_PROVIDER,
    &DEBUG_PLUGINS  => plugins  => plugins  => &DEBUG_PLUGINS,
    &DEBUG_FILTERS  => filters  => filters  => &DEBUG_FILTERS,
    &DEBUG_SERVICE  => service  => service  => &DEBUG_SERVICE,
    &DEBUG_ALL      => all      => all      => &DEBUG_ALL,
    &DEBUG_CALLER   => caller   => caller   => &DEBUG_CALLER,
};

@STATUS  = qw( STATUS_OK STATUS_RETURN STATUS_STOP STATUS_DONE
               STATUS_DECLINED STATUS_ERROR );
@ERROR   = qw( ERROR_FILE ERROR_VIEW ERROR_UNDEF ERROR_PERL 
               ERROR_RETURN ERROR_FILTER ERROR_PLUGIN );
@CHOMP   = qw( CHOMP_NONE CHOMP_ALL CHOMP_ONE CHOMP_COLLAPSE CHOMP_GREEDY );
@DEBUG   = qw( DEBUG_OFF DEBUG_ON DEBUG_UNDEF DEBUG_VARS 
               DEBUG_DIRS DEBUG_STASH DEBUG_CONTEXT DEBUG_PARSER
               DEBUG_PROVIDER DEBUG_PLUGINS DEBUG_FILTERS DEBUG_SERVICE
               DEBUG_ALL DEBUG_CALLER DEBUG_FLAGS );

@EXPORT_OK   = ( @STATUS, @ERROR, @CHOMP, @DEBUG );
%EXPORT_TAGS = (
    'all'      => [ @EXPORT_OK ],
    'status'   => [ @STATUS    ],
    'error'    => [ @ERROR     ],
    'chomp'    => [ @CHOMP     ],
    'debug'    => [ @DEBUG     ],
);


sub debug_flags {
    my ($self, $debug) = @_;
    my (@flags, $flag, $value);
    $debug = $self unless defined($debug) || ref($self);
    
    if ($debug =~ /^\d+$/) {
        foreach $flag (@DEBUG) {
            next if $flag =~ /^DEBUG_(OFF|ALL|FLAGS)$/;

            # don't trash the original
            my $copy = $flag;
            $flag =~ s/^DEBUG_//;
            $flag = lc $flag;
            return $self->error("no value for flag: $flag")
                unless defined($value = $DEBUG_OPTIONS->{ $flag });
            $flag = $value;

            if ($debug & $flag) {
                $value = $DEBUG_OPTIONS->{ $flag };
                return $self->error("no value for flag: $flag") unless defined $value;
                push(@flags, $value);
            }
        }
        return wantarray ? @flags : join(', ', @flags);
    }
    else {
        @flags = split(/\W+/, $debug);
        $debug = 0;
        foreach $flag (@flags) {
            $value = $DEBUG_OPTIONS->{ $flag };
            return $self->error("unknown debug flag: $flag") unless defined $value;
            $debug |= $value;
        }
        return $debug;
    }
}


1;


}
#
# Inline include of Template/Base.pm
#
BEGIN { $INC{'Template/Base.pm'} = 'dummy/Template/Base.pm'; }
BEGIN {
#line 0 "Template/Base.pm"
 
package Template::Base;

use strict;
use warnings;
use Template::Constants;

our $VERSION = 2.78;



sub new {
    my $class = shift;
    my ($argnames, @args, $arg, $cfg);

    {   no strict 'refs';
        no warnings 'once';
        $argnames = \@{"$class\::BASEARGS"} || [ ];
    }

    # shift off all mandatory args, returning error if undefined or null
    foreach $arg (@$argnames) {
        return $class->error("no $arg specified")
            unless ($cfg = shift);
        push(@args, $cfg);
    }

    # fold all remaining args into a hash, or use provided hash ref
    $cfg  = defined $_[0] && ref($_[0]) eq 'HASH' ? shift : { @_ };

    my $self = bless {
        (map { ($_ => shift @args) } @$argnames),
        _ERROR  => '',
        DEBUG   => 0,
    }, $class;
    
    return $self->_init($cfg) ? $self : $class->error($self->error);
}



sub error {
    my $self = shift;
    my $errvar;

    { 
        no strict qw( refs );
        $errvar = ref $self ? \$self->{ _ERROR } : \${"$self\::ERROR"};
    }
    if (@_) {
        $$errvar = ref($_[0]) ? shift : join('', @_);
        return undef;
    }
    else {
        return $$errvar;
    }
}



sub _init {
    my ($self, $config) = @_;
    return $self;
}


sub debug {
    my $self = shift;
    my $msg  = join('', @_);
    my ($pkg, $file, $line) = caller();

    unless ($msg =~ /\n$/) {
        $msg .= ($self->{ DEBUG } & Template::Constants::DEBUG_CALLER)
            ? " at $file line $line\n"
            : "\n";
    }

    print STDERR "[$pkg] $msg";
}



sub module_version {
    my $self = shift;
    my $class = ref $self || $self;
    no strict 'refs';
    return ${"${class}::VERSION"};
}


1;


}
#
# Inline include of Template/Config.pm
#
BEGIN { $INC{'Template/Config.pm'} = 'dummy/Template/Config.pm'; }
BEGIN {
#line 0 "Template/Config.pm"
 
package Template::Config;

use strict;
use warnings;
use base 'Template::Base';
use vars qw( $VERSION $DEBUG $ERROR $INSTDIR
             $PARSER $PROVIDER $PLUGINS $FILTERS $ITERATOR 
             $LATEX_PATH $PDFLATEX_PATH $DVIPS_PATH
             $STASH $SERVICE $CONTEXT $CONSTANTS @PRELOAD );

$VERSION   = 2.75;
$DEBUG     = 0 unless defined $DEBUG;
$ERROR     = '';
$CONTEXT   = 'Template::Context';
$FILTERS   = 'Template::Filters';
$ITERATOR  = 'Template::Iterator';
$PARSER    = 'Template::Parser';
$PLUGINS   = 'Template::Plugins';
$PROVIDER  = 'Template::Provider';
$SERVICE   = 'Template::Service';
$STASH     = 'Template::Stash::XS';
$CONSTANTS = 'Template::Namespace::Constants';

@PRELOAD   = ( $CONTEXT, $FILTERS, $ITERATOR, $PARSER,
               $PLUGINS, $PROVIDER, $SERVICE, $STASH );

$INSTDIR  = '';




sub preload {
    my $class = shift;

    foreach my $module (@PRELOAD, @_) {
        $class->load($module) || return;
    };
    return 1;
}



sub load {
    my ($class, $module) = @_;
    $module =~ s[::][/]g;
    $module .= '.pm';
    eval { require $module; };
    return $@ ? $class->error("failed to load $module: $@") : 1;
}



sub parser {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH'
               ? shift : { @_ };

    return undef unless $class->load($PARSER);
    return $PARSER->new($params) 
        || $class->error("failed to create parser: ", $PARSER->error);
}



sub provider {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($PROVIDER);
    return $PROVIDER->new($params) 
        || $class->error("failed to create template provider: ",
                         $PROVIDER->error);
}



sub plugins {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($PLUGINS);
    return $PLUGINS->new($params)
        || $class->error("failed to create plugin provider: ",
                         $PLUGINS->error);
}



sub filters {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($FILTERS);
    return $FILTERS->new($params)
        || $class->error("failed to create filter provider: ",
                         $FILTERS->error);
}



sub iterator {
    my $class = shift;
    my $list  = shift;

    return undef unless $class->load($ITERATOR);
    return $ITERATOR->new($list, @_)
        || $class->error("failed to create iterator: ", $ITERATOR->error);
}



sub stash {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($STASH);
    return $STASH->new($params) 
        || $class->error("failed to create stash: ", $STASH->error);
}



sub context {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($CONTEXT);
    return $CONTEXT->new($params) 
        || $class->error("failed to create context: ", $CONTEXT->error);
}



sub service {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($SERVICE);
    return $SERVICE->new($params) 
        || $class->error("failed to create context: ", $SERVICE->error);
}



sub constants {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($CONSTANTS);
    return $CONSTANTS->new($params) 
        || $class->error("failed to create constants namespace: ", 
                         $CONSTANTS->error);
}



sub instdir {
    my ($class, $dir) = @_;
    my $inst = $INSTDIR 
        || return $class->error("no installation directory");
    $inst =~ s[/$][]g;
    $inst .= "/$dir" if $dir;
    return $inst;
}




package Template::TieString;

sub TIEHANDLE {
    my ($class, $textref) = @_;
    bless $textref, $class;
}
sub PRINT {
    my $self = shift;
    $$self .= join('', @_);
}



1;


}
#
# Inline include of Template/Document.pm
#
BEGIN { $INC{'Template/Document.pm'} = 'dummy/Template/Document.pm'; }
BEGIN {
#line 0 "Template/Document.pm"

package Template::Document;

use strict;
use warnings;
use base 'Template::Base';
use Template::Constants;

our $VERSION = 2.79;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';
our ($COMPERR, $AUTOLOAD, $UNICODE);

BEGIN {
    # UNICODE is supported in versions of Perl from 5.008 onwards
    if ($UNICODE = $] > 5.007 ? 1 : 0) {
        if ($] > 5.008) {
            # utf8::is_utf8() available from Perl 5.8.1 onwards
            *is_utf8 = \&utf8::is_utf8;
        }
        elsif ($] == 5.008) {
            # use Encode::is_utf8() for Perl 5.8.0
            require Encode;
            *is_utf8 = \&Encode::is_utf8;
        }
    }
}




sub new {
    my ($class, $doc) = @_;
    my ($block, $defblocks, $variables, $metadata) = @$doc{ qw( BLOCK DEFBLOCKS VARIABLES METADATA ) };
    $defblocks ||= { };
    $metadata  ||= { };

    # evaluate Perl code in $block to create sub-routine reference if necessary
    unless (ref $block) {
        local $SIG{__WARN__} = \&catch_warnings;
        $COMPERR = '';

        # DON'T LOOK NOW! - blindly untainting can make you go blind!
        $block =~ /(.*)/s;
        $block = $1;
        
        $block = eval $block;
        return $class->error($@)
            unless defined $block;
    }

    # same for any additional BLOCK definitions
    @$defblocks{ keys %$defblocks } = 
        # MORE BLIND UNTAINTING - turn away if you're squeamish
        map { 
            ref($_) 
                ? $_ 
                : ( /(.*)/s && eval($1) or return $class->error($@) )
            } values %$defblocks;
    
    bless {
        %$metadata,
        _BLOCK     => $block,
        _DEFBLOCKS => $defblocks,
        _VARIABLES => $variables,
        _HOT       => 0,
    }, $class;
}



sub block {
    return $_[0]->{ _BLOCK };
}



sub blocks {
    return $_[0]->{ _DEFBLOCKS };
}



sub variables {
    return $_[0]->{ _VARIABLES };
}


sub process {
    my ($self, $context) = @_;
    my $defblocks = $self->{ _DEFBLOCKS };
    my $output;


    # check we're not already visiting this template
    return $context->throw(Template::Constants::ERROR_FILE, 
                           "recursion into '$self->{ name }'")
        if $self->{ _HOT } && ! $context->{ RECURSION };   ## RETURN ##

    $context->visit($self, $defblocks);

    $self->{ _HOT } = 1;
    eval {
        my $block = $self->{ _BLOCK };
        $output = &$block($context);
    };
    $self->{ _HOT } = 0;

    $context->leave();

    die $context->catch($@)
        if $@;
        
    return $output;
}



sub AUTOLOAD {
    my $self   = shift;
    my $method = $AUTOLOAD;

    $method =~ s/.*:://;
    return if $method eq 'DESTROY';
    return $self->{ $method };
}





sub _dump {
    my $self = shift;
    my $dblks;
    my $output = "$self : $self->{ name }\n";

    $output .= "BLOCK: $self->{ _BLOCK }\nDEFBLOCKS:\n";

    if ($dblks = $self->{ _DEFBLOCKS }) {
        foreach my $b (keys %$dblks) {
            $output .= "    $b: $dblks->{ $b }\n";
        }
    }

    return $output;
}




sub as_perl {
    my ($class, $content) = @_;
    my ($block, $defblocks, $metadata) = @$content{ qw( BLOCK DEFBLOCKS METADATA ) };

    $block =~ s/\s+$//;

    $defblocks = join('', map {
        my $code = $defblocks->{ $_ };
        $code =~ s/\s*$//;
        "        '$_' => $code,\n";
    } keys %$defblocks);
    $defblocks =~ s/\s+$//;

    $metadata = join('', map { 
        my $x = $metadata->{ $_ }; 
        $x =~ s/(['\\])/\\$1/g; 
        "        '$_' => '$x',\n";
    } keys %$metadata);
    $metadata =~ s/\s+$//;

    return <<EOF

$class->new({
    METADATA => {
$metadata
    },
    BLOCK => $block,
    DEFBLOCKS => {
$defblocks
    },
});
EOF
}



sub write_perl_file {
    my ($class, $file, $content) = @_;
    my ($fh, $tmpfile);
    
    return $class->error("invalid filename: $file")
        unless $file =~ /^(.+)$/s;

    eval {
        require File::Temp;
        require File::Basename;
        ($fh, $tmpfile) = File::Temp::tempfile( 
            DIR => File::Basename::dirname($file) 
        );
        my $perlcode = $class->as_perl($content) || die $!;
        
        if ($UNICODE && is_utf8($perlcode)) {
            $perlcode = "use utf8;\n\n$perlcode";
            binmode $fh, ":utf8";
        }
        print $fh $perlcode;
        close($fh);
    };
    return $class->error($@) if $@;
    return rename($tmpfile, $file)
        || $class->error($!);
}



sub catch_warnings {
    $COMPERR .= join('', @_); 
}

    
1;


}
#
# Inline include of Template/Exception.pm
#
BEGIN { $INC{'Template/Exception.pm'} = 'dummy/Template/Exception.pm'; }
BEGIN {
#line 0 "Template/Exception.pm"

package Template::Exception;

use strict;
use warnings;
use constant TYPE  => 0;
use constant INFO  => 1;
use constant TEXT  => 2;
use overload q|""| => "as_string", fallback => 1;

our $VERSION = 2.70;



sub new {
    my ($class, $type, $info, $textref) = @_;
    bless [ $type, $info, $textref ], $class;
}



sub type {
    $_[0]->[ TYPE ];
}

sub info {
    $_[0]->[ INFO ];
}

sub type_info {
    my $self = shift;
    @$self[ TYPE, INFO ];
}


sub text {
    my ($self, $newtextref) = @_;
    my $textref = $self->[ TEXT ];
    
    if ($newtextref) {
        $$newtextref .= $$textref if $textref && $textref ne $newtextref;
        $self->[ TEXT ] = $newtextref;
        return '';
    }
    elsif ($textref) {
        return $$textref;
    }
    else {
        return '';
    }
}



sub as_string {
    my $self = shift;
    return $self->[ TYPE ] . ' error - ' . $self->[ INFO ];
}



sub select_handler {
    my ($self, @options) = @_;
    my $type = $self->[ TYPE ];
    my %hlut;
    @hlut{ @options } = (1) x @options;

    while ($type) {
        return $type if $hlut{ $type };

        # strip .element from the end of the exception type to find a 
        # more generic handler
        $type =~ s/\.?[^\.]*$//;
    }
    return undef;
}
    
1;


}
#
# Inline include of Template/Service.pm
#
BEGIN { $INC{'Template/Service.pm'} = 'dummy/Template/Service.pm'; }
BEGIN {
#line 0 "Template/Service.pm"

package Template::Service;

use strict;
use warnings;
use base 'Template::Base';
use Template::Config;
use Template::Exception;
use Template::Constants;
use Scalar::Util 'blessed';

use constant EXCEPTION => 'Template::Exception';

our $VERSION = 2.80;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';




sub process {
    my ($self, $template, $params) = @_;
    my $context = $self->{ CONTEXT };
    my ($name, $output, $procout, $error);
    $output = '';

    $self->debug("process($template, ", 
                 defined $params ? $params : '<no params>',
                 ')') if $self->{ DEBUG };

    $context->reset()
        if $self->{ AUTO_RESET };

    # pre-request compiled template from context so that we can alias it 
    # in the stash for pre-processed templates to reference
    eval { $template = $context->template($template) };
    return $self->error($@)
        if $@;

    # localise the variable stash with any parameters passed
    # and set the 'template' variable
    $params ||= { };
    # TODO: change this to C<||=> so we can use a template parameter
    $params->{ template } = $template 
        unless ref $template eq 'CODE';
    $context->localise($params);

    SERVICE: {
        # PRE_PROCESS
        eval {
            foreach $name (@{ $self->{ PRE_PROCESS } }) {
                $self->debug("PRE_PROCESS: $name") if $self->{ DEBUG };
                $output .= $context->process($name);
            }
        };
        last SERVICE if ($error = $@);

        # PROCESS
        eval {
            foreach $name (@{ $self->{ PROCESS } || [ $template ] }) {
                $self->debug("PROCESS: $name") if $self->{ DEBUG };
                $procout .= $context->process($name);
            }
        };
        if ($error = $@) {
            last SERVICE
                unless defined ($procout = $self->_recover(\$error));
        }
        
        if (defined $procout) {
            # WRAPPER
            eval {
                foreach $name (reverse @{ $self->{ WRAPPER } }) {
                    $self->debug("WRAPPER: $name") if $self->{ DEBUG };
                    $procout = $context->process($name, { content => $procout });
                }
            };
            last SERVICE if ($error = $@);
            $output .= $procout;
        }
        
        # POST_PROCESS
        eval {
            foreach $name (@{ $self->{ POST_PROCESS } }) {
                $self->debug("POST_PROCESS: $name") if $self->{ DEBUG };
                $output .= $context->process($name);
            }
        };
        last SERVICE if ($error = $@);
    }

    $context->delocalise();
    delete $params->{ template };

    if ($error) {
    #   $error = $error->as_string if ref $error;
        return $self->error($error);
    }

    return $output;
}



sub context {
    return $_[0]->{ CONTEXT };
}



sub _init {
    my ($self, $config) = @_;
    my ($item, $data, $context, $block, $blocks);
    my $delim = $config->{ DELIMITER };
    $delim = ':' unless defined $delim;

    # coerce PRE_PROCESS, PROCESS and POST_PROCESS to arrays if necessary, 
    # by splitting on non-word characters
    foreach $item (qw( PRE_PROCESS PROCESS POST_PROCESS WRAPPER )) {
        $data = $config->{ $item };
        $self->{ $item } = [ ], next unless (defined $data);
        $data = [ split($delim, $data || '') ]
            unless ref $data eq 'ARRAY';
        $self->{ $item } = $data;
    }
    # unset PROCESS option unless explicitly specified in config
    $self->{ PROCESS } = undef
        unless defined $config->{ PROCESS };
    
    $self->{ ERROR      } = $config->{ ERROR } || $config->{ ERRORS };
    $self->{ AUTO_RESET } = defined $config->{ AUTO_RESET }
                            ? $config->{ AUTO_RESET } : 1;
    $self->{ DEBUG      } = ( $config->{ DEBUG } || 0 )
                            & Template::Constants::DEBUG_SERVICE;
    
    $context = $self->{ CONTEXT } = $config->{ CONTEXT }
        || Template::Config->context($config)
        || return $self->error(Template::Config->error);
    
    return $self;
}



sub _recover {
    my ($self, $error) = @_;
    my $context = $self->{ CONTEXT };
    my ($hkey, $handler, $output);

    # there shouldn't ever be a non-exception object received at this
    # point... unless a module like CGI::Carp messes around with the 
    # DIE handler. 
    return undef
        unless blessed($$error) && $$error->isa(EXCEPTION);

    # a 'stop' exception is thrown by [% STOP %] - we return the output
    # buffer stored in the exception object
    return $$error->text()
        if $$error->type() eq 'stop';

    my $handlers = $self->{ ERROR }
        || return undef;                    ## RETURN

    if (ref $handlers eq 'HASH') {
        if ($hkey = $$error->select_handler(keys %$handlers)) {
            $handler = $handlers->{ $hkey };
            $self->debug("using error handler for $hkey") if $self->{ DEBUG };
        }
        elsif ($handler = $handlers->{ default }) {
            # use default handler
            $self->debug("using default error handler") if $self->{ DEBUG };
        }
        else {
            return undef;                   ## RETURN
        }
    }
    else {
        $handler = $handlers;
        $self->debug("using default error handler") if $self->{ DEBUG };
    }
    
    eval { $handler = $context->template($handler) };
    if ($@) {
        $$error = $@;
        return undef;                       ## RETURN
    };
    
    $context->stash->set('error', $$error);
    eval {
        $output .= $context->process($handler);
    };
    if ($@) {
        $$error = $@;
        return undef;                       ## RETURN
    }

    return $output;
}




sub _dump {
    my $self = shift;
    my $context = $self->{ CONTEXT }->_dump();
    $context =~ s/\n/\n    /gm;

    my $error = $self->{ ERROR };
    $error = join('', 
          "{\n",
          (map { "    $_ => $error->{ $_ }\n" }
           keys %$error),
          "}\n")
    if ref $error;
    
    local $" = ', ';
    return <<EOF;
$self
PRE_PROCESS  => [ @{ $self->{ PRE_PROCESS } } ]
POST_PROCESS => [ @{ $self->{ POST_PROCESS } } ]
ERROR        => $error
CONTEXT      => $context
EOF
}


1;


}
#
# Inline include of Template/Provider.pm
#
BEGIN { $INC{'Template/Provider.pm'} = 'dummy/Template/Provider.pm'; }
BEGIN {
#line 0 "Template/Provider.pm"

package Template::Provider;

use strict;
use warnings;
use base 'Template::Base';
use Template::Config;
use Template::Constants;
use Template::Document;
use File::Basename;
use File::Spec;

use constant PREV   => 0;
use constant NAME   => 1;   # template name -- indexed by this name in LOOKUP
use constant DATA   => 2;   # Compiled template
use constant LOAD   => 3;   # mtime of template
use constant NEXT   => 4;   # link to next item in cache linked list
use constant STAT   => 5;   # Time last stat()ed

our $VERSION = 2.94;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';

our $DOCUMENT = 'Template::Document' unless defined $DOCUMENT;

our $STAT_TTL = 1 unless defined $STAT_TTL;

our $MAX_DIRS = 64 unless defined $MAX_DIRS;

our $UNICODE = $] > 5.007 ? 1 : 0;

my $boms = [
    'UTF-8'    => "\x{ef}\x{bb}\x{bf}",
    'UTF-32BE' => "\x{0}\x{0}\x{fe}\x{ff}",
    'UTF-32LE' => "\x{ff}\x{fe}\x{0}\x{0}",
    'UTF-16BE' => "\x{fe}\x{ff}",
    'UTF-16LE' => "\x{ff}\x{fe}",
];

our $RELATIVE_PATH = qr[(?:^|/)\.+/];


BEGIN {
    if ($] < 5.006) {
        package bytes;
        $INC{'bytes.pm'} = 1;
    }
}




sub fetch {
    my ($self, $name) = @_;
    my ($data, $error);


    if (ref $name) {
        # $name can be a reference to a scalar, GLOB or file handle
        ($data, $error) = $self->_load($name);
        ($data, $error) = $self->_compile($data)
            unless $error;
        $data = $data->{ data }
            unless $error;
    }
    elsif (File::Spec->file_name_is_absolute($name)) {
        # absolute paths (starting '/') allowed if ABSOLUTE set
        ($data, $error) = $self->{ ABSOLUTE }
            ? $self->_fetch($name)
            : $self->{ TOLERANT }
                ? (undef, Template::Constants::STATUS_DECLINED)
            : ("$name: absolute paths are not allowed (set ABSOLUTE option)",
               Template::Constants::STATUS_ERROR);
    }
    elsif ($name =~ m/$RELATIVE_PATH/o) {
        # anything starting "./" is relative to cwd, allowed if RELATIVE set
        ($data, $error) = $self->{ RELATIVE }
            ? $self->_fetch($name)
            : $self->{ TOLERANT }
                ? (undef, Template::Constants::STATUS_DECLINED)
            : ("$name: relative paths are not allowed (set RELATIVE option)",
               Template::Constants::STATUS_ERROR);
    }
    else {
        # otherwise, it's a file name relative to INCLUDE_PATH
        ($data, $error) = $self->{ INCLUDE_PATH }
            ? $self->_fetch_path($name)
            : (undef, Template::Constants::STATUS_DECLINED);
    }


    return ($data, $error);
}



sub store {
    my ($self, $name, $data) = @_;
    $self->_store($name, {
        data => $data,
        load => 0,
    });
}



sub load {
    my ($self, $name) = @_;
    my ($data, $error);
    my $path = $name;

    if (File::Spec->file_name_is_absolute($name)) {
        # absolute paths (starting '/') allowed if ABSOLUTE set
        $error = "$name: absolute paths are not allowed (set ABSOLUTE option)"
            unless $self->{ ABSOLUTE };
    }
    elsif ($name =~ m[$RELATIVE_PATH]o) {
        # anything starting "./" is relative to cwd, allowed if RELATIVE set
        $error = "$name: relative paths are not allowed (set RELATIVE option)"
            unless $self->{ RELATIVE };
    }
    else {
      INCPATH: {
          # otherwise, it's a file name relative to INCLUDE_PATH
          my $paths = $self->paths()
              || return ($self->error(), Template::Constants::STATUS_ERROR);

          foreach my $dir (@$paths) {
              $path = File::Spec->catfile($dir, $name);
              last INCPATH
                  if $self->_template_modified($path);
          }
          undef $path;      # not found
      }
    }

    # Now fetch the content
    ($data, $error) = $self->_template_content($path)
        if defined $path && !$error;

    if ($error) {
        return $self->{ TOLERANT }
            ? (undef, Template::Constants::STATUS_DECLINED)
            : ($error, Template::Constants::STATUS_ERROR);
    }
    elsif (! defined $path) {
        return (undef, Template::Constants::STATUS_DECLINED);
    }
    else {
        return ($data, Template::Constants::STATUS_OK);
    }
}




sub include_path {
     my ($self, $path) = @_;
     $self->{ INCLUDE_PATH } = $path if $path;
     return $self->{ INCLUDE_PATH };
}



sub paths {
    my $self   = shift;
    my @ipaths = @{ $self->{ INCLUDE_PATH } };
    my (@opaths, $dpaths, $dir);
    my $count = $MAX_DIRS;

    while (@ipaths && --$count) {
        $dir = shift @ipaths || next;

        # $dir can be a sub or object ref which returns a reference
        # to a dynamically generated list of search paths.

        if (ref $dir eq 'CODE') {
            eval { $dpaths = &$dir() };
            if ($@) {
                chomp $@;
                return $self->error($@);
            }
            unshift(@ipaths, @$dpaths);
            next;
        }
        elsif (ref($dir) && UNIVERSAL::can($dir, 'paths')) {
            $dpaths = $dir->paths()
                || return $self->error($dir->error());
            unshift(@ipaths, @$dpaths);
            next;
        }
        else {
            push(@opaths, $dir);
        }
    }
    return $self->error("INCLUDE_PATH exceeds $MAX_DIRS directories")
        if @ipaths;

    return \@opaths;
}



sub DESTROY {
    my $self = shift;
    my ($slot, $next);

    $slot = $self->{ HEAD };
    while ($slot) {
        $next = $slot->[ NEXT ];
        undef $slot->[ PREV ];
        undef $slot->[ NEXT ];
        $slot = $next;
    }
    undef $self->{ HEAD };
    undef $self->{ TAIL };
}






sub _init {
    my ($self, $params) = @_;
    my $size = $params->{ CACHE_SIZE   };
    my $path = $params->{ INCLUDE_PATH } || '.';
    my $cdir = $params->{ COMPILE_DIR  } || '';
    my $dlim = $params->{ DELIMITER    };
    my $debug;

    # tweak delim to ignore C:/
    unless (defined $dlim) {
        $dlim = ($^O eq 'MSWin32') ? ':(?!\\/)' : ':';
    }

    # coerce INCLUDE_PATH to an array ref, if not already so
    $path = [ split(/$dlim/, $path) ]
        unless ref $path eq 'ARRAY';

    # don't allow a CACHE_SIZE 1 because it breaks things and the
    # additional checking isn't worth it
    $size = 2
        if defined $size && ($size == 1 || $size < 0);

    if (defined ($debug = $params->{ DEBUG })) {
        $self->{ DEBUG } = $debug & ( Template::Constants::DEBUG_PROVIDER
                                    | Template::Constants::DEBUG_FLAGS );
    }
    else {
        $self->{ DEBUG } = $DEBUG;
    }

    if ($self->{ DEBUG }) {
        local $" = ', ';
        $self->debug("creating cache of ",
                     defined $size ? $size : 'unlimited',
                     " slots for [ @$path ]");
    }

    # create COMPILE_DIR and sub-directories representing each INCLUDE_PATH
    # element in which to store compiled files
    if ($cdir) {
        require File::Path;
        foreach my $dir (@$path) {
            next if ref $dir;
            my $wdir = $dir;
            $wdir =~ s[:][]g if $^O eq 'MSWin32';
            $wdir =~ /(.*)/;  # untaint
            $wdir = "$1";     # quotes work around bug in Strawberry Perl
            $wdir = File::Spec->catfile($cdir, $wdir);
            File::Path::mkpath($wdir) unless -d $wdir;
        }
    }

    $self->{ LOOKUP       } = { };
    $self->{ NOTFOUND     } = { };  # Tracks templates *not* found.
    $self->{ SLOTS        } = 0;
    $self->{ SIZE         } = $size;
    $self->{ INCLUDE_PATH } = $path;
    $self->{ DELIMITER    } = $dlim;
    $self->{ COMPILE_DIR  } = $cdir;
    $self->{ COMPILE_EXT  } = $params->{ COMPILE_EXT } || '';
    $self->{ ABSOLUTE     } = $params->{ ABSOLUTE } || 0;
    $self->{ RELATIVE     } = $params->{ RELATIVE } || 0;
    $self->{ TOLERANT     } = $params->{ TOLERANT } || 0;
    $self->{ DOCUMENT     } = $params->{ DOCUMENT } || $DOCUMENT;
    $self->{ PARSER       } = $params->{ PARSER   };
    $self->{ DEFAULT      } = $params->{ DEFAULT  };
    $self->{ ENCODING     } = $params->{ ENCODING };
    $self->{ STAT_TTL     } = $params->{ STAT_TTL } || $STAT_TTL;
    $self->{ PARAMS       } = $params;

    # look for user-provided UNICODE parameter or use default from package var
    $self->{ UNICODE      } = defined $params->{ UNICODE }
                                    ? $params->{ UNICODE } : $UNICODE;

    return $self;
}



sub _fetch {
    my ($self, $name, $t_name) = @_;
    my $stat_ttl = $self->{ STAT_TTL };

    $self->debug("_fetch($name)") if $self->{ DEBUG };

    # First see if the named template is in the memory cache
    if ((my $slot = $self->{ LOOKUP }->{ $name })) {
        # Test if cache is fresh, and reload/compile if not.
        my ($data, $error) = $self->_refresh($slot);

        return $error
            ? ( $data, $error )     # $data may contain error text
            : $slot->[ DATA ];      # returned document object
    }

    # Otherwise, see if we already know the template is not found
    if (my $last_stat_time = $self->{ NOTFOUND }->{ $name }) {
        my $expires_in = $last_stat_time + $stat_ttl - time;
        if ($expires_in > 0) {
            $self->debug(" file [$name] in negative cache.  Expires in $expires_in seconds")
                if $self->{ DEBUG };
            return (undef, Template::Constants::STATUS_DECLINED);
        }
        else {
            delete $self->{ NOTFOUND }->{ $name };
        }
    }

    # Is there an up-to-date compiled version on disk?
    if ($self->_compiled_is_current($name)) {
        # require() the compiled template.
        my $compiled_template = $self->_load_compiled( $self->_compiled_filename($name) );

        # Store and return the compiled template
        return $self->store( $name, $compiled_template ) if $compiled_template;

        # Problem loading compiled template:
        # warn and continue to fetch source template
        warn($self->error(), "\n");
    }

    # load template from source
    my ($template, $error) = $self->_load($name, $t_name);

    if ($error) {
        # Template could not be fetched.  Add to the negative/notfound cache.
        $self->{ NOTFOUND }->{ $name } = time;
        return ( $template, $error );
    }

    # compile template source
    ($template, $error) = $self->_compile($template, $self->_compiled_filename($name) );

    if ($error) {
        # return any compile time error
        return ($template, $error);
    }
    else {
        # Store compiled template and return it
        return $self->store($name, $template->{data}) ;
    }
}



sub _fetch_path {
    my ($self, $name) = @_;

    $self->debug("_fetch_path($name)") if $self->{ DEBUG };

    # the template may have been stored using a non-filename name
    # so look for the plain name in the cache first
    if ((my $slot = $self->{ LOOKUP }->{ $name })) {
        # cached entry exists, so refresh slot and extract data
        my ($data, $error) = $self->_refresh($slot);

        return $error
            ? ($data, $error)
            : ($slot->[ DATA ], $error );
    }

    my $paths = $self->paths
        || return ( $self->error, Template::Constants::STATUS_ERROR );

    # search the INCLUDE_PATH for the file, in cache or on disk
    foreach my $dir (@$paths) {
        my $path = File::Spec->catfile($dir, $name);

        $self->debug("searching path: $path\n") if $self->{ DEBUG };

        my ($data, $error) = $self->_fetch( $path, $name );

        # Return if no error or if a serious error.
        return ( $data, $error )
            if !$error || $error == Template::Constants::STATUS_ERROR;

    }

    # not found in INCLUDE_PATH, now try DEFAULT
    return $self->_fetch_path( $self->{DEFAULT} )
        if defined $self->{DEFAULT} && $name ne $self->{DEFAULT};

    # We could not handle this template name
    return (undef, Template::Constants::STATUS_DECLINED);
}

sub _compiled_filename {
    my ($self, $file) = @_;
    my ($compext, $compdir) = @$self{ qw( COMPILE_EXT COMPILE_DIR ) };
    my ($path, $compiled);

    return undef
        unless $compext || $compdir;

    $path = $file;
    $path =~ /^(.+)$/s or die "invalid filename: $path";
    $path =~ s[:][]g if $^O eq 'MSWin32';

    $compiled = "$path$compext";
    $compiled = File::Spec->catfile($compdir, $compiled) if length $compdir;

    return $compiled;
}

sub _load_compiled {
    my ($self, $file) = @_;
    my $compiled;

    # load compiled template via require();  we zap any
    # %INC entry to ensure it is reloaded (we don't
    # want 1 returned by require() to say it's in memory)
    delete $INC{ $file };
    eval { $compiled = require $file; };
    return $@
        ? $self->error("compiled template $compiled: $@")
        : $compiled;
}


sub _load {
    my ($self, $name, $alias) = @_;
    my ($data, $error);
    my $tolerant = $self->{ TOLERANT };
    my $now = time;

    $alias = $name unless defined $alias or ref $name;

    $self->debug("_load($name, ", defined $alias ? $alias : '<no alias>',
                 ')') if $self->{ DEBUG };

    # SCALAR ref is the template text
    if (ref $name eq 'SCALAR') {
        # $name can be a SCALAR reference to the input text...
        return {
            name => defined $alias ? $alias : 'input text',
            path => defined $alias ? $alias : 'input text',
            text => $$name,
            time => $now,
            load => 0,
        };
    }

    # Otherwise, assume GLOB as a file handle
    if (ref $name) {
        local $/;
        my $text = <$name>;
        $text = $self->_decode_unicode($text) if $self->{ UNICODE };
        return {
            name => defined $alias ? $alias : 'input file handle',
            path => defined $alias ? $alias : 'input file handle',
            text => $text,
            time => $now,
            load => 0,
        };
    }

    # Otherwise, it's the name of the template
    if ( $self->_template_modified( $name ) ) {  # does template exist?
        my ($text, $error, $mtime ) = $self->_template_content( $name );
        unless ( $error )  {
            $text = $self->_decode_unicode($text) if $self->{ UNICODE };
            return {
                name => $alias,
                path => $name,
                text => $text,
                time => $mtime,
                load => $now,
            };
        }

        return ( $error, Template::Constants::STATUS_ERROR )
            unless $tolerant;
    }

    # Unable to process template, pass onto the next Provider.
    return (undef, Template::Constants::STATUS_DECLINED);
}



sub _refresh {
    my ($self, $slot) = @_;
    my $stat_ttl = $self->{ STAT_TTL };
    my ($head, $file, $data, $error);

    $self->debug("_refresh([ ",
                 join(', ', map { defined $_ ? $_ : '<undef>' } @$slot),
                 '])') if $self->{ DEBUG };

    # if it's more than $STAT_TTL seconds since we last performed a
    # stat() on the file then we need to do it again and see if the file
    # time has changed
    my $now = time;
    my $expires_in_sec = $slot->[ STAT ] + $stat_ttl - $now;

    if ( $expires_in_sec <= 0 ) {  # Time to check!
        $slot->[ STAT ] = $now;

        # Grab mtime of template.
        # Seems like this should be abstracted to compare to
        # just ask for a newer compiled template (if it's newer)
        # and let that check for a newer template source.
        my $template_mtime = $self->_template_modified( $slot->[ NAME ] );
        if ( ! defined $template_mtime || ( $template_mtime != $slot->[ LOAD ] )) {
            $self->debug("refreshing cache file ", $slot->[ NAME ])
                if $self->{ DEBUG };

            ($data, $error) = $self->_load($slot->[ NAME ], $slot->[ DATA ]->{ name });
            ($data, $error) = $self->_compile($data)
                unless $error;

            if ($error) {
                # if the template failed to load/compile then we wipe out the
                # STAT entry.  This forces the provider to try and reload it
                # each time instead of using the previously cached version
                # until $STAT_TTL is next up
                $slot->[ STAT ] = 0;
            }
            else {
                $slot->[ DATA ] = $data->{ data };
                $slot->[ LOAD ] = $data->{ time };
            }
        }

    } elsif ( $self->{ DEBUG } ) {
        $self->debug( sprintf('STAT_TTL not met for file [%s].  Expires in %d seconds',
                        $slot->[ NAME ], $expires_in_sec ) );
    }

    # Move this slot to the head of the list
    unless( $self->{ HEAD } == $slot ) {
        # remove existing slot from usage chain...
        if ($slot->[ PREV ]) {
            $slot->[ PREV ]->[ NEXT ] = $slot->[ NEXT ];
        }
        else {
            $self->{ HEAD } = $slot->[ NEXT ];
        }
        if ($slot->[ NEXT ]) {
            $slot->[ NEXT ]->[ PREV ] = $slot->[ PREV ];
        }
        else {
            $self->{ TAIL } = $slot->[ PREV ];
        }

        # ..and add to start of list
        $head = $self->{ HEAD };
        $head->[ PREV ] = $slot if $head;
        $slot->[ PREV ] = undef;
        $slot->[ NEXT ] = $head;
        $self->{ HEAD } = $slot;
    }

    return ($data, $error);
}




sub _store {
    my ($self, $name, $data, $compfile) = @_;
    my $size = $self->{ SIZE };
    my ($slot, $head);

    # Return if memory cache disabled.  (overriding code should also check)
    # $$$ What's the expected behaviour of store()?  Can't tell from the
    # docs if you can call store() when SIZE = 0.
    return $data->{data} if defined $size and !$size;

    # extract the compiled template from the data hash
    $data = $data->{ data };
    $self->debug("_store($name, $data)") if $self->{ DEBUG };

    # check the modification time -- extra stat here
    my $load = $self->_modified($name);

    if (defined $size && $self->{ SLOTS } >= $size) {
        # cache has reached size limit, so reuse oldest entry
        $self->debug("reusing oldest cache entry (size limit reached: $size)\nslots: $self->{ SLOTS }") if $self->{ DEBUG };

        # remove entry from tail of list
        $slot = $self->{ TAIL };
        $slot->[ PREV ]->[ NEXT ] = undef;
        $self->{ TAIL } = $slot->[ PREV ];

        # remove name lookup for old node
        delete $self->{ LOOKUP }->{ $slot->[ NAME ] };

        # add modified node to head of list
        $head = $self->{ HEAD };
        $head->[ PREV ] = $slot if $head;
        @$slot = ( undef, $name, $data, $load, $head, time );
        $self->{ HEAD } = $slot;

        # add name lookup for new node
        $self->{ LOOKUP }->{ $name } = $slot;
    }
    else {
        # cache is under size limit, or none is defined

        $self->debug("adding new cache entry") if $self->{ DEBUG };

        # add new node to head of list
        $head = $self->{ HEAD };
        $slot = [ undef, $name, $data, $load, $head, time ];
        $head->[ PREV ] = $slot if $head;
        $self->{ HEAD } = $slot;
        $self->{ TAIL } = $slot unless $self->{ TAIL };

        # add lookup from name to slot and increment nslots
        $self->{ LOOKUP }->{ $name } = $slot;
        $self->{ SLOTS }++;
    }

    return $data;
}



sub _compile {
    my ($self, $data, $compfile) = @_;
    my $text = $data->{ text };
    my ($parsedoc, $error);

    $self->debug("_compile($data, ",
                 defined $compfile ? $compfile : '<no compfile>', ')')
        if $self->{ DEBUG };

    my $parser = $self->{ PARSER }
        ||= Template::Config->parser($self->{ PARAMS })
        ||  return (Template::Config->error(), Template::Constants::STATUS_ERROR);

    # discard the template text - we don't need it any more
    delete $data->{ text };

    # call parser to compile template into Perl code
    if ($parsedoc = $parser->parse($text, $data)) {

        $parsedoc->{ METADATA } = {
            'name'    => $data->{ name },
            'modtime' => $data->{ time },
            %{ $parsedoc->{ METADATA } },
        };

        # write the Perl code to the file $compfile, if defined
        if ($compfile) {
            my $basedir = &File::Basename::dirname($compfile);
            $basedir =~ /(.*)/;
            $basedir = $1;

            unless (-d $basedir) {
                eval { File::Path::mkpath($basedir) };
                $error = "failed to create compiled templates directory: $basedir ($@)"
                    if ($@);
            }

            unless ($error) {
                my $docclass = $self->{ DOCUMENT };
                $error = 'cache failed to write '
                    . &File::Basename::basename($compfile)
                    . ': ' . $docclass->error()
                    unless $docclass->write_perl_file($compfile, $parsedoc);
            }

            # set atime and mtime of newly compiled file, don't bother
            # if time is undef
            if (!defined($error) && defined $data->{ time }) {
                my ($cfile) = $compfile =~ /^(.+)$/s or do {
                    return("invalid filename: $compfile",
                           Template::Constants::STATUS_ERROR);
                };

                my ($ctime) = $data->{ time } =~ /^(\d+)$/;
                unless ($ctime || $ctime eq 0) {
                    return("invalid time: $ctime",
                           Template::Constants::STATUS_ERROR);
                }
                utime($ctime, $ctime, $cfile);

                $self->debug(" cached compiled template to file [$compfile]")
                    if $self->{ DEBUG };
            }
        }

        unless ($error) {
            return $data                                        ## RETURN ##
                if $data->{ data } = $DOCUMENT->new($parsedoc);
            $error = $Template::Document::ERROR;
        }
    }
    else {
        $error = Template::Exception->new( 'parse', "$data->{ name } " .
                                           $parser->error() );
    }

    # return STATUS_ERROR, or STATUS_DECLINED if we're being tolerant
    return $self->{ TOLERANT }
        ? (undef, Template::Constants::STATUS_DECLINED)
        : ($error,  Template::Constants::STATUS_ERROR)
}


sub _compiled_is_current {
    my ( $self, $template_name ) = @_;
    my $compiled_name   = $self->_compiled_filename($template_name) || return;
    my $compiled_mtime  = (stat($compiled_name))[9] || return;
    my $template_mtime  = $self->_template_modified( $template_name ) || return;

    # This was >= in the 2.15, but meant that downgrading
    # a source template would not get picked up.
    return $compiled_mtime == $template_mtime;
}



sub _template_modified {
    my $self = shift;
    my $template = shift || return;
    return (stat( $template ))[9];
}


sub _template_content {
    my ($self, $path) = @_;

    return (undef, "No path specified to fetch content from ")
        unless $path;

    my $data;
    my $mod_date;
    my $error;

    local *FH;
    if(-d $path) {
        $error = "$path: not a file";
    }
    elsif (open(FH, "< $path")) {
        local $/;
        binmode(FH);
        $data = <FH>;
        $mod_date = (stat($path))[9];
        close(FH);
    }
    else {
        $error = "$path: $!";
    }

    return wantarray
        ? ( $data, $error, $mod_date )
        : $data;
}



sub _modified {
    my ($self, $name, $time) = @_;
    my $load = $self->_template_modified($name)
        || return $time ? 1 : 0;

    return $time
         ? $load > $time
         : $load;
}


sub _dump {
    my $self = shift;
    my $size = $self->{ SIZE };
    my $parser = $self->{ PARSER };
    $parser = $parser ? $parser->_dump() : '<no parser>';
    $parser =~ s/\n/\n    /gm;
    $size = 'unlimited' unless defined $size;

    my $output = "[Template::Provider] {\n";
    my $format = "    %-16s => %s\n";
    my $key;

    $output .= sprintf($format, 'INCLUDE_PATH',
                       '[ ' . join(', ', @{ $self->{ INCLUDE_PATH } }) . ' ]');
    $output .= sprintf($format, 'CACHE_SIZE', $size);

    foreach $key (qw( ABSOLUTE RELATIVE TOLERANT DELIMITER
                      COMPILE_EXT COMPILE_DIR )) {
        $output .= sprintf($format, $key, $self->{ $key });
    }
    $output .= sprintf($format, 'PARSER', $parser);


    local $" = ', ';
    my $lookup = $self->{ LOOKUP };
    $lookup = join('', map {
        sprintf("    $format", $_, defined $lookup->{ $_ }
                ? ('[ ' . join(', ', map { defined $_ ? $_ : '<undef>' }
                               @{ $lookup->{ $_ } }) . ' ]') : '<undef>');
    } sort keys %$lookup);
    $lookup = "{\n$lookup    }";

    $output .= sprintf($format, LOOKUP => $lookup);

    $output .= '}';
    return $output;
}



sub _dump_cache {
    my $self = shift;
    my ($node, $lut, $count);

    $count = 0;
    if ($node = $self->{ HEAD }) {
        while ($node) {
            $lut->{ $node } = $count++;
            $node = $node->[ NEXT ];
        }
        $node = $self->{ HEAD };
        print STDERR "CACHE STATE:\n";
        print STDERR "  HEAD: ", $self->{ HEAD }->[ NAME ], "\n";
        print STDERR "  TAIL: ", $self->{ TAIL }->[ NAME ], "\n";
        while ($node) {
            my ($prev, $name, $data, $load, $next) = @$node;
            $prev = $prev ? "#$lut->{ $prev }<-": '<undef>';
            $next = $next ? "->#$lut->{ $next }": '<undef>';
            print STDERR "   #$lut->{ $node } : [ $prev, $name, $data, $load, $next ]\n";
            $node = $node->[ NEXT ];
        }
    }
}


sub _decode_unicode {
    my $self   = shift;
    my $string = shift;
    return undef unless defined $string;

    use bytes;
    require Encode;

    return $string if Encode::is_utf8( $string );

    # try all the BOMs in order looking for one (order is important
    # 32bit BOMs look like 16bit BOMs)

    my $count  = 0;

    while ($count < @{ $boms }) {
        my $enc = $boms->[$count++];
        my $bom = $boms->[$count++];

        # does the string start with the bom?
        if ($bom eq substr($string, 0, length($bom))) {
            # decode it and hand it back
            return Encode::decode($enc, substr($string, length($bom)), 1);
        }
    }

    return $self->{ ENCODING }
        ? Encode::decode( $self->{ ENCODING }, $string )
        : $string;
}


1;


}
#
# Inline include of Template.pm
#
BEGIN { $INC{'Template.pm'} = 'dummy/Template.pm'; }
BEGIN {
#line 0 "Template.pm"

package Template;

use strict;
use warnings;
use 5.006;
use base 'Template::Base';

use Template::Config;
use Template::Constants;
use Template::Provider;
use Template::Service;
use File::Basename;
use File::Path;
use Scalar::Util qw(blessed);

our $VERSION = '2.26';
our $ERROR   = '';
our $DEBUG   = 0;
our $BINMODE = 0 unless defined $BINMODE;
our $AUTOLOAD;

Template::Config->preload() if $ENV{ MOD_PERL };



sub process {
    my ($self, $template, $vars, $outstream, @opts) = @_;
    my ($output, $error);
    my $options = (@opts == 1) && ref($opts[0]) eq 'HASH'
        ? shift(@opts) : { @opts };

    $options->{ binmode } = $BINMODE
        unless defined $options->{ binmode };

    # we're using this for testing in t/output.t and t/filter.t so
    # don't remove it if you don't want tests to fail...
    $self->DEBUG("set binmode\n") if $DEBUG && $options->{ binmode };

    $output = $self->{ SERVICE }->process($template, $vars);

    if (defined $output) {
        $outstream ||= $self->{ OUTPUT };
        unless (ref $outstream) {
            my $outpath = $self->{ OUTPUT_PATH };
            $outstream = "$outpath/$outstream" if $outpath;
        }

        # send processed template to output stream, checking for error
        return ($self->error($error))
            if ($error = &_output($outstream, \$output, $options));

        return 1;
    }
    else {
        return $self->error($self->{ SERVICE }->error);
    }
}



sub service {
    my $self = shift;
    return $self->{ SERVICE };
}



sub context {
    my $self = shift;
    return $self->{ SERVICE }->{ CONTEXT };
}

sub template {
    shift->context->template(@_);
}



sub _init {
    my ($self, $config) = @_;

    # convert any textual DEBUG args to numerical form
    my $debug = $config->{ DEBUG };
    $config->{ DEBUG } = Template::Constants::debug_flags($self, $debug)
        || return if defined $debug && $debug !~ /^\d+$/;

    # prepare a namespace handler for any CONSTANTS definition
    if (my $constants = $config->{ CONSTANTS }) {
        my $ns  = $config->{ NAMESPACE } ||= { };
        my $cns = $config->{ CONSTANTS_NAMESPACE } || 'constants';
        $constants = Template::Config->constants($constants)
            || return $self->error(Template::Config->error);
        $ns->{ $cns } = $constants;
    }

    $self->{ SERVICE } = $config->{ SERVICE }
        || Template::Config->service($config)
        || return $self->error(Template::Config->error);

    $self->{ OUTPUT      } = $config->{ OUTPUT } || \*STDOUT;
    $self->{ OUTPUT_PATH } = $config->{ OUTPUT_PATH };

    return $self;
}



sub _output {
    my ($where, $textref, $options) = @_;
    my $reftype;
    my $error = 0;

    # call a CODE reference
    if (($reftype = ref($where)) eq 'CODE') {
        &$where($$textref);
    }
    # print to a glob (such as \*STDOUT)
    elsif ($reftype eq 'GLOB') {
        print $where $$textref;
    }
    # append output to a SCALAR ref
    elsif ($reftype eq 'SCALAR') {
        $$where .= $$textref;
    }
    # push onto ARRAY ref
    elsif ($reftype eq 'ARRAY') {
        push @$where, $$textref;
    }
    # call the print() method on an object that implements the method
    # (e.g. IO::Handle, Apache::Request, etc)
    elsif (blessed($where) && $where->can('print')) {
        $where->print($$textref);
    }
    # a simple string is taken as a filename
    elsif (! $reftype) {
        local *FP;
        # make destination directory if it doesn't exist
        my $dir = dirname($where);
        eval { mkpath($dir) unless -d $dir; };
        if ($@) {
            # strip file name and line number from error raised by die()
            ($error = $@) =~ s/ at \S+ line \d+\n?$//;
        }
        elsif (open(FP, ">$where")) {
            # binmode option can be 1 or a specific layer, e.g. :utf8
            my $bm = $options->{ binmode  };
            if ($bm && $bm eq 1) {
                binmode FP;
            }
            elsif ($bm){
                binmode FP, $bm;
            }
            print FP $$textref;
            close FP;
        }
        else {
            $error  = "$where: $!";
        }
    }
    # give up, we've done our best
    else {
        $error = "output_handler() cannot determine target type ($where)\n";
    }

    return $error;
}


1;


}
#
# Inline include of Template/Grammar.pm
#
BEGIN { $INC{'Template/Grammar.pm'} = 'dummy/Template/Grammar.pm'; }
BEGIN {
#line 0 "Template/Grammar.pm"

package Template::Grammar;

use strict;
use warnings;

our $VERSION  = 2.26;

my (@RESERVED, %CMPOP, $LEXTABLE, $RULES, $STATES);
my ($factory, $rawstart);




@RESERVED = qw(
    GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER BLOCK END
    USE PLUGIN FILTER MACRO PERL RAWPERL TO STEP AND OR NOT DIV MOD
    IF UNLESS ELSE ELSIF FOR NEXT WHILE SWITCH CASE META IN
    TRY THROW CATCH FINAL LAST RETURN STOP CLEAR VIEW DEBUG
    );



%CMPOP = qw(
    != ne
    == eq
    <  <
    >  >
    >= >=
    <= <=
);



$LEXTABLE = {
    'FOREACH' => 'FOR',
    'BREAK'   => 'LAST',
    '&&'      => 'AND',
    '||'      => 'OR',
    '!'       => 'NOT',
    '|'       => 'FILTER',
    '.'       => 'DOT',
    '_'       => 'CAT',
    '..'      => 'TO',
    '='       => 'ASSIGN',
    '=>'      => 'ASSIGN',
    ','       => 'COMMA',
    '\\'      => 'REF',
    'and'     => 'AND',     # explicitly specified so that qw( and or
    'or'      => 'OR',      # not ) can always be used in lower case,
    'not'     => 'NOT',     # regardless of ANYCASE flag
    'mod'     => 'MOD',
    'div'     => 'DIV',
};

{
    my @tokens = qw< ( ) [ ] { } ${ $ + / ; : ? >;
    my @cmpop  = keys %CMPOP;
    my @binop  = qw( - * % );              # '+' and '/' above, in @tokens

    # fill lexer table, slice by slice, with reserved words and operators
    @$LEXTABLE{ @RESERVED, @cmpop, @binop, @tokens }
            = ( @RESERVED, ('CMPOP') x @cmpop, ('BINOP') x @binop, @tokens );
}



sub new {
    my $class = shift;
    bless {
        LEXTABLE => $LEXTABLE,
        STATES   => $STATES,
        RULES    => $RULES,
    }, $class;
}

sub install_factory {
    my ($self, $new_factory) = @_;
    $factory = $new_factory;
}



$STATES = [
    {#State 0
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'loop' => 4,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'atomdir' => 12,
            'anonblock' => 50,
            'template' => 52,
            'defblockname' => 14,
            'ident' => 16,
            'assign' => 19,
            'macro' => 20,
            'lterm' => 56,
            'node' => 23,
            'term' => 58,
            'rawperl' => 59,
            'expr' => 62,
            'use' => 63,
            'defblock' => 66,
            'filter' => 29,
            'sterm' => 68,
            'perl' => 31,
            'chunks' => 33,
            'setlist' => 70,
            'try' => 35,
            'switch' => 34,
            'directive' => 71,
            'block' => 72,
            'condition' => 73
        }
    },
    {#State 1
        ACTIONS => {
            "\$" => 43,
            'LITERAL' => 75,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'setlist' => 76,
            'item' => 39,
            'assign' => 19,
            'node' => 23,
            'ident' => 74
        }
    },
    {#State 2
        DEFAULT => -130
    },
    {#State 3
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 79,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 4
        DEFAULT => -23
    },
    {#State 5
        ACTIONS => {
            ";" => 80
        }
    },
    {#State 6
        DEFAULT => -37
    },
    {#State 7
        DEFAULT => -14
    },
    {#State 8
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 90,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 9
        ACTIONS => {
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "]" => 94,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 96,
            'item' => 39,
            'range' => 93,
            'node' => 23,
            'ident' => 77,
            'term' => 95,
            'list' => 92,
            'lterm' => 56
        }
    },
    {#State 10
        ACTIONS => {
            ";" => 97
        }
    },
    {#State 11
        DEFAULT => -5
    },
    {#State 12
        ACTIONS => {
            ";" => -20
        },
        DEFAULT => -27
    },
    {#State 13
        DEFAULT => -78,
        GOTOS => {
            '@5-1' => 98
        }
    },
    {#State 14
        ACTIONS => {
            'IDENT' => 99
        },
        DEFAULT => -87,
        GOTOS => {
            'blockargs' => 102,
            'metadata' => 101,
            'meta' => 100
        }
    },
    {#State 15
        ACTIONS => {
            'IDENT' => 99
        },
        GOTOS => {
            'metadata' => 103,
            'meta' => 100
        }
    },
    {#State 16
        ACTIONS => {
            'DOT' => 104,
            'ASSIGN' => 105
        },
        DEFAULT => -109
    },
    {#State 17
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 106,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 18
        ACTIONS => {
            'IDENT' => 107
        }
    },
    {#State 19
        DEFAULT => -149
    },
    {#State 20
        DEFAULT => -12
    },
    {#State 21
        ACTIONS => {
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 108,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'loopvar' => 110,
            'node' => 23,
            'ident' => 77,
            'term' => 109,
            'lterm' => 56
        }
    },
    {#State 22
        DEFAULT => -40
    },
    {#State 23
        DEFAULT => -127
    },
    {#State 24
        DEFAULT => -6
    },
    {#State 25
        ACTIONS => {
            "\"" => 117,
            "\$" => 114,
            'LITERAL' => 116,
            'FILENAME' => 83,
            'IDENT' => 111,
            'NUMBER' => 84,
            "\${" => 37
        },
        GOTOS => {
            'names' => 91,
            'lvalue' => 112,
            'item' => 113,
            'name' => 82,
            'filepart' => 87,
            'filename' => 85,
            'nameargs' => 118,
            'lnameargs' => 115
        }
    },
    {#State 26
        DEFAULT => -113
    },
    {#State 27
        ACTIONS => {
            "\$" => 43,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'ident' => 119
        }
    },
    {#State 28
        ACTIONS => {
            'LITERAL' => 124,
            'FILENAME' => 83,
            'IDENT' => 120,
            'NUMBER' => 84
        },
        DEFAULT => -87,
        GOTOS => {
            'blockargs' => 123,
            'filepart' => 87,
            'filename' => 122,
            'blockname' => 121,
            'metadata' => 101,
            'meta' => 100
        }
    },
    {#State 29
        DEFAULT => -43
    },
    {#State 30
        ACTIONS => {
            "\$" => 43,
            'LITERAL' => 129,
            'IDENT' => 2,
            "\${" => 37
        },
        DEFAULT => -119,
        GOTOS => {
            'params' => 128,
            'hash' => 125,
            'item' => 126,
            'param' => 127
        }
    },
    {#State 31
        DEFAULT => -25
    },
    {#State 32
        ACTIONS => {
            "\"" => 117,
            "\$" => 114,
            'LITERAL' => 116,
            'FILENAME' => 83,
            'IDENT' => 111,
            'NUMBER' => 84,
            "\${" => 37
        },
        GOTOS => {
            'names' => 91,
            'lvalue' => 112,
            'item' => 113,
            'name' => 82,
            'filepart' => 87,
            'filename' => 85,
            'nameargs' => 118,
            'lnameargs' => 130
        }
    },
    {#State 33
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -2,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 131,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 34
        DEFAULT => -22
    },
    {#State 35
        DEFAULT => -24
    },
    {#State 36
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 132,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 37
        ACTIONS => {
            "\"" => 60,
            "\$" => 43,
            'LITERAL' => 78,
            'IDENT' => 2,
            'REF' => 27,
            'NUMBER' => 26,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 133,
            'item' => 39,
            'node' => 23,
            'ident' => 77
        }
    },
    {#State 38
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 134,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 39
        ACTIONS => {
            "(" => 135
        },
        DEFAULT => -128
    },
    {#State 40
        ACTIONS => {
            ";" => 136
        }
    },
    {#State 41
        DEFAULT => -38
    },
    {#State 42
        DEFAULT => -11
    },
    {#State 43
        ACTIONS => {
            'IDENT' => 137
        }
    },
    {#State 44
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 138,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 45
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 139,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 46
        DEFAULT => -42
    },
    {#State 47
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 140,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 48
        ACTIONS => {
            'IF' => 144,
            'FILTER' => 143,
            'FOR' => 142,
            'WHILE' => 146,
            'WRAPPER' => 145,
            'UNLESS' => 141
        }
    },
    {#State 49
        DEFAULT => -39
    },
    {#State 50
        DEFAULT => -10
    },
    {#State 51
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 147,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 52
        ACTIONS => {
            '' => 148
        }
    },
    {#State 53
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 57,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 149,
            'term' => 58,
            'expr' => 151,
            'assign' => 150,
            'lterm' => 56
        }
    },
    {#State 54
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 152,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 55
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 153,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 56
        DEFAULT => -103
    },
    {#State 57
        ACTIONS => {
            'ASSIGN' => 154
        },
        DEFAULT => -112
    },
    {#State 58
        DEFAULT => -146
    },
    {#State 59
        DEFAULT => -15
    },
    {#State 60
        DEFAULT => -176,
        GOTOS => {
            'quoted' => 155
        }
    },
    {#State 61
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 156,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 62
        ACTIONS => {
            ";" => -16,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -26
    },
    {#State 63
        DEFAULT => -13
    },
    {#State 64
        DEFAULT => -36
    },
    {#State 65
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 167,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 66
        DEFAULT => -9
    },
    {#State 67
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 168,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 68
        DEFAULT => -104
    },
    {#State 69
        ACTIONS => {
            "\$" => 43,
            'LITERAL' => 75,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'setlist' => 169,
            'item' => 39,
            'assign' => 19,
            'node' => 23,
            'ident' => 74
        }
    },
    {#State 70
        ACTIONS => {
            "\$" => 43,
            'COMMA' => 171,
            'LITERAL' => 75,
            'IDENT' => 2,
            "\${" => 37
        },
        DEFAULT => -19,
        GOTOS => {
            'item' => 39,
            'assign' => 170,
            'node' => 23,
            'ident' => 74
        }
    },
    {#State 71
        DEFAULT => -8
    },
    {#State 72
        DEFAULT => -1
    },
    {#State 73
        DEFAULT => -21
    },
    {#State 74
        ACTIONS => {
            'ASSIGN' => 172,
            'DOT' => 104
        }
    },
    {#State 75
        ACTIONS => {
            'ASSIGN' => 154
        }
    },
    {#State 76
        ACTIONS => {
            'COMMA' => 171,
            'LITERAL' => 75,
            'IDENT' => 2,
            "\$" => 43,
            "\${" => 37
        },
        DEFAULT => -30,
        GOTOS => {
            'item' => 39,
            'assign' => 170,
            'node' => 23,
            'ident' => 74
        }
    },
    {#State 77
        ACTIONS => {
            'DOT' => 104
        },
        DEFAULT => -109
    },
    {#State 78
        DEFAULT => -112
    },
    {#State 79
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            ";" => 173,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        }
    },
    {#State 80
        DEFAULT => -7
    },
    {#State 81
        DEFAULT => -173
    },
    {#State 82
        DEFAULT => -166
    },
    {#State 83
        DEFAULT => -172
    },
    {#State 84
        DEFAULT => -174
    },
    {#State 85
        ACTIONS => {
            'DOT' => 174
        },
        DEFAULT => -168
    },
    {#State 86
        ACTIONS => {
            "\$" => 43,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'ident' => 175
        }
    },
    {#State 87
        DEFAULT => -171
    },
    {#State 88
        DEFAULT => -169
    },
    {#State 89
        DEFAULT => -176,
        GOTOS => {
            'quoted' => 176
        }
    },
    {#State 90
        DEFAULT => -35
    },
    {#State 91
        ACTIONS => {
            "+" => 177,
            "(" => 178
        },
        DEFAULT => -156,
        GOTOS => {
            'args' => 179
        }
    },
    {#State 92
        ACTIONS => {
            "{" => 30,
            'COMMA' => 182,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "]" => 180,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 181,
            'lterm' => 56
        }
    },
    {#State 93
        ACTIONS => {
            "]" => 183
        }
    },
    {#State 94
        DEFAULT => -107
    },
    {#State 95
        DEFAULT => -116
    },
    {#State 96
        ACTIONS => {
            'TO' => 184
        },
        DEFAULT => -104
    },
    {#State 97
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 185,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 98
        ACTIONS => {
            ";" => 186
        }
    },
    {#State 99
        ACTIONS => {
            'ASSIGN' => 187
        }
    },
    {#State 100
        DEFAULT => -99
    },
    {#State 101
        ACTIONS => {
            'COMMA' => 189,
            'IDENT' => 99
        },
        DEFAULT => -86,
        GOTOS => {
            'meta' => 188
        }
    },
    {#State 102
        ACTIONS => {
            ";" => 190
        }
    },
    {#State 103
        ACTIONS => {
            'COMMA' => 189,
            'IDENT' => 99
        },
        DEFAULT => -17,
        GOTOS => {
            'meta' => 188
        }
    },
    {#State 104
        ACTIONS => {
            "\$" => 43,
            'IDENT' => 2,
            'NUMBER' => 192,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 191
        }
    },
    {#State 105
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'WRAPPER' => 55,
            'FOR' => 21,
            'NEXT' => 22,
            'LITERAL' => 57,
            "\"" => 60,
            'PROCESS' => 61,
            'FILTER' => 25,
            'RETURN' => 64,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 193,
            'DEFAULT' => 69,
            "{" => 30,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'term' => 58,
            'loop' => 4,
            'expr' => 195,
            'wrapper' => 46,
            'atomexpr' => 48,
            'atomdir' => 12,
            'mdir' => 194,
            'sterm' => 68,
            'filter' => 29,
            'ident' => 149,
            'perl' => 31,
            'setlist' => 70,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'directive' => 196,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 106
        DEFAULT => -33
    },
    {#State 107
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'INCLUDE' => 17,
            "(" => 198,
            'SWITCH' => 54,
            'WRAPPER' => 55,
            'FOR' => 21,
            'NEXT' => 22,
            'LITERAL' => 57,
            "\"" => 60,
            'PROCESS' => 61,
            'FILTER' => 25,
            'RETURN' => 64,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 193,
            'DEFAULT' => 69,
            "{" => 30,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'term' => 58,
            'loop' => 4,
            'expr' => 199,
            'wrapper' => 46,
            'atomexpr' => 48,
            'atomdir' => 12,
            'mdir' => 197,
            'sterm' => 68,
            'filter' => 29,
            'ident' => 149,
            'perl' => 31,
            'setlist' => 70,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'directive' => 196,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 108
        ACTIONS => {
            'IN' => 201,
            'ASSIGN' => 200
        },
        DEFAULT => -130
    },
    {#State 109
        DEFAULT => -156,
        GOTOS => {
            'args' => 202
        }
    },
    {#State 110
        ACTIONS => {
            ";" => 203
        }
    },
    {#State 111
        ACTIONS => {
            'ASSIGN' => -130
        },
        DEFAULT => -173
    },
    {#State 112
        ACTIONS => {
            'ASSIGN' => 204
        }
    },
    {#State 113
        DEFAULT => -159
    },
    {#State 114
        ACTIONS => {
            "\$" => 43,
            'IDENT' => 205,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'ident' => 175
        }
    },
    {#State 115
        ACTIONS => {
            ";" => 206
        }
    },
    {#State 116
        ACTIONS => {
            'ASSIGN' => -161
        },
        DEFAULT => -169
    },
    {#State 117
        DEFAULT => -176,
        GOTOS => {
            'quoted' => 207
        }
    },
    {#State 118
        DEFAULT => -158
    },
    {#State 119
        ACTIONS => {
            'DOT' => 104
        },
        DEFAULT => -110
    },
    {#State 120
        ACTIONS => {
            'ASSIGN' => 187
        },
        DEFAULT => -173
    },
    {#State 121
        DEFAULT => -83
    },
    {#State 122
        ACTIONS => {
            'DOT' => 174
        },
        DEFAULT => -84
    },
    {#State 123
        ACTIONS => {
            ";" => 208
        }
    },
    {#State 124
        DEFAULT => -85
    },
    {#State 125
        ACTIONS => {
            "}" => 209
        }
    },
    {#State 126
        ACTIONS => {
            'ASSIGN' => 210
        }
    },
    {#State 127
        DEFAULT => -122
    },
    {#State 128
        ACTIONS => {
            "\$" => 43,
            'COMMA' => 212,
            'LITERAL' => 129,
            'IDENT' => 2,
            "\${" => 37
        },
        DEFAULT => -118,
        GOTOS => {
            'item' => 126,
            'param' => 211
        }
    },
    {#State 129
        ACTIONS => {
            'ASSIGN' => 213
        }
    },
    {#State 130
        DEFAULT => -73
    },
    {#State 131
        DEFAULT => -4
    },
    {#State 132
        ACTIONS => {
            ";" => 214
        }
    },
    {#State 133
        ACTIONS => {
            "}" => 215
        }
    },
    {#State 134
        ACTIONS => {
            'DIV' => 159,
            'BINOP' => 161,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -142
    },
    {#State 135
        DEFAULT => -156,
        GOTOS => {
            'args' => 216
        }
    },
    {#State 136
        DEFAULT => -76,
        GOTOS => {
            '@4-2' => 217
        }
    },
    {#State 137
        DEFAULT => -132
    },
    {#State 138
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            ";" => 218,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        }
    },
    {#State 139
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -29
    },
    {#State 140
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -28
    },
    {#State 141
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 219,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 142
        ACTIONS => {
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 108,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'loopvar' => 220,
            'node' => 23,
            'ident' => 77,
            'term' => 109,
            'lterm' => 56
        }
    },
    {#State 143
        ACTIONS => {
            "\"" => 117,
            "\$" => 114,
            'LITERAL' => 116,
            'FILENAME' => 83,
            'IDENT' => 111,
            'NUMBER' => 84,
            "\${" => 37
        },
        GOTOS => {
            'names' => 91,
            'lvalue' => 112,
            'item' => 113,
            'name' => 82,
            'filepart' => 87,
            'filename' => 85,
            'nameargs' => 118,
            'lnameargs' => 221
        }
    },
    {#State 144
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 222,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 145
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 223,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 146
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 224,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 147
        DEFAULT => -41
    },
    {#State 148
        DEFAULT => 0
    },
    {#State 149
        ACTIONS => {
            'DOT' => 104,
            'ASSIGN' => 172
        },
        DEFAULT => -109
    },
    {#State 150
        ACTIONS => {
            ")" => 225
        }
    },
    {#State 151
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            ")" => 226,
            'OR' => 162
        }
    },
    {#State 152
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            ";" => 227,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        }
    },
    {#State 153
        ACTIONS => {
            ";" => 228
        }
    },
    {#State 154
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 229,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 155
        ACTIONS => {
            "\"" => 234,
            'TEXT' => 231,
            ";" => 233,
            "\$" => 43,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'ident' => 230,
            'quotable' => 232
        }
    },
    {#State 156
        DEFAULT => -34
    },
    {#State 157
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 235,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 158
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 236,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 159
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 237,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 160
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 238,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 161
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 239,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 162
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 240,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 163
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 241,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 164
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 242,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 165
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 243,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 166
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 244,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 167
        DEFAULT => -32
    },
    {#State 168
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            ";" => 245,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        }
    },
    {#State 169
        ACTIONS => {
            'COMMA' => 171,
            'LITERAL' => 75,
            'IDENT' => 2,
            "\$" => 43,
            "\${" => 37
        },
        DEFAULT => -31,
        GOTOS => {
            'item' => 39,
            'assign' => 170,
            'node' => 23,
            'ident' => 74
        }
    },
    {#State 170
        DEFAULT => -147
    },
    {#State 171
        DEFAULT => -148
    },
    {#State 172
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 246,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 173
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 247,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 174
        ACTIONS => {
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 248
        }
    },
    {#State 175
        ACTIONS => {
            'DOT' => 104
        },
        DEFAULT => -156,
        GOTOS => {
            'args' => 249
        }
    },
    {#State 176
        ACTIONS => {
            "\"" => 250,
            'TEXT' => 231,
            ";" => 233,
            "\$" => 43,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'ident' => 230,
            'quotable' => 232
        }
    },
    {#State 177
        ACTIONS => {
            "\"" => 89,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'filename' => 85,
            'name' => 251
        }
    },
    {#State 178
        DEFAULT => -156,
        GOTOS => {
            'args' => 252
        }
    },
    {#State 179
        ACTIONS => {
            'NOT' => 38,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "{" => 30,
            'COMMA' => 258,
            "(" => 53,
            "\${" => 37
        },
        DEFAULT => -163,
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 180
        DEFAULT => -105
    },
    {#State 181
        DEFAULT => -114
    },
    {#State 182
        DEFAULT => -115
    },
    {#State 183
        DEFAULT => -106
    },
    {#State 184
        ACTIONS => {
            "\"" => 60,
            "\$" => 43,
            'LITERAL' => 78,
            'IDENT' => 2,
            'REF' => 27,
            'NUMBER' => 26,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 259,
            'item' => 39,
            'node' => 23,
            'ident' => 77
        }
    },
    {#State 185
        ACTIONS => {
            'FINAL' => 260,
            'CATCH' => 262
        },
        DEFAULT => -72,
        GOTOS => {
            'final' => 261
        }
    },
    {#State 186
        ACTIONS => {
            'TEXT' => 263
        }
    },
    {#State 187
        ACTIONS => {
            "\"" => 266,
            'LITERAL' => 265,
            'NUMBER' => 264
        }
    },
    {#State 188
        DEFAULT => -97
    },
    {#State 189
        DEFAULT => -98
    },
    {#State 190
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'loop' => 4,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'atomdir' => 12,
            'anonblock' => 50,
            'template' => 267,
            'defblockname' => 14,
            'ident' => 16,
            'assign' => 19,
            'macro' => 20,
            'lterm' => 56,
            'node' => 23,
            'term' => 58,
            'rawperl' => 59,
            'expr' => 62,
            'use' => 63,
            'defblock' => 66,
            'filter' => 29,
            'sterm' => 68,
            'perl' => 31,
            'chunks' => 33,
            'setlist' => 70,
            'switch' => 34,
            'try' => 35,
            'directive' => 71,
            'block' => 72,
            'condition' => 73
        }
    },
    {#State 191
        DEFAULT => -125
    },
    {#State 192
        DEFAULT => -126
    },
    {#State 193
        ACTIONS => {
            ";" => 268
        }
    },
    {#State 194
        DEFAULT => -89
    },
    {#State 195
        ACTIONS => {
            ";" => -150,
            "+" => 157,
            'LITERAL' => -150,
            'IDENT' => -150,
            'CAT' => 163,
            "\$" => -150,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            'COMMA' => -150,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162,
            "\${" => -150
        },
        DEFAULT => -26
    },
    {#State 196
        DEFAULT => -92
    },
    {#State 197
        DEFAULT => -91
    },
    {#State 198
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 57,
            'IDENT' => 269,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'margs' => 270,
            'node' => 23,
            'ident' => 149,
            'term' => 58,
            'expr' => 151,
            'assign' => 150,
            'lterm' => 56
        }
    },
    {#State 199
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -26
    },
    {#State 200
        ACTIONS => {
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 271,
            'lterm' => 56
        }
    },
    {#State 201
        ACTIONS => {
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 272,
            'lterm' => 56
        }
    },
    {#State 202
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'COMMA' => 258,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        DEFAULT => -64,
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 203
        DEFAULT => -56,
        GOTOS => {
            '@1-3' => 273
        }
    },
    {#State 204
        ACTIONS => {
            "\"" => 89,
            "\$" => 86,
            'LITERAL' => 88,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'names' => 91,
            'nameargs' => 274,
            'filename' => 85,
            'name' => 82
        }
    },
    {#State 205
        ACTIONS => {
            'ASSIGN' => -132
        },
        DEFAULT => -130
    },
    {#State 206
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 275,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 207
        ACTIONS => {
            "\"" => 276,
            'TEXT' => 231,
            ";" => 233,
            "\$" => 43,
            'IDENT' => 2,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'ident' => 230,
            'quotable' => 232
        }
    },
    {#State 208
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 277,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 209
        DEFAULT => -108
    },
    {#State 210
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 278,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 211
        DEFAULT => -120
    },
    {#State 212
        DEFAULT => -121
    },
    {#State 213
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 279,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 214
        DEFAULT => -74,
        GOTOS => {
            '@3-3' => 280
        }
    },
    {#State 215
        DEFAULT => -131
    },
    {#State 216
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'COMMA' => 258,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            ")" => 281,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 217
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 282,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 218
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 283,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 219
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -47
    },
    {#State 220
        DEFAULT => -58
    },
    {#State 221
        DEFAULT => -81
    },
    {#State 222
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -45
    },
    {#State 223
        DEFAULT => -66
    },
    {#State 224
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -61
    },
    {#State 225
        DEFAULT => -144
    },
    {#State 226
        DEFAULT => -145
    },
    {#State 227
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 284,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 228
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 285,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 229
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -151
    },
    {#State 230
        ACTIONS => {
            'DOT' => 104
        },
        DEFAULT => -177
    },
    {#State 231
        DEFAULT => -178
    },
    {#State 232
        DEFAULT => -175
    },
    {#State 233
        DEFAULT => -179
    },
    {#State 234
        DEFAULT => -111
    },
    {#State 235
        ACTIONS => {
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -135
    },
    {#State 236
        ACTIONS => {
            ":" => 286,
            'CMPOP' => 164,
            "?" => 158,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        }
    },
    {#State 237
        ACTIONS => {
            'MOD' => 165
        },
        DEFAULT => -136
    },
    {#State 238
        ACTIONS => {
            'DIV' => 159,
            'BINOP' => 161,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -140
    },
    {#State 239
        ACTIONS => {
            'DIV' => 159,
            "+" => 157,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -133
    },
    {#State 240
        ACTIONS => {
            'DIV' => 159,
            'BINOP' => 161,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -141
    },
    {#State 241
        ACTIONS => {
            'DIV' => 159,
            'BINOP' => 161,
            "+" => 157,
            'CMPOP' => 164,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -139
    },
    {#State 242
        ACTIONS => {
            'DIV' => 159,
            'BINOP' => 161,
            "+" => 157,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -138
    },
    {#State 243
        DEFAULT => -137
    },
    {#State 244
        ACTIONS => {
            'DIV' => 159,
            'MOD' => 165
        },
        DEFAULT => -134
    },
    {#State 245
        DEFAULT => -59,
        GOTOS => {
            '@2-3' => 287
        }
    },
    {#State 246
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -150
    },
    {#State 247
        ACTIONS => {
            'ELSIF' => 290,
            'ELSE' => 288
        },
        DEFAULT => -50,
        GOTOS => {
            'else' => 289
        }
    },
    {#State 248
        DEFAULT => -170
    },
    {#State 249
        ACTIONS => {
            'NOT' => 38,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "{" => 30,
            'COMMA' => 258,
            "(" => 53,
            "\${" => 37
        },
        DEFAULT => -162,
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 250
        DEFAULT => -167
    },
    {#State 251
        DEFAULT => -165
    },
    {#State 252
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'COMMA' => 258,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            ")" => 291,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 253
        ACTIONS => {
            'DOT' => 104,
            'ASSIGN' => 292
        },
        DEFAULT => -109
    },
    {#State 254
        ACTIONS => {
            "(" => 135,
            'ASSIGN' => 210
        },
        DEFAULT => -128
    },
    {#State 255
        DEFAULT => -153
    },
    {#State 256
        ACTIONS => {
            'ASSIGN' => 213
        },
        DEFAULT => -112
    },
    {#State 257
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -152
    },
    {#State 258
        DEFAULT => -155
    },
    {#State 259
        DEFAULT => -117
    },
    {#State 260
        ACTIONS => {
            ";" => 293
        }
    },
    {#State 261
        ACTIONS => {
            'END' => 294
        }
    },
    {#State 262
        ACTIONS => {
            ";" => 296,
            'DEFAULT' => 297,
            'FILENAME' => 83,
            'IDENT' => 81,
            'NUMBER' => 84
        },
        GOTOS => {
            'filepart' => 87,
            'filename' => 295
        }
    },
    {#State 263
        ACTIONS => {
            'END' => 298
        }
    },
    {#State 264
        DEFAULT => -102
    },
    {#State 265
        DEFAULT => -100
    },
    {#State 266
        ACTIONS => {
            'TEXT' => 299
        }
    },
    {#State 267
        ACTIONS => {
            'END' => 300
        }
    },
    {#State 268
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 301,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 269
        ACTIONS => {
            'IDENT' => -96,
            ")" => -96,
            'COMMA' => -96
        },
        DEFAULT => -130
    },
    {#State 270
        ACTIONS => {
            'COMMA' => 304,
            'IDENT' => 302,
            ")" => 303
        }
    },
    {#State 271
        DEFAULT => -156,
        GOTOS => {
            'args' => 305
        }
    },
    {#State 272
        DEFAULT => -156,
        GOTOS => {
            'args' => 306
        }
    },
    {#State 273
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 307,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 274
        DEFAULT => -157
    },
    {#State 275
        ACTIONS => {
            'END' => 308
        }
    },
    {#State 276
        ACTIONS => {
            'ASSIGN' => -160
        },
        DEFAULT => -167
    },
    {#State 277
        ACTIONS => {
            'END' => 309
        }
    },
    {#State 278
        ACTIONS => {
            'DIV' => 159,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -124
    },
    {#State 279
        ACTIONS => {
            'DIV' => 159,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -123
    },
    {#State 280
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 310,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 281
        DEFAULT => -129
    },
    {#State 282
        ACTIONS => {
            'END' => 311
        }
    },
    {#State 283
        ACTIONS => {
            'ELSIF' => 290,
            'ELSE' => 288
        },
        DEFAULT => -50,
        GOTOS => {
            'else' => 312
        }
    },
    {#State 284
        ACTIONS => {
            'CASE' => 313
        },
        DEFAULT => -55,
        GOTOS => {
            'case' => 314
        }
    },
    {#State 285
        ACTIONS => {
            'END' => 315
        }
    },
    {#State 286
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 316,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 287
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 317,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 288
        ACTIONS => {
            ";" => 318
        }
    },
    {#State 289
        ACTIONS => {
            'END' => 319
        }
    },
    {#State 290
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 320,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 291
        DEFAULT => -164
    },
    {#State 292
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'expr' => 321,
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 58,
            'lterm' => 56
        }
    },
    {#State 293
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 322,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 294
        DEFAULT => -67
    },
    {#State 295
        ACTIONS => {
            'DOT' => 174,
            ";" => 323
        }
    },
    {#State 296
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 324,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 297
        ACTIONS => {
            ";" => 325
        }
    },
    {#State 298
        DEFAULT => -79
    },
    {#State 299
        ACTIONS => {
            "\"" => 326
        }
    },
    {#State 300
        DEFAULT => -82
    },
    {#State 301
        ACTIONS => {
            'END' => 327
        }
    },
    {#State 302
        DEFAULT => -94
    },
    {#State 303
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'WRAPPER' => 55,
            'FOR' => 21,
            'NEXT' => 22,
            'LITERAL' => 57,
            "\"" => 60,
            'PROCESS' => 61,
            'FILTER' => 25,
            'RETURN' => 64,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 193,
            'DEFAULT' => 69,
            "{" => 30,
            "\${" => 37
        },
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'term' => 58,
            'loop' => 4,
            'expr' => 199,
            'wrapper' => 46,
            'atomexpr' => 48,
            'atomdir' => 12,
            'mdir' => 328,
            'sterm' => 68,
            'filter' => 29,
            'ident' => 149,
            'perl' => 31,
            'setlist' => 70,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'directive' => 196,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 304
        DEFAULT => -95
    },
    {#State 305
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'COMMA' => 258,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        DEFAULT => -62,
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 306
        ACTIONS => {
            'NOT' => 38,
            "{" => 30,
            'COMMA' => 258,
            'LITERAL' => 256,
            'IDENT' => 2,
            "\"" => 60,
            "(" => 53,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        DEFAULT => -63,
        GOTOS => {
            'sterm' => 68,
            'item' => 254,
            'node' => 23,
            'ident' => 253,
            'term' => 58,
            'expr' => 257,
            'param' => 255,
            'lterm' => 56
        }
    },
    {#State 307
        ACTIONS => {
            'END' => 329
        }
    },
    {#State 308
        DEFAULT => -80
    },
    {#State 309
        DEFAULT => -88
    },
    {#State 310
        ACTIONS => {
            'END' => 330
        }
    },
    {#State 311
        DEFAULT => -77
    },
    {#State 312
        ACTIONS => {
            'END' => 331
        }
    },
    {#State 313
        ACTIONS => {
            ";" => 332,
            'DEFAULT' => 334,
            "{" => 30,
            'LITERAL' => 78,
            'IDENT' => 2,
            "\"" => 60,
            "\$" => 43,
            "[" => 9,
            'NUMBER' => 26,
            'REF' => 27,
            "\${" => 37
        },
        GOTOS => {
            'sterm' => 68,
            'item' => 39,
            'node' => 23,
            'ident' => 77,
            'term' => 333,
            'lterm' => 56
        }
    },
    {#State 314
        ACTIONS => {
            'END' => 335
        }
    },
    {#State 315
        DEFAULT => -65
    },
    {#State 316
        ACTIONS => {
            'DIV' => 159,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162,
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'MOD' => 165,
            "/" => 166
        },
        DEFAULT => -143
    },
    {#State 317
        ACTIONS => {
            'END' => 336
        }
    },
    {#State 318
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 337,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 319
        DEFAULT => -46
    },
    {#State 320
        ACTIONS => {
            'CMPOP' => 164,
            "?" => 158,
            ";" => 338,
            "+" => 157,
            'MOD' => 165,
            'DIV' => 159,
            "/" => 166,
            'AND' => 160,
            'CAT' => 163,
            'BINOP' => 161,
            'OR' => 162
        }
    },
    {#State 321
        ACTIONS => {
            "+" => 157,
            'CAT' => 163,
            'CMPOP' => 164,
            "?" => 158,
            'DIV' => 159,
            'MOD' => 165,
            "/" => 166,
            'AND' => 160,
            'BINOP' => 161,
            'OR' => 162
        },
        DEFAULT => -154
    },
    {#State 322
        DEFAULT => -71
    },
    {#State 323
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 339,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 324
        ACTIONS => {
            'FINAL' => 260,
            'CATCH' => 262
        },
        DEFAULT => -72,
        GOTOS => {
            'final' => 340
        }
    },
    {#State 325
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 341,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 326
        DEFAULT => -101
    },
    {#State 327
        DEFAULT => -93
    },
    {#State 328
        DEFAULT => -90
    },
    {#State 329
        DEFAULT => -57
    },
    {#State 330
        DEFAULT => -75
    },
    {#State 331
        DEFAULT => -44
    },
    {#State 332
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 342,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 333
        ACTIONS => {
            ";" => 343
        }
    },
    {#State 334
        ACTIONS => {
            ";" => 344
        }
    },
    {#State 335
        DEFAULT => -51
    },
    {#State 336
        DEFAULT => -60
    },
    {#State 337
        DEFAULT => -49
    },
    {#State 338
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 345,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 339
        ACTIONS => {
            'FINAL' => 260,
            'CATCH' => 262
        },
        DEFAULT => -72,
        GOTOS => {
            'final' => 346
        }
    },
    {#State 340
        DEFAULT => -70
    },
    {#State 341
        ACTIONS => {
            'FINAL' => 260,
            'CATCH' => 262
        },
        DEFAULT => -72,
        GOTOS => {
            'final' => 347
        }
    },
    {#State 342
        DEFAULT => -54
    },
    {#State 343
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 348,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 344
        ACTIONS => {
            'SET' => 1,
            'PERL' => 40,
            'NOT' => 38,
            'IDENT' => 2,
            'CLEAR' => 41,
            'UNLESS' => 3,
            'IF' => 44,
            "\$" => 43,
            'STOP' => 6,
            'CALL' => 45,
            'THROW' => 8,
            'GET' => 47,
            "[" => 9,
            'TRY' => 10,
            'LAST' => 49,
            'DEBUG' => 51,
            'RAWPERL' => 13,
            'META' => 15,
            'INCLUDE' => 17,
            "(" => 53,
            'SWITCH' => 54,
            'MACRO' => 18,
            'WRAPPER' => 55,
            ";" => -18,
            'FOR' => 21,
            'LITERAL' => 57,
            'NEXT' => 22,
            "\"" => 60,
            'TEXT' => 24,
            'PROCESS' => 61,
            'RETURN' => 64,
            'FILTER' => 25,
            'INSERT' => 65,
            'NUMBER' => 26,
            'REF' => 27,
            'WHILE' => 67,
            'BLOCK' => 28,
            'DEFAULT' => 69,
            "{" => 30,
            'USE' => 32,
            'VIEW' => 36,
            "\${" => 37
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 39,
            'node' => 23,
            'rawperl' => 59,
            'term' => 58,
            'loop' => 4,
            'use' => 63,
            'expr' => 62,
            'capture' => 42,
            'statement' => 5,
            'view' => 7,
            'wrapper' => 46,
            'atomexpr' => 48,
            'chunk' => 11,
            'defblock' => 66,
            'atomdir' => 12,
            'anonblock' => 50,
            'sterm' => 68,
            'defblockname' => 14,
            'filter' => 29,
            'ident' => 16,
            'perl' => 31,
            'setlist' => 70,
            'chunks' => 33,
            'try' => 35,
            'switch' => 34,
            'assign' => 19,
            'block' => 349,
            'directive' => 71,
            'macro' => 20,
            'condition' => 73,
            'lterm' => 56
        }
    },
    {#State 345
        ACTIONS => {
            'ELSIF' => 290,
            'ELSE' => 288
        },
        DEFAULT => -50,
        GOTOS => {
            'else' => 350
        }
    },
    {#State 346
        DEFAULT => -68
    },
    {#State 347
        DEFAULT => -69
    },
    {#State 348
        ACTIONS => {
            'CASE' => 313
        },
        DEFAULT => -55,
        GOTOS => {
            'case' => 351
        }
    },
    {#State 349
        DEFAULT => -53
    },
    {#State 350
        DEFAULT => -48
    },
    {#State 351
        DEFAULT => -52
    }
];



$RULES = [
    [#Rule 0
         '$start', 2, undef
    ],
    [#Rule 1
         'template', 1,
sub
{ $factory->template($_[1])           }
    ],
    [#Rule 2
         'block', 1,
sub
{ $factory->block($_[1])              }
    ],
    [#Rule 3
         'block', 0,
sub
{ $factory->block()                   }
    ],
    [#Rule 4
         'chunks', 2,
sub
{ push(@{$_[1]}, $_[2]) 
                                        if defined $_[2]; $_[1]           }
    ],
    [#Rule 5
         'chunks', 1,
sub
{ defined $_[1] ? [ $_[1] ] : [ ]     }
    ],
    [#Rule 6
         'chunk', 1,
sub
{ $factory->textblock($_[1])          }
    ],
    [#Rule 7
         'chunk', 2,
sub
{ return '' unless $_[1];
                                      $_[0]->location() . $_[1];
                                    }
    ],
    [#Rule 8
         'statement', 1, undef
    ],
    [#Rule 9
         'statement', 1, undef
    ],
    [#Rule 10
         'statement', 1, undef
    ],
    [#Rule 11
         'statement', 1, undef
    ],
    [#Rule 12
         'statement', 1, undef
    ],
    [#Rule 13
         'statement', 1, undef
    ],
    [#Rule 14
         'statement', 1, undef
    ],
    [#Rule 15
         'statement', 1, undef
    ],
    [#Rule 16
         'statement', 1,
sub
{ $factory->get($_[1])                }
    ],
    [#Rule 17
         'statement', 2,
sub
{ $_[0]->add_metadata($_[2]);         }
    ],
    [#Rule 18
         'statement', 0, undef
    ],
    [#Rule 19
         'directive', 1,
sub
{ $factory->set($_[1])                }
    ],
    [#Rule 20
         'directive', 1, undef
    ],
    [#Rule 21
         'directive', 1, undef
    ],
    [#Rule 22
         'directive', 1, undef
    ],
    [#Rule 23
         'directive', 1, undef
    ],
    [#Rule 24
         'directive', 1, undef
    ],
    [#Rule 25
         'directive', 1, undef
    ],
    [#Rule 26
         'atomexpr', 1,
sub
{ $factory->get($_[1])                }
    ],
    [#Rule 27
         'atomexpr', 1, undef
    ],
    [#Rule 28
         'atomdir', 2,
sub
{ $factory->get($_[2])                }
    ],
    [#Rule 29
         'atomdir', 2,
sub
{ $factory->call($_[2])               }
    ],
    [#Rule 30
         'atomdir', 2,
sub
{ $factory->set($_[2])                }
    ],
    [#Rule 31
         'atomdir', 2,
sub
{ $factory->default($_[2])            }
    ],
    [#Rule 32
         'atomdir', 2,
sub
{ $factory->insert($_[2])             }
    ],
    [#Rule 33
         'atomdir', 2,
sub
{ $factory->include($_[2])            }
    ],
    [#Rule 34
         'atomdir', 2,
sub
{ $factory->process($_[2])            }
    ],
    [#Rule 35
         'atomdir', 2,
sub
{ $factory->throw($_[2])              }
    ],
    [#Rule 36
         'atomdir', 1,
sub
{ $factory->return()                  }
    ],
    [#Rule 37
         'atomdir', 1,
sub
{ $factory->stop()                    }
    ],
    [#Rule 38
         'atomdir', 1,
sub
{ "\$output = '';";                   }
    ],
    [#Rule 39
         'atomdir', 1,
sub
{ $_[0]->block_label('last ', ';')    }
    ],
    [#Rule 40
         'atomdir', 1,
sub
{ $_[0]->in_block('FOR')
                                        ? $factory->next($_[0]->block_label)
                                        : $_[0]->block_label('next ', ';') }
    ],
    [#Rule 41
         'atomdir', 2,
sub
{ if ($_[2]->[0]->[0] =~ /^'(on|off)'$/) {
                                          $_[0]->{ DEBUG_DIRS } = ($1 eq 'on');
                                          $factory->debug($_[2]);
                                      }
                                      else {
                                          $_[0]->{ DEBUG_DIRS } ? $factory->debug($_[2]) : '';
                                      }
                                    }
    ],
    [#Rule 42
         'atomdir', 1, undef
    ],
    [#Rule 43
         'atomdir', 1, undef
    ],
    [#Rule 44
         'condition', 6,
sub
{ $factory->if(@_[2, 4, 5])           }
    ],
    [#Rule 45
         'condition', 3,
sub
{ $factory->if(@_[3, 1])              }
    ],
    [#Rule 46
         'condition', 6,
sub
{ $factory->if("!($_[2])", @_[4, 5])  }
    ],
    [#Rule 47
         'condition', 3,
sub
{ $factory->if("!($_[3])", $_[1])     }
    ],
    [#Rule 48
         'else', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]);
                                      $_[5];                              }
    ],
    [#Rule 49
         'else', 3,
sub
{ [ $_[3] ]                           }
    ],
    [#Rule 50
         'else', 0,
sub
{ [ undef ]                           }
    ],
    [#Rule 51
         'switch', 6,
sub
{ $factory->switch(@_[2, 5])          }
    ],
    [#Rule 52
         'case', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]); 
                                      $_[5];                              }
    ],
    [#Rule 53
         'case', 4,
sub
{ [ $_[4] ]                           }
    ],
    [#Rule 54
         'case', 3,
sub
{ [ $_[3] ]                           }
    ],
    [#Rule 55
         'case', 0,
sub
{ [ undef ]                           }
    ],
    [#Rule 56
         '@1-3', 0,
sub
{ $_[0]->enter_block('FOR')           }
    ],
    [#Rule 57
         'loop', 6,
sub
{ $factory->foreach(@{$_[2]}, $_[5], $_[0]->leave_block)  }
    ],
    [#Rule 58
         'loop', 3,
sub
{ $factory->foreach(@{$_[3]}, $_[1])  }
    ],
    [#Rule 59
         '@2-3', 0,
sub
{ $_[0]->enter_block('WHILE')         }
    ],
    [#Rule 60
         'loop', 6,
sub
{ $factory->while(@_[2, 5], $_[0]->leave_block) }
    ],
    [#Rule 61
         'loop', 3,
sub
{ $factory->while(@_[3, 1]) }
    ],
    [#Rule 62
         'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
    ],
    [#Rule 63
         'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
    ],
    [#Rule 64
         'loopvar', 2,
sub
{ [ 0, @_[1, 2] ]                     }
    ],
    [#Rule 65
         'wrapper', 5,
sub
{ $factory->wrapper(@_[2, 4])         }
    ],
    [#Rule 66
         'wrapper', 3,
sub
{ $factory->wrapper(@_[3, 1])         }
    ],
    [#Rule 67
         'try', 5,
sub
{ $factory->try(@_[3, 4])             }
    ],
    [#Rule 68
         'final', 5,
sub
{ unshift(@{$_[5]}, [ @_[2,4] ]);
                                      $_[5];                              }
    ],
    [#Rule 69
         'final', 5,
sub
{ unshift(@{$_[5]}, [ undef, $_[4] ]);
                                      $_[5];                              }
    ],
    [#Rule 70
         'final', 4,
sub
{ unshift(@{$_[4]}, [ undef, $_[3] ]);
                                      $_[4];                              }
    ],
    [#Rule 71
         'final', 3,
sub
{ [ $_[3] ]                           }
    ],
    [#Rule 72
         'final', 0,
sub
{ [ 0 ] }
    ],
    [#Rule 73
         'use', 2,
sub
{ $factory->use($_[2])                }
    ],
    [#Rule 74
         '@3-3', 0,
sub
{ $_[0]->push_defblock();             }
    ],
    [#Rule 75
         'view', 6,
sub
{ $factory->view(@_[2,5], 
                                                     $_[0]->pop_defblock) }
    ],
    [#Rule 76
         '@4-2', 0,
sub
{ ${$_[0]->{ INPERL }}++;             }
    ],
    [#Rule 77
         'perl', 5,
sub
{ ${$_[0]->{ INPERL }}--;
                                      $_[0]->{ EVAL_PERL } 
                                      ? $factory->perl($_[4])             
                                      : $factory->no_perl();              }
    ],
    [#Rule 78
         '@5-1', 0,
sub
{ ${$_[0]->{ INPERL }}++; 
                                      $rawstart = ${$_[0]->{'LINE'}};     }
    ],
    [#Rule 79
         'rawperl', 5,
sub
{ ${$_[0]->{ INPERL }}--;
                                      $_[0]->{ EVAL_PERL } 
                                      ? $factory->rawperl($_[4], $rawstart)
                                      : $factory->no_perl();              }
    ],
    [#Rule 80
         'filter', 5,
sub
{ $factory->filter(@_[2,4])           }
    ],
    [#Rule 81
         'filter', 3,
sub
{ $factory->filter(@_[3,1])           }
    ],
    [#Rule 82
         'defblock', 5,
sub
{ my $name = join('/', @{ $_[0]->{ DEFBLOCKS } });
                                      pop(@{ $_[0]->{ DEFBLOCKS } });
                                      $_[0]->define_block($name, $_[4]); 
                                      undef
                                    }
    ],
    [#Rule 83
         'defblockname', 2,
sub
{ push(@{ $_[0]->{ DEFBLOCKS } }, $_[2]);
                                      $_[2];
                                    }
    ],
    [#Rule 84
         'blockname', 1, undef
    ],
    [#Rule 85
         'blockname', 1,
sub
{ $_[1] =~ s/^'(.*)'$/$1/; $_[1]      }
    ],
    [#Rule 86
         'blockargs', 1, undef
    ],
    [#Rule 87
         'blockargs', 0, undef
    ],
    [#Rule 88
         'anonblock', 5,
sub
{ local $" = ', ';
                                      print STDERR "experimental block args: [@{ $_[2] }]\n"
                                          if $_[2];
                                      $factory->anon_block($_[4])         }
    ],
    [#Rule 89
         'capture', 3,
sub
{ $factory->capture(@_[1, 3])         }
    ],
    [#Rule 90
         'macro', 6,
sub
{ $factory->macro(@_[2, 6, 4])        }
    ],
    [#Rule 91
         'macro', 3,
sub
{ $factory->macro(@_[2, 3])           }
    ],
    [#Rule 92
         'mdir', 1, undef
    ],
    [#Rule 93
         'mdir', 4,
sub
{ $_[3]                               }
    ],
    [#Rule 94
         'margs', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
    ],
    [#Rule 95
         'margs', 2,
sub
{ $_[1]                               }
    ],
    [#Rule 96
         'margs', 1,
sub
{ [ $_[1] ]                           }
    ],
    [#Rule 97
         'metadata', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
    ],
    [#Rule 98
         'metadata', 2, undef
    ],
    [#Rule 99
         'metadata', 1, undef
    ],
    [#Rule 100
         'meta', 3,
sub
{ for ($_[3]) { s/^'//; s/'$//; 
                                                       s/\\'/'/g  }; 
                                         [ @_[1,3] ] }
    ],
    [#Rule 101
         'meta', 5,
sub
{ [ @_[1,4] ] }
    ],
    [#Rule 102
         'meta', 3,
sub
{ [ @_[1,3] ] }
    ],
    [#Rule 103
         'term', 1, undef
    ],
    [#Rule 104
         'term', 1, undef
    ],
    [#Rule 105
         'lterm', 3,
sub
{ "[ $_[2] ]"                         }
    ],
    [#Rule 106
         'lterm', 3,
sub
{ "[ $_[2] ]"                         }
    ],
    [#Rule 107
         'lterm', 2,
sub
{ "[ ]"                               }
    ],
    [#Rule 108
         'lterm', 3,
sub
{ "{ $_[2]  }"                        }
    ],
    [#Rule 109
         'sterm', 1,
sub
{ $factory->ident($_[1])              }
    ],
    [#Rule 110
         'sterm', 2,
sub
{ $factory->identref($_[2])           }
    ],
    [#Rule 111
         'sterm', 3,
sub
{ $factory->quoted($_[2])             }
    ],
    [#Rule 112
         'sterm', 1, undef
    ],
    [#Rule 113
         'sterm', 1, undef
    ],
    [#Rule 114
         'list', 2,
sub
{ "$_[1], $_[2]"                      }
    ],
    [#Rule 115
         'list', 2, undef
    ],
    [#Rule 116
         'list', 1, undef
    ],
    [#Rule 117
         'range', 3,
sub
{ $_[1] . '..' . $_[3]                }
    ],
    [#Rule 118
         'hash', 1, undef
    ],
    [#Rule 119
         'hash', 0,
sub
{ "" }
    ],
    [#Rule 120
         'params', 2,
sub
{ "$_[1], $_[2]"                      }
    ],
    [#Rule 121
         'params', 2, undef
    ],
    [#Rule 122
         'params', 1, undef
    ],
    [#Rule 123
         'param', 3,
sub
{ "$_[1] => $_[3]"                    }
    ],
    [#Rule 124
         'param', 3,
sub
{ "$_[1] => $_[3]"                    }
    ],
    [#Rule 125
         'ident', 3,
sub
{ push(@{$_[1]}, @{$_[3]}); $_[1]     }
    ],
    [#Rule 126
         'ident', 3,
sub
{ push(@{$_[1]}, 
                                           map {($_, 0)} split(/\./, $_[3]));
                                      $_[1];                              }
    ],
    [#Rule 127
         'ident', 1, undef
    ],
    [#Rule 128
         'node', 1,
sub
{ [ $_[1], 0 ]                        }
    ],
    [#Rule 129
         'node', 4,
sub
{ [ $_[1], $factory->args($_[3]) ]    }
    ],
    [#Rule 130
         'item', 1,
sub
{ "'$_[1]'"                           }
    ],
    [#Rule 131
         'item', 3,
sub
{ $_[2]                               }
    ],
    [#Rule 132
         'item', 2,
sub
{ $_[0]->{ V1DOLLAR }
                                       ? "'$_[2]'" 
                                       : $factory->ident(["'$_[2]'", 0])  }
    ],
    [#Rule 133
         'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
    ],
    [#Rule 134
         'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
    ],
    [#Rule 135
         'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
    ],
    [#Rule 136
         'expr', 3,
sub
{ "int($_[1] / $_[3])"                }
    ],
    [#Rule 137
         'expr', 3,
sub
{ "$_[1] % $_[3]"                     }
    ],
    [#Rule 138
         'expr', 3,
sub
{ "$_[1] $CMPOP{ $_[2] } $_[3]"       }
    ],
    [#Rule 139
         'expr', 3,
sub
{ "$_[1]  . $_[3]"                    }
    ],
    [#Rule 140
         'expr', 3,
sub
{ "$_[1] && $_[3]"                    }
    ],
    [#Rule 141
         'expr', 3,
sub
{ "$_[1] || $_[3]"                    }
    ],
    [#Rule 142
         'expr', 2,
sub
{ "! $_[2]"                           }
    ],
    [#Rule 143
         'expr', 5,
sub
{ "$_[1] ? $_[3] : $_[5]"             }
    ],
    [#Rule 144
         'expr', 3,
sub
{ $factory->assign(@{$_[2]})          }
    ],
    [#Rule 145
         'expr', 3,
sub
{ "($_[2])"                           }
    ],
    [#Rule 146
         'expr', 1, undef
    ],
    [#Rule 147
         'setlist', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
    ],
    [#Rule 148
         'setlist', 2, undef
    ],
    [#Rule 149
         'setlist', 1, undef
    ],
    [#Rule 150
         'assign', 3,
sub
{ [ $_[1], $_[3] ]                    }
    ],
    [#Rule 151
         'assign', 3,
sub
{ [ @_[1,3] ]                         }
    ],
    [#Rule 152
         'args', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
    ],
    [#Rule 153
         'args', 2,
sub
{ push(@{$_[1]->[0]}, $_[2]); $_[1]   }
    ],
    [#Rule 154
         'args', 4,
sub
{ push(@{$_[1]->[0]}, "'', " . 
                                      $factory->assign(@_[2,4])); $_[1]  }
    ],
    [#Rule 155
         'args', 2,
sub
{ $_[1]                               }
    ],
    [#Rule 156
         'args', 0,
sub
{ [ [ ] ]                             }
    ],
    [#Rule 157
         'lnameargs', 3,
sub
{ push(@{$_[3]}, $_[1]); $_[3]        }
    ],
    [#Rule 158
         'lnameargs', 1, undef
    ],
    [#Rule 159
         'lvalue', 1, undef
    ],
    [#Rule 160
         'lvalue', 3,
sub
{ $factory->quoted($_[2])             }
    ],
    [#Rule 161
         'lvalue', 1, undef
    ],
    [#Rule 162
         'nameargs', 3,
sub
{ [ [$factory->ident($_[2])], $_[3] ]   }
    ],
    [#Rule 163
         'nameargs', 2,
sub
{ [ @_[1,2] ] }
    ],
    [#Rule 164
         'nameargs', 4,
sub
{ [ @_[1,3] ] }
    ],
    [#Rule 165
         'names', 3,
sub
{ push(@{$_[1]}, $_[3]); $_[1] }
    ],
    [#Rule 166
         'names', 1,
sub
{ [ $_[1] ]                    }
    ],
    [#Rule 167
         'name', 3,
sub
{ $factory->quoted($_[2])  }
    ],
    [#Rule 168
         'name', 1,
sub
{ "'$_[1]'" }
    ],
    [#Rule 169
         'name', 1, undef
    ],
    [#Rule 170
         'filename', 3,
sub
{ "$_[1].$_[3]" }
    ],
    [#Rule 171
         'filename', 1, undef
    ],
    [#Rule 172
         'filepart', 1, undef
    ],
    [#Rule 173
         'filepart', 1, undef
    ],
    [#Rule 174
         'filepart', 1, undef
    ],
    [#Rule 175
         'quoted', 2,
sub
{ push(@{$_[1]}, $_[2]) 
                                          if defined $_[2]; $_[1]         }
    ],
    [#Rule 176
         'quoted', 0,
sub
{ [ ]                                 }
    ],
    [#Rule 177
         'quotable', 1,
sub
{ $factory->ident($_[1])              }
    ],
    [#Rule 178
         'quotable', 1,
sub
{ $factory->text($_[1])               }
    ],
    [#Rule 179
         'quotable', 1,
sub
{ undef                               }
    ]
];



1;


}
#
# Inline include of Template/Directive.pm
#
BEGIN { $INC{'Template/Directive.pm'} = 'dummy/Template/Directive.pm'; }
BEGIN {
#line 0 "Template/Directive.pm"

package Template::Directive;

use strict;
use warnings;
use base 'Template::Base';
use Template::Constants;
use Template::Exception;

our $VERSION   = 2.20;
our $DEBUG     = 0 unless defined $DEBUG;
our $WHILE_MAX = 1000 unless defined $WHILE_MAX;
our $PRETTY    = 0 unless defined $PRETTY;
our $OUTPUT    = '$output .= ';


sub _init {
    my ($self, $config) = @_;
    $self->{ NAMESPACE } = $config->{ NAMESPACE };
    return $self;
}

sub trace_vars {
    my $self = shift;
    return @_
        ? ($self->{ TRACE_VARS } = shift)
        :  $self->{ TRACE_VARS };
}

sub pad {
    my ($text, $pad) = @_;
    $pad = ' ' x ($pad * 4);
    $text =~ s/^(?!#line)/$pad/gm;
    $text;
}



sub template {
    my ($self, $block) = @_;
    $block = pad($block, 2) if $PRETTY;

    return "sub { return '' }" unless $block =~ /\S/;

    return <<EOF;
sub {
    my \$context = shift || die "template sub called without context\\n";
    my \$stash   = \$context->stash;
    my \$output  = '';
    my \$_tt_error;
    
    eval { BLOCK: {
$block
    } };
    if (\$@) {
        \$_tt_error = \$context->catch(\$@, \\\$output);
        die \$_tt_error unless \$_tt_error->type eq 'return';
    }

    return \$output;
}
EOF
}



sub anon_block {
    my ($self, $block) = @_;
    $block = pad($block, 2) if $PRETTY;

    return <<EOF;

$OUTPUT do {
    my \$output  = '';
    my \$_tt_error;
    
    eval { BLOCK: {
$block
    } };
    if (\$@) {
        \$_tt_error = \$context->catch(\$@, \\\$output);
        die \$_tt_error unless \$_tt_error->type eq 'return';
    }

    \$output;
};
EOF
}



sub block {
    my ($self, $block) = @_;
    return join("\n", @{ $block || [] });
}



sub textblock {
    my ($self, $text) = @_;
    return "$OUTPUT " . &text($self, $text) . ';';
}



sub text {
    my ($self, $text) = @_;
    for ($text) {
        s/(["\$\@\\])/\\$1/g;
        s/\n/\\n/g;
    }
    return '"' . $text . '"';
}



sub quoted {
    my ($self, $items) = @_;
    return '' unless @$items;
    return ("('' . " . $items->[0] . ')') if scalar @$items == 1;
    return '(' . join(' . ', @$items) . ')';
}



sub ident {
    my ($self, $ident) = @_;
    return "''" unless @$ident;
    my $ns;

    # Careful!  Template::Parser always creates a Template::Directive object
    # (as of v2.22_1) so $self is usually an object.  However, we used to 
    # allow Template::Directive methods to be called as class methods and 
    # Template::Namespace::Constants module takes advantage of this fact
    # by calling Template::Directive->ident() when it needs to generate an
    # identifier.  This hack guards against Mr Fuckup from coming to town
    # when that happens.
    
    if (ref $self) {
        # trace variable usage
        if ($self->{ TRACE_VARS }) {
            my $root = $self->{ TRACE_VARS };
            my $n    = 0;
            my $v;
            while ($n < @$ident) {
                $v = $ident->[$n];
                for ($v) { s/^'//; s/'$// };
                $root = $root->{ $v } ||= { };
                $n += 2;
            }
        }

        # does the first element of the identifier have a NAMESPACE
        # handler defined?
        if (@$ident > 2 && ($ns = $self->{ NAMESPACE })) {
            my $key = $ident->[0];
            $key =~ s/^'(.+)'$/$1/s;
            if ($ns = $ns->{ $key }) {
                return $ns->ident($ident);
            }
        }
    }
        
    if (scalar @$ident <= 2 && ! $ident->[1]) {
        $ident = $ident->[0];
    }
    else {
        $ident = '[' . join(', ', @$ident) . ']';
    }
    return "\$stash->get($ident)";
}


sub identref {
    my ($self, $ident) = @_;
    return "''" unless @$ident;
    if (scalar @$ident <= 2 && ! $ident->[1]) {
        $ident = $ident->[0];
    }
    else {
        $ident = '[' . join(', ', @$ident) . ']';
    }
    return "\$stash->getref($ident)";
}



sub assign {
    my ($self, $var, $val, $default) = @_;

    if (ref $var) {
        if (scalar @$var == 2 && ! $var->[1]) {
            $var = $var->[0];
        }
        else {
            $var = '[' . join(', ', @$var) . ']';
        }
    }
    $val .= ', 1' if $default;
    return "\$stash->set($var, $val)";
}



sub args {
    my ($self, $args) = @_;
    my $hash = shift @$args;
    push(@$args, '{ ' . join(', ', @$hash) . ' }')
        if @$hash;

    return '0' unless @$args;
    return '[ ' . join(', ', @$args) . ' ]';
}


sub filenames {
    my ($self, $names) = @_;
    if (@$names > 1) {
        $names = '[ ' . join(', ', @$names) . ' ]';
    }
    else {
        $names = shift @$names;
    }
    return $names;
}



sub get {
    my ($self, $expr) = @_;  
    return "$OUTPUT $expr;";
}



sub call {
    my ($self, $expr) = @_;  
    $expr .= ';';
    return $expr;
}



sub set {
    my ($self, $setlist) = @_;
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= &assign($self, $var, $val) . ";\n";
    }
    chomp $output;
    return $output;
}



sub default {
    my ($self, $setlist) = @_;  
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= &assign($self, $var, $val, 1) . ";\n";
    }
    chomp $output;
    return $output;
}



sub insert {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    $file = $self->filenames($file);
    return "$OUTPUT \$context->insert($file);"; 
}



sub include {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $self->filenames($file);
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT \$context->include($file);"; 
}



sub process {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $self->filenames($file);
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT \$context->process($file);"; 
}



sub if {
    my ($self, $expr, $block, $else) = @_;
    my @else = $else ? @$else : ();
    $else = pop @else;
    $block = pad($block, 1) if $PRETTY;

    my $output = "if ($expr) {\n$block\n}\n";

    foreach my $elsif (@else) {
        ($expr, $block) = @$elsif;
        $block = pad($block, 1) if $PRETTY;
        $output .= "elsif ($expr) {\n$block\n}\n";
    }
    if (defined $else) {
        $else = pad($else, 1) if $PRETTY;
        $output .= "else {\n$else\n}\n";
    }

    return $output;
}



sub foreach {
    my ($self, $target, $list, $args, $block, $label) = @_;
    $args  = shift @$args;
    $args  = @$args ? ', { ' . join(', ', @$args) . ' }' : '';
    $label ||= 'LOOP';

    my ($loop_save, $loop_set, $loop_restore, $setiter);
    if ($target) {
        $loop_save    = 'eval { $_tt_oldloop = ' . &ident($self, ["'loop'"]) . ' }';
        $loop_set     = "\$stash->{'$target'} = \$_tt_value";
        $loop_restore = "\$stash->set('loop', \$_tt_oldloop)";
    }
    else {
        $loop_save    = '$stash = $context->localise()';
        $loop_set     = "\$stash->get(['import', [\$_tt_value]]) "
                        . "if ref \$_tt_value eq 'HASH'";
        $loop_restore = '$stash = $context->delocalise()';
    }
    $block = pad($block, 3) if $PRETTY;

    return <<EOF;

do {
    my (\$_tt_value, \$_tt_error, \$_tt_oldloop);
    my \$_tt_list = $list;
    
    unless (UNIVERSAL::isa(\$_tt_list, 'Template::Iterator')) {
        \$_tt_list = Template::Config->iterator(\$_tt_list)
            || die \$Template::Config::ERROR, "\\n"; 
    }

    (\$_tt_value, \$_tt_error) = \$_tt_list->get_first();
    $loop_save;
    \$stash->set('loop', \$_tt_list);
    eval {
$label:   while (! \$_tt_error) {
            $loop_set;
$block;
            (\$_tt_value, \$_tt_error) = \$_tt_list->get_next();
        }
    };
    $loop_restore;
    die \$@ if \$@;
    \$_tt_error = 0 if \$_tt_error && \$_tt_error eq Template::Constants::STATUS_DONE;
    die \$_tt_error if \$_tt_error;
};
EOF
}


sub next {
    my ($self, $label) = @_;
    $label ||= 'LOOP';
    return <<EOF;
(\$_tt_value, \$_tt_error) = \$_tt_list->get_next();
next $label;
EOF
}



sub wrapper {
    my ($self, $nameargs, $block) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;

    local $" = ', ';

    return $self->multi_wrapper($file, $hash, $block)
        if @$file > 1;
    $file = shift @$file;

    $block = pad($block, 1) if $PRETTY;
    push(@$hash, "'content'", '$output');
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    return <<EOF;

$OUTPUT do {
    my \$output = '';
$block
    \$context->include($file); 
};
EOF
}


sub multi_wrapper {
    my ($self, $file, $hash, $block) = @_;
    $block = pad($block, 1) if $PRETTY;

    push(@$hash, "'content'", '$output');
    $hash = @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    $file = join(', ', reverse @$file);

    return <<EOF;

$OUTPUT do {
    my \$output = '';
$block
    foreach ($file) {
        \$output = \$context->include(\$_$hash); 
    }
    \$output;
};
EOF
}



sub while {
    my ($self, $expr, $block, $label) = @_;
    $block = pad($block, 2) if $PRETTY;
    $label ||= 'LOOP';

    return <<EOF;

do {
    my \$_tt_failsafe = $WHILE_MAX;
$label:
    while (--\$_tt_failsafe && ($expr)) {
$block
    }
    die "WHILE loop terminated (> $WHILE_MAX iterations)\\n"
        unless \$_tt_failsafe;
};
EOF
}



sub switch {
    my ($self, $expr, $case) = @_;
    my @case = @$case;
    my ($match, $block, $default);
    my $caseblock = '';

    $default = pop @case;

    foreach $case (@case) {
        $match = $case->[0];
        $block = $case->[1];
        $block = pad($block, 1) if $PRETTY;
        $caseblock .= <<EOF;
\$_tt_match = $match;
\$_tt_match = [ \$_tt_match ] unless ref \$_tt_match eq 'ARRAY';
if (grep(/^\\Q\$_tt_result\\E\$/, \@\$_tt_match)) {
$block
    last SWITCH;
}
EOF
    }

    $caseblock .= $default
        if defined $default;
    $caseblock = pad($caseblock, 2) if $PRETTY;

return <<EOF;

do {
    my \$_tt_result = $expr;
    my \$_tt_match;
    SWITCH: {
$caseblock
    }
};
EOF
}



sub try {
    my ($self, $block, $catch) = @_;
    my @catch = @$catch;
    my ($match, $mblock, $default, $final, $n);
    my $catchblock = '';
    my $handlers = [];

    $block = pad($block, 2) if $PRETTY;
    $final = pop @catch;
    $final = "# FINAL\n" . ($final ? "$final\n" : '')
           . 'die $_tt_error if $_tt_error;' . "\n" . '$output;';
    $final = pad($final, 1) if $PRETTY;

    $n = 0;
    foreach $catch (@catch) {
        $match = $catch->[0] || do {
            $default ||= $catch->[1];
            next;
        };
        $mblock = $catch->[1];
        $mblock = pad($mblock, 1) if $PRETTY;
        push(@$handlers, "'$match'");
        $catchblock .= $n++ 
            ? "elsif (\$_tt_handler eq '$match') {\n$mblock\n}\n" 
               : "if (\$_tt_handler eq '$match') {\n$mblock\n}\n";
    }
    $catchblock .= "\$_tt_error = 0;";
    $catchblock = pad($catchblock, 3) if $PRETTY;
    if ($default) {
        $default = pad($default, 1) if $PRETTY;
        $default = "else {\n    # DEFAULT\n$default\n    \$_tt_error = '';\n}";
    }
    else {
        $default = '# NO DEFAULT';
    }
    $default = pad($default, 2) if $PRETTY;

    $handlers = join(', ', @$handlers);
return <<EOF;

$OUTPUT do {
    my \$output = '';
    my (\$_tt_error, \$_tt_handler);
    eval {
$block
    };
    if (\$@) {
        \$_tt_error = \$context->catch(\$@, \\\$output);
        die \$_tt_error if \$_tt_error->type =~ /^return|stop\$/;
        \$stash->set('error', \$_tt_error);
        \$stash->set('e', \$_tt_error);
        if (defined (\$_tt_handler = \$_tt_error->select_handler($handlers))) {
$catchblock
        }
$default
    }
$final
};
EOF
}



sub throw {
    my ($self, $nameargs) = @_;
    my ($type, $args) = @$nameargs;
    my $hash = shift(@$args);
    my $info = shift(@$args);
    $type = shift @$type;           # uses same parser production as INCLUDE
                                    # etc., which allow multiple names
                                    # e.g. INCLUDE foo+bar+baz

    if (! $info) {
        $args = "$type, undef";
    }
    elsif (@$hash || @$args) {
        local $" = ', ';
        my $i = 0;
        $args = "$type, { args => [ " 
              . join(', ', $info, @$args) 
              . ' ], '
              . join(', ', 
                     (map { "'" . $i++ . "' => $_" } ($info, @$args)),
                     @$hash)
              . ' }';
    }
    else {
        $args = "$type, $info";
    }
    
    return "\$context->throw($args, \\\$output);";
}



sub clear {
    return "\$output = '';";
}


sub OLD_break {
    return 'last LOOP;';
}


sub return {
    return "\$context->throw('return', '', \\\$output);";
}


sub stop {
    return "\$context->throw('stop', '', \\\$output);";
}



sub use {
    my ($self, $lnameargs) = @_;
    my ($file, $args, $alias) = @$lnameargs;
    $file = shift @$file;       # same production rule as INCLUDE
    $alias ||= $file;
    $args = &args($self, $args);
    $file .= ", $args" if $args;
    return "# USE\n"
         . "\$stash->set($alias,\n"
         . "            \$context->plugin($file));";
}


sub view {
    my ($self, $nameargs, $block, $defblocks) = @_;
    my ($name, $args) = @$nameargs;
    my $hash = shift @$args;
    $name = shift @$name;       # same production rule as INCLUDE
    $block = pad($block, 1) if $PRETTY;

    if (%$defblocks) {
        $defblocks = join(",\n", map { "'$_' => $defblocks->{ $_ }" }
                                keys %$defblocks);
        $defblocks = pad($defblocks, 1) if $PRETTY;
        $defblocks = "{\n$defblocks\n}";
        push(@$hash, "'blocks'", $defblocks);
    }
    $hash = @$hash ? '{ ' . join(', ', @$hash) . ' }' : '';

    return <<EOF;
do {
    my \$output = '';
    my \$_tt_oldv = \$stash->get('view');
    my \$_tt_view = \$context->view($hash);
    \$stash->set($name, \$_tt_view);
    \$stash->set('view', \$_tt_view);

$block

    \$stash->set('view', \$_tt_oldv);
    \$_tt_view->seal();
};
EOF
}



sub perl {
    my ($self, $block) = @_;
    $block = pad($block, 1) if $PRETTY;

    return <<EOF;

\$context->throw('perl', 'EVAL_PERL not set')
    unless \$context->eval_perl();

$OUTPUT do {
    my \$output = "package Template::Perl;\\n";

$block

    local(\$Template::Perl::context) = \$context;
    local(\$Template::Perl::stash)   = \$stash;

    my \$_tt_result = '';
    tie *Template::Perl::PERLOUT, 'Template::TieString', \\\$_tt_result;
    my \$_tt_save_stdout = select *Template::Perl::PERLOUT;

    eval \$output;
    select \$_tt_save_stdout;
    \$context->throw(\$@) if \$@;
    \$_tt_result;
};
EOF
}



sub no_perl {
    my $self = shift;
    return "\$context->throw('perl', 'EVAL_PERL not set');";
}



sub rawperl {
    my ($self, $block, $line) = @_;
    for ($block) {
        s/^\n+//;
        s/\n+$//;
    }
    $block = pad($block, 1) if $PRETTY;
    $line = $line ? " (starting line $line)" : '';

    return <<EOF;
$block
EOF
}




sub filter {
    my ($self, $lnameargs, $block) = @_;
    my ($name, $args, $alias) = @$lnameargs;
    $name = shift @$name;
    $args = &args($self, $args);
    $args = $args ? "$args, $alias" : ", undef, $alias"
        if $alias;
    $name .= ", $args" if $args;
    $block = pad($block, 1) if $PRETTY;
 
    return <<EOF;

$OUTPUT do {
    my \$output = '';
    my \$_tt_filter = \$context->filter($name)
              || \$context->throw(\$context->error);

$block
    
    &\$_tt_filter(\$output);
};
EOF
}



sub capture {
    my ($self, $name, $block) = @_;

    if (ref $name) {
        if (scalar @$name == 2 && ! $name->[1]) {
            $name = $name->[0];
        }
        else {
            $name = '[' . join(', ', @$name) . ']';
        }
    }
    $block = pad($block, 1) if $PRETTY;

    return <<EOF;

\$stash->set($name, do {
    my \$output = '';
$block
    \$output;
});
EOF

}



sub macro {
    my ($self, $ident, $block, $args) = @_;
    $block = pad($block, 2) if $PRETTY;

    if ($args) {
        my $nargs = scalar @$args;
        $args = join(', ', map { "'$_'" } @$args);
        $args = $nargs > 1 
            ? "\@_tt_args{ $args } = splice(\@_, 0, $nargs)"
            : "\$_tt_args{ $args } = shift";

        return <<EOF;

\$stash->set('$ident', sub {
    my \$output = '';
    my (%_tt_args, \$_tt_params);
    $args;
    \$_tt_params = shift;
    \$_tt_params = { } unless ref(\$_tt_params) eq 'HASH';
    \$_tt_params = { \%_tt_args, %\$_tt_params };

    my \$stash = \$context->localise(\$_tt_params);
    eval {
$block
    };
    \$stash = \$context->delocalise();
    die \$@ if \$@;
    return \$output;
});
EOF

    }
    else {
        return <<EOF;

\$stash->set('$ident', sub {
    my \$_tt_params = \$_[0] if ref(\$_[0]) eq 'HASH';
    my \$output = '';

    my \$stash = \$context->localise(\$_tt_params);
    eval {
$block
    };
    \$stash = \$context->delocalise();
    die \$@ if \$@;
    return \$output;
});
EOF
    }
}


sub debug {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $args  = join(', ', @$file, @$args);
    $args .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT \$context->debugging($args); ## DEBUG ##"; 
}


1;


}
#
# Inline include of Template/Parser.pm
#
BEGIN { $INC{'Template/Parser.pm'} = 'dummy/Template/Parser.pm'; }
BEGIN {
#line 0 "Template/Parser.pm"

package Template::Parser;

use strict;
use warnings;
use base 'Template::Base';

use Template::Constants qw( :status :chomp );
use Template::Directive;
use Template::Grammar;

use constant CONTINUE => 0;
use constant ACCEPT   => 1;
use constant ERROR    => 2;
use constant ABORT    => 3;

our $VERSION = 2.89;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';

our $ANYCASE_BEFORE = qr/\G((?=\s*[=\.]))/;
our $ANYCASE_AFTER  = {
    map { $_ => 1 }
    qw(
        GET SET CALL DEFAULT INSERT INCLUDE PROCESS WRAPPER BLOCK USE
        PLUGIN FILTER MACRO IN TO STEP AND OR NOT DIV MOD DOT
        IF UNLESS ELSIF FOR WHILE SWITCH CASE META THROW CATCH VIEW
        CMPOP BINOP COMMA
    ),
    '(', '[', '{'
    # not sure about ASSIGN as it breaks C<header_html = include header>
};



our $TAG_STYLE   = {
    'outline'   => [ '\[%',    '%\]', '%%' ],  # NEW!  Outline tag
    'default'   => [ '\[%',    '%\]'    ],
    'template1' => [ '[\[%]%', '%[\]%]' ],
    'metatext'  => [ '%%',     '%%'     ],
    'html'      => [ '<!--',   '-->'    ],
    'mason'     => [ '<%',     '>'      ],
    'asp'       => [ '<%',     '%>'     ],
    'php'       => [ '<\?',    '\?>'    ],
    'star'      => [ '\[\*',   '\*\]'   ],
};
$TAG_STYLE->{ template } = $TAG_STYLE->{ tt2 } = $TAG_STYLE->{ default };


our $DEFAULT_STYLE = {
    START_TAG   => $TAG_STYLE->{ default }->[0],
    END_TAG     => $TAG_STYLE->{ default }->[1],
    OUTLINE_TAG => $TAG_STYLE->{ default }->[2],
    ANYCASE     => 0,
    INTERPOLATE => 0,
    PRE_CHOMP   => 0,
    POST_CHOMP  => 0,
    V1DOLLAR    => 0,
    EVAL_PERL   => 0,
};

our $QUOTED_ESCAPES = {
        n => "\n",
        r => "\r",
        t => "\t",
};

our $CHOMP_FLAGS  = qr/[-=~+]/;





sub new {
    my $class  = shift;
    my $config = $_[0] && ref($_[0]) eq 'HASH' ? shift(@_) : { @_ };
    my ($tagstyle, $debug, $start, $end, $defaults, $grammar, $hash, $key, $udef);

    my $self = bless {
        START_TAG   => undef,
        END_TAG     => undef,
        OUTLINE_TAG => undef,
        TAG_STYLE   => 'default',
        ANYCASE     => 0,
        INTERPOLATE => 0,
        PRE_CHOMP   => 0,
        POST_CHOMP  => 0,
        V1DOLLAR    => 0,
        EVAL_PERL   => 0,
        FILE_INFO   => 1,
        GRAMMAR     => undef,
        _ERROR      => '',
        IN_BLOCK    => [ ],
        TRACE_VARS  => $config->{ TRACE_VARS },
        FACTORY     => $config->{ FACTORY } || 'Template::Directive',
    }, $class;

    # update self with any relevant keys in config
    foreach $key (keys %$self) {
        $self->{ $key } = $config->{ $key } if defined $config->{ $key };
    }
    $self->{ FILEINFO } = [ ];

    # DEBUG config item can be a bitmask
    if (defined ($debug = $config->{ DEBUG })) {
        $self->{ DEBUG } = $debug & ( Template::Constants::DEBUG_PARSER
                                    | Template::Constants::DEBUG_FLAGS );
        $self->{ DEBUG_DIRS } = $debug & Template::Constants::DEBUG_DIRS;
    }
    # package variable can be set to 1 to support previous behaviour
    elsif ($DEBUG == 1) {
        $self->{ DEBUG } = Template::Constants::DEBUG_PARSER;
        $self->{ DEBUG_DIRS } = 0;
    }
    # otherwise let $DEBUG be a bitmask
    else {
        $self->{ DEBUG } = $DEBUG & ( Template::Constants::DEBUG_PARSER
                                    | Template::Constants::DEBUG_FLAGS );
        $self->{ DEBUG_DIRS } = $DEBUG & Template::Constants::DEBUG_DIRS;
    }

    $grammar = $self->{ GRAMMAR } ||= do {
        require Template::Grammar;
        Template::Grammar->new();
    };

    # instantiate a FACTORY object
    unless (ref $self->{ FACTORY }) {
        my $fclass = $self->{ FACTORY };
        $self->{ FACTORY } = $self->{ FACTORY }->new(
             NAMESPACE => $config->{ NAMESPACE }
        )
        || return $class->error($self->{ FACTORY }->error());
    }

    # load grammar rules, states and lex table
    @$self{ qw( LEXTABLE STATES RULES ) }
        = @$grammar{ qw( LEXTABLE STATES RULES ) };

    $self->new_style($config)
        || return $class->error($self->error());

    return $self;
}


sub enter_block {
    my ($self, $name) = @_;
    my $blocks = $self->{ IN_BLOCK };
    push(@{ $self->{ IN_BLOCK } }, $name);
}

sub leave_block {
    my $self = shift;
    my $label = $self->block_label;
    pop(@{ $self->{ IN_BLOCK } });
    return $label;
}

sub in_block {
    my ($self, $name) = @_;
    my $blocks = $self->{ IN_BLOCK };
    return @$blocks && $blocks->[-1] eq $name;
}

sub block_label {
    my ($self, $prefix, $suffix) = @_;
    my $blocks = $self->{ IN_BLOCK };
    my $name   = @$blocks
        ? $blocks->[-1] . scalar @$blocks
        : undef;
    return join('', grep { defined $_ } $prefix, $name, $suffix);
}




sub new_style {
    my ($self, $config) = @_;
    my $styles = $self->{ STYLE } ||= [ ];
    my ($tagstyle, $tags, $start, $end, $out, $key);

    # clone new style from previous or default style
    my $style  = { %{ $styles->[-1] || $DEFAULT_STYLE } };

    # expand START_TAG and END_TAG from specified TAG_STYLE
    if ($tagstyle = $config->{ TAG_STYLE }) {
        return $self->error("Invalid tag style: $tagstyle")
            unless defined ($tags = $TAG_STYLE->{ $tagstyle });
        ($start, $end, $out) = @$tags;
        $config->{ START_TAG   } ||= $start;
        $config->{ END_TAG     } ||= $end;
        $config->{ OUTLINE_TAG } ||= $out;
    }

    foreach $key (keys %$DEFAULT_STYLE) {
        $style->{ $key } = $config->{ $key } if defined $config->{ $key };
    }

    $start = $style->{ START_TAG   };
    $end   = $style->{ END_TAG     };
    $out   = $style->{ OUTLINE_TAG };
    $style->{ TEXT_SPLIT } = $self->text_splitter($start, $end, $out);

    push(@$styles, $style);
    return $style;
}

sub text_splitter {
    my ($self, $start, $end, $out) = @_;

    if (defined $out) {
        return qr/
          \A(.*?)             # $1 - start of line up to directive
            (?:
              (?:
              ^$out           # outline tag at start of line
              (.*?)           # $2 - content of that line
              (?:\n|$)        # end of that line or file
              )
              |
              (?:
              $start          # start of tag
              (.*?)           # $3 - tag contents
              $end            # end of tag
              )
            )
        /msx;
    }
    else {
        return qr/
          ^(.*?)              # $1 - start of line up to directive
            (?:
              $start          # start of tag
              (.*?)           # $2 - tag contents
              $end            # end of tag
            )
        /sx;
    }
}


sub old_style {
    my $self = shift;
    my $styles = $self->{ STYLE };
    return $self->error('only 1 parser style remaining')
        unless (@$styles > 1);
    pop @$styles;
    return $styles->[-1];
}



sub parse {
    my ($self, $text, $info) = @_;
    my ($tokens, $block);

    $info->{ DEBUG } = $self->{ DEBUG_DIRS }
        unless defined $info->{ DEBUG };


    # store for blocks defined in the template (see define_block())
    my $defblock  = $self->{ DEFBLOCK  } = { };
    my $metadata  = $self->{ METADATA  } = [ ];
    my $variables = $self->{ VARIABLES } = { };
    $self->{ DEFBLOCKS } = [ ];

    $self->{ _ERROR } = '';

    # split file into TEXT/DIRECTIVE chunks
    $tokens = $self->split_text($text)
        || return undef;                                    ## RETURN ##

    push(@{ $self->{ FILEINFO } }, $info);

    # parse chunks
    $block = $self->_parse($tokens, $info);

    pop(@{ $self->{ FILEINFO } });

    return undef unless $block;                             ## RETURN ##

    $self->debug("compiled main template document block:\n$block")
        if $self->{ DEBUG } & Template::Constants::DEBUG_PARSER;

    return {
        BLOCK     => $block,
        DEFBLOCKS => $defblock,
        VARIABLES => $variables,
        METADATA  => { @$metadata },
    };
}




sub split_text {
    my ($self, $text) = @_;
    my ($pre, $dir, $prelines, $dirlines, $postlines, $chomp, $tags, @tags);
    my $style = $self->{ STYLE }->[-1];
    my ($start, $end, $out, $prechomp, $postchomp, $interp ) =
        @$style{ qw( START_TAG END_TAG OUTLINE_TAG PRE_CHOMP POST_CHOMP INTERPOLATE ) };
    my $tags_dir = $self->{ANYCASE} ? qr<TAGS>i : qr<TAGS>;
    my $split    = $style->{ TEXT_SPLIT };
    my $has_out  = defined $out;

    my @tokens = ();
    my $line = 1;

    return \@tokens                                         ## RETURN ##
        unless defined $text && length $text;

    # extract all directives from the text
    while ($text =~ s/$split//) {
        $pre = $1;
        $dir = defined($2) ? $2 : $3;
        $pre = '' unless defined $pre;
        $dir = '' unless defined $dir;

        $prelines  = ($pre =~ tr/\n//);  # newlines in preceding text
        $dirlines  = ($dir =~ tr/\n//);  # newlines in directive tag
        $postlines = 0;                  # newlines chomped after tag

        for ($dir) {
            if (/^\#/) {
                # comment out entire directive except for any end chomp flag
                $dir = ($dir =~ /($CHOMP_FLAGS)$/o) ? $1 : '';
            }
            else {

                if(s/^($CHOMP_FLAGS)?(\s*)//so && $2) {
                  my $chomped = $2;
                  my $linecount = ($chomped =~ tr/\n//); # newlines in chomped whitespace
                  $linecount ||= 0;
                  $prelines += $linecount;
                  $dirlines -= $linecount;
                }
                # PRE_CHOMP: process whitespace before tag
                $chomp = $1 ? $1 : $prechomp;
                $chomp =~ tr/-=~+/1230/;
                if ($chomp && $pre) {
                    # chomp off whitespace and newline preceding directive
                    if ($chomp == CHOMP_ALL) {
                        $pre =~ s{ (\r?\n|^) [^\S\n]* \z }{}mx;
                    }
                    elsif ($chomp == CHOMP_COLLAPSE) {
                        $pre =~ s{ (\s+) \z }{ }x;
                    }
                    elsif ($chomp == CHOMP_GREEDY) {
                        $pre =~ s{ (\s+) \z }{}x;
                    }
                }
            }

            # POST_CHOMP: process whitespace after tag
            s/\s*($CHOMP_FLAGS)?\s*$//so;
            $chomp = $1 ? $1 : $postchomp;
            $chomp =~ tr/-=~+/1230/;
            if ($chomp) {
                if ($chomp == CHOMP_ALL) {
                    $text =~ s{ ^ ([^\S\n]* \n) }{}x
                        && $postlines++;
                }
                elsif ($chomp == CHOMP_COLLAPSE) {
                    $text =~ s{ ^ (\s+) }{ }x
                        && ($postlines += $1=~y/\n//);
                }
                # any trailing whitespace
                elsif ($chomp == CHOMP_GREEDY) {
                    $text =~ s{ ^ (\s+) }{}x
                        && ($postlines += $1=~y/\n//);
                }
            }
        }

        # any text preceding the directive can now be added
        if (length $pre) {
            push(@tokens, $interp
                 ? [ $pre, $line, 'ITEXT' ]
                 : ('TEXT', $pre) );
        }
        $line += $prelines;

        # and now the directive, along with line number information
        if (length $dir) {
            # the TAGS directive is a compile-time switch
            if ($dir =~ /^$tags_dir\s+(.*)/) {
                my @tags = split(/\s+/, $1);
                if (scalar @tags > 1) {
                    ($start, $end, $out) = map { quotemeta($_) } @tags;
                    $split = $self->text_splitter($start, $end, $out);
                }
                elsif ($tags = $TAG_STYLE->{ $tags[0] }) {
                    ($start, $end, $out) = @$tags;
                    $split = $self->text_splitter($start, $end, $out);
                }
                else {
                    warn "invalid TAGS style: $tags[0]\n";
                }
            }
            else {
                # DIRECTIVE is pushed as:
                #   [ $dirtext, $line_no(s), \@tokens ]
                push(@tokens,
                     [ $dir,
                       ($dirlines
                        ? sprintf("%d-%d", $line, $line + $dirlines)
                        : $line),
                       $self->tokenise_directive($dir) ]);
            }
        }

        # update line counter to include directive lines and any extra
        # newline chomped off the start of the following text
        $line += $dirlines + $postlines;
    }

    # anything remaining in the string is plain text
    push(@tokens, $interp
         ? [ $text, $line, 'ITEXT' ]
         : ( 'TEXT', $text) )
        if length $text;

    return \@tokens;                                        ## RETURN ##
}




sub interpolate_text {
    my ($self, $text, $line) = @_;
    my @tokens  = ();
    my ($pre, $var, $dir);


   while ($text =~
           /
           ( (?: \\. | [^\$] ){1,3000} ) # escaped or non-'$' character [$1]
           |
           ( \$ (?:                 # embedded variable            [$2]
             (?: \{ ([^\}]*) \} )   # ${ ... }                     [$3]
             |
             ([\w\.]+)              # $word                        [$4]
             )
           )
        /gx) {

        ($pre, $var, $dir) = ($1, $3 || $4, $2);

        # preceding text
        if (defined($pre) && length($pre)) {
            $line += $pre =~ tr/\n//;
            $pre =~ s/\\\$/\$/g;
            push(@tokens, 'TEXT', $pre);
        }
        # $variable reference
        if ($var) {
            $line += $dir =~ tr/\n/ /;
            push(@tokens, [ $dir, $line, $self->tokenise_directive($var) ]);
        }
        # other '$' reference - treated as text
        elsif ($dir) {
            $line += $dir =~ tr/\n//;
            push(@tokens, 'TEXT', $dir);
        }
    }

    return \@tokens;
}




sub tokenise_directive {
    my ($self, $text, $line) = @_;
    my ($token, $uctoken, $type, $lookup);
    my $lextable = $self->{ LEXTABLE };
    my $style    = $self->{ STYLE }->[-1];
    my ($anycase, $start, $end) = @$style{ qw( ANYCASE START_TAG END_TAG ) };
    my @tokens = ( );

    while ($text =~
            /
                # strip out any comments
                (\#[^\n]*)
           |
                # a quoted phrase matches in $3
                (["'])                   # $2 - opening quote, ' or "
                (                        # $3 - quoted text buffer
                    (?:                  # repeat group (no backreference)
                        \\\\             # an escaped backslash \\
                    |                    # ...or...
                        \\\2             # an escaped quote \" or \' (match $1)
                    |                    # ...or...
                        .                # any other character
                    |   \n
                    )*?                  # non-greedy repeat
                )                        # end of $3
                \2                       # match opening quote
            |
                # an unquoted number matches in $4
                (-?\d+(?:\.\d+)?)       # numbers
            |
                # filename matches in $5
                ( \/?\w+(?:(?:\/|::?)\w*)+ | \/\w+)
            |
                # an identifier matches in $6
                (\w+)                    # variable identifier
            |
                # an unquoted word or symbol matches in $7
                (   [(){}\[\]:;,\/\\]    # misc parenthesis and symbols
                |   [+\-*]               # math operations
                |   \$\{?                # dollar with option left brace
                |   =>                   # like '='
                |   [=!<>]?= | [!<>]     # eqality tests
                |   &&? | \|\|?          # boolean ops
                |   \.\.?                # n..n sequence
                |   \S+                  # something unquoted
                )                        # end of $7
            /gmxo) {

        # ignore comments to EOL
        next if $1;

        # quoted string
        if (defined ($token = $3)) {
            # double-quoted string may include $variable references
            if ($2 eq '"') {
                if ($token =~ /[\$\\]/) {
                    $type = 'QUOTED';
                    # unescape " and \ but leave \$ escaped so that
                        # interpolate_text() doesn't incorrectly treat it
                    # as a variable reference
                        for ($token) {
                                s/\\([^\$nrt])/$1/g;
                                s/\\([nrt])/$QUOTED_ESCAPES->{ $1 }/ge;
                        }
                    push(@tokens, ('"') x 2,
                                  @{ $self->interpolate_text($token) },
                                  ('"') x 2);
                    next;
                }
                else {
                    $type = 'LITERAL';
                    $token =~ s['][\\']g;
                    $token = "'$token'";
                }
            }
            else {
                $type = 'LITERAL';
                $token = "'$token'";
            }
        }
        # number
        elsif (defined ($token = $4)) {
            $type = 'NUMBER';
        }
        elsif (defined($token = $5)) {
            $type = 'FILENAME';
        }
        elsif (defined($token = $6)) {
            # Fold potential keywords to UPPER CASE if the ANYCASE option is
            # set, unless (we've got some preceding tokens and) the previous
            # token is a DOT op.  This prevents the 'last' in 'data.last'
            # from being interpreted as the LAST keyword.
            if ($anycase) {
                # if the token follows a dot or precedes an assignment then
                # it's not for folding, e.g. the 'wrapper' in this:
                # [% page = { wrapper='html' }; page.wrapper %]
                if ((@tokens && $ANYCASE_AFTER->{ $tokens[-2] })
                ||  ($text =~ /$ANYCASE_BEFORE/gc)) {
                    # keep the token unmodified
                    $uctoken = $token;
                }
                else {
                    $uctoken = uc $token;
                }
            }
            else {
                $uctoken = $token;
            }
            if (defined ($type = $lextable->{ $uctoken })) {
                $token = $uctoken;
            }
            else {
                $type = 'IDENT';
            }
        }
        elsif (defined ($token = $7)) {
            # reserved words may be in lower case unless case sensitive
            $uctoken = $anycase ? uc $token : $token;
            unless (defined ($type = $lextable->{ $uctoken })) {
                $type = 'UNQUOTED';
            }
        }

        push(@tokens, $type, $token);

    }


    return \@tokens;                                        ## RETURN ##
}



sub define_block {
    my ($self, $name, $block) = @_;
    my $defblock = $self->{ DEFBLOCK }
        || return undef;

    $self->debug("compiled block '$name':\n$block")
        if $self->{ DEBUG } & Template::Constants::DEBUG_PARSER;

    $defblock->{ $name } = $block;

    return undef;
}

sub push_defblock {
    my $self = shift;
    my $stack = $self->{ DEFBLOCK_STACK } ||= [];
    push(@$stack, $self->{ DEFBLOCK } );
    $self->{ DEFBLOCK } = { };
}

sub pop_defblock {
    my $self  = shift;
    my $defs  = $self->{ DEFBLOCK };
    my $stack = $self->{ DEFBLOCK_STACK } || return $defs;
    return $defs unless @$stack;
    $self->{ DEFBLOCK } = pop @$stack;
    return $defs;
}



sub add_metadata {
    my ($self, $setlist) = @_;
    my $metadata = $self->{ METADATA }
        || return undef;

    push(@$metadata, @$setlist);

    return undef;
}



sub location {
    my $self = shift;
    return "\n" unless $self->{ FILE_INFO };
    my $line = ${ $self->{ LINE } };
    my $info = $self->{ FILEINFO }->[-1];
    my $file = $info->{ path } || $info->{ name }
        || '(unknown template)';
    $line =~ s/\-.*$//; # might be 'n-n'
    $line ||= 1;
    return "#line $line \"$file\"\n";
}




sub _parse {
    my ($self, $tokens, $info) = @_;
    my ($token, $value, $text, $line, $inperl);
    my ($state, $stateno, $status, $action, $lookup, $coderet, @codevars);
    my ($lhs, $len, $code);         # rule contents
    my $stack = [ [ 0, undef ] ];   # DFA stack


    # retrieve internal rule and state tables
    my ($states, $rules) = @$self{ qw( STATES RULES ) };

    # If we're tracing variable usage then we need to give the factory a
    # reference to our $self->{ VARIABLES } for it to fill in.  This is a
    # bit of a hack to back-patch this functionality into TT2.
    $self->{ FACTORY }->trace_vars($self->{ VARIABLES })
        if $self->{ TRACE_VARS };

    # call the grammar set_factory method to install emitter factory
    $self->{ GRAMMAR }->install_factory($self->{ FACTORY });

    $line = $inperl = 0;
    $self->{ LINE   } = \$line;
    $self->{ FILE   } = $info->{ name };
    $self->{ INPERL } = \$inperl;

    $status = CONTINUE;
    my $in_string = 0;

    while(1) {
        # get state number and state
        $stateno =  $stack->[-1]->[0];
        $state   = $states->[$stateno];

        # see if any lookaheads exist for the current state
        if (exists $state->{'ACTIONS'}) {

            # get next token and expand any directives (i.e. token is an
            # array ref) onto the front of the token list
            while (! defined $token && @$tokens) {
                $token = shift(@$tokens);
                if (ref $token) {
                    ($text, $line, $token) = @$token;
                    if (ref $token) {
                        if ($info->{ DEBUG } && ! $in_string) {
                            # - - - - - - - - - - - - - - - - - - - - - - - - -
                            # This is gnarly.  Look away now if you're easily
                            # frightened.  We're pushing parse tokens onto the
                            # pending list to simulate a DEBUG directive like so:
                            # [% DEBUG msg line='20' text='INCLUDE foo' %]
                            # - - - - - - - - - - - - - - - - - - - - - - - - -
                            my $dtext = $text;
                            $dtext =~ s[(['\\])][\\$1]g;
                            unshift(@$tokens,
                                    DEBUG   => 'DEBUG',
                                    IDENT   => 'msg',
                                    IDENT   => 'line',
                                    ASSIGN  => '=',
                                    LITERAL => "'$line'",
                                    IDENT   => 'text',
                                    ASSIGN  => '=',
                                    LITERAL => "'$dtext'",
                                    IDENT   => 'file',
                                    ASSIGN  => '=',
                                    LITERAL => "'$info->{ name }'",
                                    (';') x 2,
                                    @$token,
                                    (';') x 2);
                        }
                        else {
                            unshift(@$tokens, @$token, (';') x 2);
                        }
                        $token = undef;  # force redo
                    }
                    elsif ($token eq 'ITEXT') {
                        if ($inperl) {
                            # don't perform interpolation in PERL blocks
                            $token = 'TEXT';
                            $value = $text;
                        }
                        else {
                            unshift(@$tokens,
                                    @{ $self->interpolate_text($text, $line) });
                            $token = undef; # force redo
                        }
                    }
                }
                else {
                    # toggle string flag to indicate if we're crossing
                    # a string boundary
                    $in_string = ! $in_string if $token eq '"';
                    $value = shift(@$tokens);
                }
            };
            # clear undefined token to avoid 'undefined variable blah blah'
            # warnings and let the parser logic pick it up in a minute
            $token = '' unless defined $token;

            # get the next state for the current lookahead token
            $action = defined ($lookup = $state->{'ACTIONS'}->{ $token })
                      ? $lookup
                      : defined ($lookup = $state->{'DEFAULT'})
                        ? $lookup
                        : undef;
        }
        else {
            # no lookahead actions
            $action = $state->{'DEFAULT'};
        }

        # ERROR: no ACTION
        last unless defined $action;

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # shift (+ive ACTION)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if ($action > 0) {
            push(@$stack, [ $action, $value ]);
            $token = $value = undef;
            redo;
        };

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # reduce (-ive ACTION)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ($lhs, $len, $code) = @{ $rules->[ -$action ] };

        # no action imples ACCEPTance
        $action
            or $status = ACCEPT;

        # use dummy sub if code ref doesn't exist
        $code = sub { $_[1] }
            unless $code;

        @codevars = $len
                ?   map { $_->[1] } @$stack[ -$len .. -1 ]
                :   ();

        eval {
            $coderet = &$code( $self, @codevars );
        };
        if ($@) {
            my $err = $@;
            chomp $err;
            return $self->_parse_error($err);
        }

        # reduce stack by $len
        splice(@$stack, -$len, $len);

        # ACCEPT
        return $coderet                                     ## RETURN ##
            if $status == ACCEPT;

        # ABORT
        return undef                                        ## RETURN ##
            if $status == ABORT;

        # ERROR
        last
            if $status == ERROR;
    }
    continue {
        push(@$stack, [ $states->[ $stack->[-1][0] ]->{'GOTOS'}->{ $lhs },
              $coderet ]),
    }

    # ERROR                                                 ## RETURN ##
    return $self->_parse_error('unexpected end of input')
        unless defined $value;

    # munge text of last directive to make it readable

    return $self->_parse_error("unexpected end of directive", $text)
        if $value eq ';';   # end of directive SEPARATOR

    return $self->_parse_error("unexpected token ($value)", $text);
}




sub _parse_error {
    my ($self, $msg, $text) = @_;
    my $line = $self->{ LINE };
    $line = ref($line) ? $$line : $line;
    $line = 'unknown' unless $line;

    $msg .= "\n  [% $text %]"
        if defined $text;

    return $self->error("line $line: $msg");
}



sub _dump {
    my $self = shift;
    my $output = "[Template::Parser] {\n";
    my $format = "    %-16s => %s\n";
    my $key;

    foreach $key (qw( START_TAG END_TAG TAG_STYLE ANYCASE INTERPOLATE
                      PRE_CHOMP POST_CHOMP V1DOLLAR )) {
        my $val = $self->{ $key };
        $val = '<undef>' unless defined $val;
        $output .= sprintf($format, $key, $val);
    }

    $output .= '}';
    return $output;
}


1;


}
#
# Inline include of Lemplate/Directive.pm
#
BEGIN { $INC{'Lemplate/Directive.pm'} = 'dummy/Lemplate/Directive.pm'; }
BEGIN {
#line 0 "Lemplate/Directive.pm"
package Lemplate::Directive;
use strict;
use warnings;


our $OUTPUT = 'i = i + 1 output[i] =';
our $WHILE_MAX = 1000;

our $INJAVASCRIPT = 0;

sub new {
    my $class = shift;

    return bless {}, $class
}

sub template {
    my ($class, $block) = @_;

    return "function() return '' end" unless $block =~ /\S/;

    return <<"...";
function (context)
    if not context then
        return error("Lemplate function called without context\\n")
    end
    local stash = context.stash
    local output = {}
    local i = 0

$block

    return output
end
...
}

sub _attempt_range_expand_val ($) {
    my $val = shift;
    return $val unless
        my ( $from, $to ) = $val =~ m/\s*\[\s*(\S+)\s*\.\.\s*(\S+)\s*\]/;

    die "Range expansion is current supported for positive/negative integer values only (e.g. [ 1 .. 10 ])\nCannot expand: $val" unless $from =~ m/^-?\d+$/ && $to =~ m/^-?\d+$/;

    return join '', '[', join( ',', $from .. $to ), ']';
}


sub textblock {
    my ($class, $text) = @_;
    return $text if $INJAVASCRIPT;
    return "$OUTPUT " . $class->text($text);
}


sub text {
    my ($class, $text) = @_;
    for ($text) {
        s/([\'\\])/\\$1/g;
        s/\n/\\n/g;
        s/\r/\\r/g;
    }
    return "'" . $text . "'";
}


sub ident {
    my ($class, $ident) = @_;
    return "''" unless @$ident;
    my $ns;

    # does the first element of the identifier have a NAMESPACE
    # handler defined?
    if (ref $class && @$ident > 2 && ($ns = $class->{ NAMESPACE })) {
        my $key = $ident->[0];
        $key =~ s/^'(.+)'$/$1/s;
        if ($ns = $ns->{ $key }) {
            return $ns->ident($ident);
        }
    }

    if (scalar @$ident <= 2 && ! $ident->[1]) {
        $ident = $ident->[0];
    }
    else {
        $ident = '{' . join(', ', @$ident) . '}';
    }
    return "stash_get(stash, $ident)";
}



sub assign {
    my ($class, $var, $val, $default) = @_;

    if (ref $var) {
        if (scalar @$var == 2 && ! $var->[1]) {
            $var = $var->[0];
        }
        else {
            $var = '{' . join(', ', @$var) . '}';
        }
    }
    $val =  _attempt_range_expand_val $val;
    $val .= ', 1' if $default;
    return "stash_set(stash, $var, $val)";
}



sub args {
    my ($class, $args) = @_;
    my $hash = shift @$args;
    push(@$args, '{ ' . join(', ', @$hash) . ' }')
        if @$hash;

    return '{}' unless @$args;
    return '{ ' . join(', ', @$args) . ' }';
}



sub filenames {
    my ($class, $names) = @_;
    if (@$names > 1) {
        $names = '[ ' . join(', ', @$names) . ' ]';
    }
    else {
        $names = shift @$names;
    }
    return $names;
}



sub get {
    my ($class, $expr) = @_;
    return "$OUTPUT $expr";
}

sub block {
    my ($class, $block) = @_;
    return join "\n", map {
        s/^#(?=line \d+)/-- /gm;
        $_;
    } @{ $block || [] };
}


sub call {
    my ($class, $expr) = @_;
    $expr .= ';';
    return $expr;
}



sub set {
    my ($class, $setlist) = @_;
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= $class->assign($var, $val) . ";\n";
    }
    chomp $output;
    return $output;
}



sub default {
    my ($class, $setlist) = @_;
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= &assign($class, $var, $val, 1) . ";\n";
    }
    chomp $output;
    return $output;
}



sub include {
    my ($class, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $class->filenames($file);
    (my $raw_file = $file) =~ s/^'|'$//g;
    $Lemplate::ExtraTemplates{$raw_file} = 1;
    my $file2 = "'$Lemplate::TemplateName/$raw_file'";
    my $str_args = (@$hash ? ', { ' . join(', ', @$hash) . ' }' : '');
    return "$OUTPUT context.include(context, template_map['$Lemplate::TemplateName/$raw_file'] and $file2 or $file$str_args)";
}



sub process {
    my ($class, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $class->filenames($file);
    (my $raw_file = $file) =~ s/^'|'$//g;
    $Lemplate::ExtraTemplates{$raw_file} = 1;
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT context.process(context, $file)";
}



sub if {
    my ($class, $expr, $block, $else) = @_;
    my @else = $else ? @$else : ();
    $else = pop @else;

    my $output = "if tt2_true($expr) then\n$block\n";

    foreach my $elsif (@else) {
        ($expr, $block) = @$elsif;
        $output .= "elseif tt2_true($expr) then\n$block\n";
    }
    if (defined $else) {
        $output .= "else\n$else\nend\n";
    } else {
        $output .= "end\n";
    }

    return $output;
}


sub foreach {
    my ($class, $target, $list, $args, $block) = @_;
    $args  = shift @$args;
    $args  = @$args ? ', { ' . join(', ', @$args) . ' }' : '';

    my ($loop_save, $loop_set, $loop_restore, $setiter);
    if ($target) {
        $loop_save =
            'local oldloop = ' . $class->ident(["'loop'"]);
        $loop_set = "stash['$target'] = value";
        $loop_restore = "stash_set(stash, 'loop', oldloop)";
    }
    else {
        die "XXX - Not supported yet";
        $loop_save = 'stash = context.localise()';
        $loop_set =
            "stash.get(['import', [value]]) if typeof(value) == 'object'";
        $loop_restore = 'stash = context.delocalise()';
    }

    $list = _attempt_range_expand_val $list;

    return <<EOF;

-- FOREACH
do
    local list = $list
    local iterator
    if list.list then
        iterator = list
        list = list.list
    end
    $loop_save
    local count
    if not iterator then
        count = table_maxn(list)
        iterator = { count = 1, max = count - 1, index = 0, size = count, first = true, last = false, prev = "" }
    else
        count = iterator.size
    end
    stash.loop = iterator
    for idx, value in ipairs(list) do
        if idx == count then
            iterator.last = true
        end
        iterator.index = idx - 1
        iterator.count = idx
        iterator.next = list[idx + 1]
        $loop_set
$block
        iterator.first = false
        iterator.prev = value
    end
    $loop_restore
end
EOF
}



sub next {
  return <<EOF;
  return error("NEXT not implemented yet")
EOF
}

sub wrapper {
    my ($class, $nameargs, $block) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;

    s/ => /: / for @$hash;
    return $class->multi_wrapper($file, $hash, $block)
        if @$file > 1;
    $file = shift @$file;
    push(@$hash, "'content': output");
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    return <<EOF;

// WRAPPER
$OUTPUT (function() {
    var output = '';
$block;
    return context.include($file);
})();
EOF
}

sub multi_wrapper {
    my ($class, $file, $hash, $block) = @_;

    push(@$hash, "'content': output");
    $hash = @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    $file = join(', ', reverse @$file);

    return <<EOF;

// WRAPPER
$OUTPUT (function() {
    var output = '';
$block;
    var files = new Array($file);
    for (var i = 0; i < files.length; i++) {
        output = context.include(files[i]$hash);
    }
    return output;
})();
EOF
}



sub while {
    my ($class, $expr, $block) = @_;

    return <<EOF;

-- WHILE
do
    local failsafe = $WHILE_MAX;
    while $expr do
        failsafe = failsafe - 1
        if failsafe <= 0 then
            break
        end
$block
    end
    if not failsafe then
        return error("WHILE loop terminated (> $WHILE_MAX iterations)\\n")
    end
end
EOF
}

sub javascript {
    my ( $class, $javascript ) = @_;
    return $javascript;
}

sub no_javascript {
    my ( $class ) = @_;
    die "EVAL_JAVASCRIPT has not been enabled, cannot process [% JAVASCRIPT %] blocks";
}


sub switch {
    my ($class, $expr, $case) = @_;
    my @case = @$case;
    my ($match, $block, $default);
    my $caseblock = '';

    $default = pop @case;

    foreach $case (@case) {
        $match = $case->[0];
        $block = $case->[1];
        $caseblock .= <<EOF;
case $match:
$block
break;

EOF
    }

    if (defined $default) {
        $caseblock .= <<EOF;
default:
$default
break;
EOF
    }

return <<EOF;

    switch($expr) {
$caseblock
    }

EOF
}



sub throw {
    my ($class, $nameargs) = @_;
    my ($type, $args) = @$nameargs;
    my $hash = shift(@$args);
    my $info = shift(@$args);
    $type = shift @$type;

    return qq{return error({$type, $info})};
}



sub clear {
    return "output = {}";
}



sub break {
    return 'break';
}


sub return {
    return "return output"
}



sub stop {
    return "return error('Lemplate.STOP\\n' .. concat(output))";
}



sub use {
    my ($class, $lnameargs) = @_;
    my ($file, $args, $alias) = @$lnameargs;
    $file = shift @$file;       # same production rule as INCLUDE
    $alias ||= $file;
    $args = &args($class, $args);
    $file .= ", $args" if $args;
    return "-- USE\n"
         . "stash_set(stash, $alias, context.plugin(context, $file))";
}



sub raw {
    my ($class, $lnameargs) = @_;
    my ($file, $args, $alias) = @$lnameargs;
    $file = shift @$file;       # same production rule as INCLUDE
    $alias ||= $file;
    $args = &args($class, $args);
    $file =~ s/'|"//g;
    return "// RAW\n"
         . "stash_set(stash, $alias, $file)";
}



sub filter {
    my ($class, $lnameargs, $block) = @_;
    my ($name, $args, $alias) = @$lnameargs;
    $name = shift @$name;
    $args = &args($class, $args);
    $args = $args ? "$args, $alias" : ", null, $alias"
        if $alias;
    $name .= ", $args" if $args;
    return <<EOF;

-- FILTER
local value
do
    local output = {}
    local i = 0

$block

    value = context.filter(output, $name)
end
$OUTPUT value
EOF
}

sub quoted {
    my $class = shift;
    if ( @_ && ref($_[0]) ) {
        return join( " .. ", @{$_[0]} );
    }
    return "return error('QUOTED called with unknown arguments in Lemplate')";
}


sub macro {
    my ($class, $ident, $block, $args) = @_;

    if ($args) {
        $args = join(';', map { "args['$_'] = fargs.shift()" } @$args);

        return <<EOF;

//MACRO
stash.set('$ident', function () {
    var output = '';
    var args = {};
    var fargs = Array.prototype.slice.call(arguments);
    $args;
    args.arguments = Array.prototype.slice.call(arguments);

    var params = fargs.shift() || {};

    for (var key in params) {
        args[key] = params[key];
    }

    context.stash.clone(args);
    try {
$block
    }
    catch(e) {
        var error = context.set_error(e, output);
        throw(error);
    }

    context.stash.declone();
    return output;
});

EOF

    }
    else {
        return <<EOF;

//MACRO

stash.set('$ident', function () {
    var output = '';
    var args = {};

    var fargs = Array.prototype.slice.call(arguments);
    args.arguments = Array.prototype.slice.call(arguments);

    if (typeof arguments[0] == 'object') args = arguments[0];

    context.stash.clone(args);
    try {
$block
    }
    catch(e) {
        var error = context.set_error(e, output);
        throw(error);
    }

    context.stash.declone();
    return output;});

EOF
    }
}

sub capture {
    my ($class, $name, $block) = @_;

    if (ref $name) {
        if (scalar @$name == 2 && ! $name->[1]) {
            $name = $name->[0];
        }
        else {
            $name = '[' . join(', ', @$name) . ']';
        }
    }

    return <<EOF;

// CAPTURE
(function() {
    var output = '';
    $block
    stash.set($name, output);
})();
EOF

}

BEGIN {
    return;  # Comment out this line to get callback traces
    no strict 'refs';
    my $pkg = __PACKAGE__ . '::';
    my $stash = \ %$pkg;
    use strict 'refs';
    for my $name (keys %$stash) {
        my $glob = $stash->{$name};
        if (*$glob{CODE}) {
            my $code = *$glob{CODE};
            no warnings 'redefine';
            $stash->{$name} = sub {
                warn "Calling $name(@_)\n";
                &$code(@_);
            };
        }
    }
}


1;


}
#
# Inline include of Lemplate/Grammar.pm
#
BEGIN { $INC{'Lemplate/Grammar.pm'} = 'dummy/Lemplate/Grammar.pm'; }
BEGIN {
#line 0 "Lemplate/Grammar.pm"

package Lemplate::Grammar;

require 5.004;

use strict;
use vars qw( $VERSION );

$VERSION  = sprintf("%d.%02d", q$Revision: 2.10 $ =~ /(\d+)\.(\d+)/);

my (@RESERVED, %CMPOP, $LEXTABLE, $RULES, $STATES);
my ($factory, $rawstart);



@RESERVED = qw( 
    GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER BLOCK END
    USE RAW PLUGIN FILTER MACRO JAVASCRIPT TO STEP AND OR NOT DIV MOD
    IF UNLESS ELSE ELSIF FOR NEXT WHILE SWITCH CASE META IN
    TRY THROW CATCH FINAL LAST RETURN STOP CLEAR VIEW DEBUG
    );


%CMPOP = qw( 
    != ~=
    == ==
    <  <
    >  >
    >= >=
    <= <=
);



$LEXTABLE = {
    'FOREACH' => 'FOR',
    'BREAK'   => 'LAST',
    '&&'      => 'AND',
    '||'      => 'OR',
    '!'       => 'NOT',
    '|'       => 'FILTER',
    '.'       => 'DOT',
    '_'       => 'CAT',
    '..'      => 'TO',
    '='       => 'ASSIGN',
    '=>'      => 'ASSIGN',
    ','       => 'COMMA',
    '\\'      => 'REF',
    'and'     => 'AND',     # explicitly specified so that qw( and or
    'or'      => 'OR',      # not ) can always be used in lower case, 
    'not'     => 'NOT',     # regardless of ANYCASE flag
    'mod'     => 'MOD',
    'div'     => 'DIV',
};

{ 
    my @tokens = qw< ( ) [ ] { } ${ $ + / ; : ? >;
    my @cmpop  = keys %CMPOP;
    my @binop  = qw( - * % );              # '+' and '/' above, in @tokens

    # fill lexer table, slice by slice, with reserved words and operators
    @$LEXTABLE{ @RESERVED, @cmpop, @binop, @tokens } 
    = ( @RESERVED, ('CMPOP') x @cmpop, ('BINOP') x @binop, @tokens );
}



sub new {
    my $class = shift;
    bless {
    LEXTABLE => $LEXTABLE,
    STATES   => $STATES,
    RULES    => $RULES,
    }, $class;
}

sub install_factory {
    my ($self, $new_factory) = @_;
    $factory = $new_factory;
}



$STATES = [
    {#State 0
        ACTIONS => {
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21,
            'MACRO' => 25,
            'BLOCK' => 27,
            'META' => 26,
            'STOP' => 28,
            'INSERT' => 24,
            'UNLESS' => 23,
            'rawperl' => 59,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'IDENT' => 29,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'USE' => 11,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53,
            'CALL' => 16,
            'GET' => 41,
            "\${" => 40,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'FILTER' => 4,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'NOT' => 8
        },
        DEFAULT => -3,
        GOTOS => {
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'switch' => 42,
            'filter' => 45,
            'ident' => 9,
            'macro' => 51,
            'node' => 54,
            'view' => 13,
            'capture' => 12,
            'atomexpr' => 15,
            'javascript' => 17,
            'block' => 14,
            'template' => 57,
            'sterm' => 58,
            'use' => 20,
            'atomdir' => 60,
            'item' => 61,
            'expr' => 64,
            'directive' => 30,
            'term' => 32,
            'chunks' => 68,
            'chunk' => 70,
            'assign' => 69,
            'condition' => 65,
            'raw' => 66,
            'setlist' => 67,
            'loop' => 33,
            'defblock' => 71,
            'anonblock' => 37,
            'defblockname' => 75,
            'try' => 74
        }
    },
    {#State 1
        ACTIONS => {
            ";" => 76
        }
    },
    {#State 2
        DEFAULT => -40
    },
    {#State 3
        ACTIONS => {
            ";" => 77
        }
    },
    {#State 4
        ACTIONS => {
            "\${" => 40,
            "\"" => 78,
            'LITERAL' => 91,
            "\$" => 82,
            'FILENAME' => 81,
            'IDENT' => 88,
            'NUMBER' => 84
        },
        GOTOS => {
            'lnameargs' => 86,
            'item' => 80,
            'nameargs' => 85,
            'filename' => 89,
            'names' => 83,
            'name' => 87,
            'lvalue' => 90,
            'filepart' => 79
        }
    },
    {#State 5
        ACTIONS => {
            'FILENAME' => 81,
            'IDENT' => 88,
            'NUMBER' => 84,
            "\${" => 40,
            "\"" => 78,
            "\$" => 82,
            'LITERAL' => 91
        },
        GOTOS => {
            'lvalue' => 90,
            'filepart' => 79,
            'name' => 87,
            'filename' => 89,
            'names' => 83,
            'item' => 80,
            'nameargs' => 85,
            'lnameargs' => 92
        }
    },
    {#State 6
        ACTIONS => {
            'IDENT' => 29,
            'LITERAL' => 94,
            "\$" => 53,
            "\${" => 40
        },
        DEFAULT => -120,
        GOTOS => {
            'params' => 93,
            'item' => 97,
            'param' => 96,
            'hash' => 95
        }
    },
    {#State 7
        ACTIONS => {
            'ASSIGN' => 98
        },
        DEFAULT => -113
    },
    {#State 8
        ACTIONS => {
            'REF' => 52,
            "\${" => 40,
            "(" => 18,
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            "{" => 6,
            'LITERAL' => 100,
            "\$" => 53
        },
        GOTOS => {
            'ident' => 99,
            'lterm' => 39,
            'sterm' => 58,
            'node' => 54,
            'item' => 61,
            'term' => 32,
            'expr' => 101
        }
    },
    {#State 9
        ACTIONS => {
            'DOT' => 103,
            'ASSIGN' => 102
        },
        DEFAULT => -110
    },
    {#State 10
        ACTIONS => {
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            "\"" => 72,
            "[" => 46,
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "(" => 18,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'expr' => 104,
            'lterm' => 39,
            'ident' => 99,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54
        }
    },
    {#State 11
        ACTIONS => {
            'NUMBER' => 84,
            'IDENT' => 88,
            'FILENAME' => 81,
            'LITERAL' => 91,
            "\$" => 82,
            "\"" => 78,
            "\${" => 40
        },
        GOTOS => {
            'lnameargs' => 105,
            'nameargs' => 85,
            'item' => 80,
            'names' => 83,
            'filename' => 89,
            'name' => 87,
            'filepart' => 79,
            'lvalue' => 90
        }
    },
    {#State 12
        DEFAULT => -11
    },
    {#State 13
        DEFAULT => -15
    },
    {#State 14
        DEFAULT => -1
    },
    {#State 15
        ACTIONS => {
            'IF' => 110,
            'WHILE' => 108,
            'FOR' => 107,
            'WRAPPER' => 111,
            'FILTER' => 106,
            'UNLESS' => 109
        }
    },
    {#State 16
        ACTIONS => {
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            "\$" => 53,
            "{" => 6,
            'LITERAL' => 100,
            'REF' => 52,
            "(" => 18,
            "\${" => 40
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'term' => 32,
            'item' => 61,
            'sterm' => 58,
            'node' => 54,
            'expr' => 112
        }
    },
    {#State 17
        DEFAULT => -26
    },
    {#State 18
        ACTIONS => {
            'REF' => 52,
            "(" => 18,
            "\${" => 40,
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            "{" => 6,
            'LITERAL' => 7,
            "\$" => 53
        },
        GOTOS => {
            'assign' => 113,
            'term' => 32,
            'sterm' => 58,
            'lterm' => 39,
            'ident' => 115,
            'expr' => 114,
            'item' => 61,
            'node' => 54
        }
    },
    {#State 19
        DEFAULT => -6
    },
    {#State 20
        DEFAULT => -13
    },
    {#State 21
        ACTIONS => {
            "\$" => 119,
            'LITERAL' => 116,
            "\"" => 120,
            'NUMBER' => 84,
            'IDENT' => 117,
            'FILENAME' => 81
        },
        GOTOS => {
            'filepart' => 79,
            'filename' => 89,
            'names' => 83,
            'name' => 87,
            'nameargs' => 118
        }
    },
    {#State 22
        ACTIONS => {
            "\$" => 53,
            "{" => 6,
            'LITERAL' => 100,
            "\"" => 72,
            "[" => 46,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29,
            "\${" => 40,
            "(" => 18,
            'REF' => 52
        },
        GOTOS => {
            'expr' => 121,
            'lterm' => 39,
            'ident' => 99,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54
        }
    },
    {#State 23
        ACTIONS => {
            "(" => 18,
            "\${" => 40,
            'REF' => 52,
            "\"" => 72,
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            "[" => 46,
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35
        },
        GOTOS => {
            'expr' => 122,
            'sterm' => 58,
            'node' => 54,
            'item' => 61,
            'term' => 32,
            'ident' => 99,
            'lterm' => 39
        }
    },
    {#State 24
        ACTIONS => {
            "\"" => 120,
            "\$" => 119,
            'LITERAL' => 116,
            'IDENT' => 117,
            'NUMBER' => 84,
            'FILENAME' => 81
        },
        GOTOS => {
            'nameargs' => 123,
            'filename' => 89,
            'filepart' => 79,
            'names' => 83,
            'name' => 87
        }
    },
    {#State 25
        ACTIONS => {
            'IDENT' => 124
        }
    },
    {#State 26
        ACTIONS => {
            'IDENT' => 127
        },
        GOTOS => {
            'metadata' => 126,
            'meta' => 125
        }
    },
    {#State 27
        ACTIONS => {
            'IDENT' => 130,
            'NUMBER' => 84,
            'FILENAME' => 81,
            'LITERAL' => 132
        },
        DEFAULT => -88,
        GOTOS => {
            'metadata' => 129,
            'meta' => 125,
            'blockargs' => 133,
            'filename' => 131,
            'filepart' => 79,
            'blockname' => 128
        }
    },
    {#State 28
        DEFAULT => -39
    },
    {#State 29
        DEFAULT => -131
    },
    {#State 30
        DEFAULT => -8
    },
    {#State 31
        ACTIONS => {
            "(" => 18,
            "\${" => 40,
            'REF' => 52,
            'LITERAL' => 100,
            "\$" => 53,
            "{" => 6,
            "\"" => 72,
            "[" => 46,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'term' => 32,
            'item' => 61,
            'sterm' => 58,
            'node' => 54,
            'expr' => 134
        }
    },
    {#State 32
        DEFAULT => -147
    },
    {#State 33
        DEFAULT => -24
    },
    {#State 34
        DEFAULT => -42
    },
    {#State 35
        DEFAULT => -114
    },
    {#State 36
        ACTIONS => {
            'REF' => 52,
            "\${" => 40,
            'NUMBER' => 35,
            'IDENT' => 136,
            "[" => 46,
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            "\"" => 72
        },
        GOTOS => {
            'item' => 61,
            'term' => 135,
            'loopvar' => 137,
            'sterm' => 58,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99
        }
    },
    {#State 37
        DEFAULT => -10
    },
    {#State 38
        DEFAULT => -44
    },
    {#State 39
        DEFAULT => -104
    },
    {#State 40
        ACTIONS => {
            'NUMBER' => 35,
            'IDENT' => 29,
            'REF' => 52,
            "\${" => 40,
            "\$" => 53,
            'LITERAL' => 100,
            "\"" => 72
        },
        GOTOS => {
            'ident' => 99,
            'node' => 54,
            'sterm' => 138,
            'item' => 61
        }
    },
    {#State 41
        ACTIONS => {
            "(" => 18,
            "\${" => 40,
            'REF' => 52,
            "[" => 46,
            "{" => 6,
            'LITERAL' => 100,
            "\$" => 53,
            "\"" => 72,
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54,
            'expr' => 139
        }
    },
    {#State 42
        DEFAULT => -23
    },
    {#State 43
        ACTIONS => {
            'NUMBER' => 84,
            'IDENT' => 117,
            'FILENAME' => 81,
            'LITERAL' => 116,
            "\$" => 119,
            "\"" => 120
        },
        GOTOS => {
            'name' => 87,
            'filepart' => 79,
            'filename' => 89,
            'names' => 83,
            'nameargs' => 140
        }
    },
    {#State 44
        DEFAULT => -38
    },
    {#State 45
        DEFAULT => -45
    },
    {#State 46
        ACTIONS => {
            'REF' => 52,
            "\${" => 40,
            "]" => 143,
            'NUMBER' => 35,
            'IDENT' => 29,
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            "\"" => 72,
            "[" => 46
        },
        GOTOS => {
            'item' => 61,
            'list' => 142,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99,
            'term' => 144,
            'range' => 145,
            'sterm' => 141
        }
    },
    {#State 47
        ACTIONS => {
            'IDENT' => 29,
            "\${" => 40,
            'LITERAL' => 147,
            "\$" => 53
        },
        GOTOS => {
            'ident' => 146,
            'item' => 61,
            'node' => 54,
            'setlist' => 148,
            'assign' => 69
        }
    },
    {#State 48
        DEFAULT => -27
    },
    {#State 49
        ACTIONS => {
            "\"" => 120,
            "\$" => 119,
            'LITERAL' => 116,
            'FILENAME' => 81,
            'IDENT' => 117,
            'NUMBER' => 84
        },
        GOTOS => {
            'name' => 87,
            'names' => 83,
            'filename' => 89,
            'filepart' => 79,
            'nameargs' => 149
        }
    },
    {#State 50
        ACTIONS => {
            'NUMBER' => 84,
            'IDENT' => 117,
            'FILENAME' => 81,
            'LITERAL' => 116,
            "\$" => 119,
            "\"" => 120
        },
        GOTOS => {
            'filename' => 89,
            'filepart' => 79,
            'names' => 83,
            'name' => 87,
            'nameargs' => 150
        }
    },
    {#State 51
        DEFAULT => -12
    },
    {#State 52
        ACTIONS => {
            'IDENT' => 29,
            "\${" => 40,
            "\$" => 53
        },
        GOTOS => {
            'ident' => 151,
            'item' => 61,
            'node' => 54
        }
    },
    {#State 53
        ACTIONS => {
            'IDENT' => 152
        }
    },
    {#State 54
        DEFAULT => -128
    },
    {#State 55
        DEFAULT => -41
    },
    {#State 56
        ACTIONS => {
            "\${" => 40,
            "\$" => 53,
            'LITERAL' => 147,
            'IDENT' => 29
        },
        GOTOS => {
            'assign' => 69,
            'setlist' => 153,
            'item' => 61,
            'node' => 54,
            'ident' => 146
        }
    },
    {#State 57
        ACTIONS => {
            '' => 154
        }
    },
    {#State 58
        DEFAULT => -105
    },
    {#State 59
        DEFAULT => -16
    },
    {#State 60
        ACTIONS => {
            ";" => -21
        },
        DEFAULT => -29
    },
    {#State 61
        ACTIONS => {
            "(" => 155
        },
        DEFAULT => -129
    },
    {#State 62
        ACTIONS => {
            "\"" => 120,
            'LITERAL' => 116,
            "\$" => 119,
            'IDENT' => 117,
            'NUMBER' => 84,
            'FILENAME' => 81
        },
        GOTOS => {
            'name' => 87,
            'names' => 83,
            'filename' => 89,
            'filepart' => 79,
            'nameargs' => 156
        }
    },
    {#State 63
        ACTIONS => {
            'FILENAME' => 81,
            'IDENT' => 117,
            'NUMBER' => 84,
            "\"" => 120,
            'LITERAL' => 116,
            "\$" => 119
        },
        GOTOS => {
            'nameargs' => 157,
            'names' => 83,
            'filepart' => 79,
            'filename' => 89,
            'name' => 87
        }
    },
    {#State 64
        ACTIONS => {
            ";" => -17,
            'MOD' => 162,
            "/" => 159,
            'AND' => 160,
            'CAT' => 163,
            "+" => 158,
            'BINOP' => 161,
            'OR' => 166,
            "?" => 167,
            'DIV' => 165,
            'CMPOP' => 164
        },
        DEFAULT => -28
    },
    {#State 65
        DEFAULT => -22
    },
    {#State 66
        DEFAULT => -14
    },
    {#State 67
        ACTIONS => {
            'COMMA' => 168,
            'IDENT' => 29,
            'LITERAL' => 147,
            "\$" => 53,
            "\${" => 40
        },
        DEFAULT => -20,
        GOTOS => {
            'assign' => 169,
            'item' => 61,
            'node' => 54,
            'ident' => 146
        }
    },
    {#State 68
        ACTIONS => {
            'NOT' => 8,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'FILTER' => 4,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'RAW' => 5,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            "\${" => 40,
            'GET' => 41,
            'CALL' => 16,
            "\$" => 53,
            'LAST' => 55,
            'DEFAULT' => 56,
            'VIEW' => 50,
            'REF' => 52,
            'SWITCH' => 10,
            'USE' => 11,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'IDENT' => 29,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31,
            'rawperl' => 59,
            'UNLESS' => 23,
            'INSERT' => 24,
            'BLOCK' => 27,
            'META' => 26,
            'MACRO' => 25,
            'STOP' => 28,
            'THROW' => 21,
            'IF' => 22,
            "(" => 18,
            'TEXT' => 19,
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34
        },
        DEFAULT => -2,
        GOTOS => {
            'expr' => 64,
            'directive' => 30,
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'switch' => 42,
            'use' => 20,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'anonblock' => 37,
            'atomexpr' => 15,
            'javascript' => 17,
            'defblockname' => 75,
            'try' => 74,
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'chunk' => 170,
            'assign' => 69,
            'condition' => 65,
            'loop' => 33,
            'macro' => 51,
            'setlist' => 67,
            'raw' => 66,
            'term' => 32,
            'ident' => 9
        }
    },
    {#State 69
        DEFAULT => -150
    },
    {#State 70
        DEFAULT => -5
    },
    {#State 71
        DEFAULT => -9
    },
    {#State 72
        DEFAULT => -177,
        GOTOS => {
            'quoted' => 171
        }
    },
    {#State 73
        ACTIONS => {
            ";" => 172
        }
    },
    {#State 74
        DEFAULT => -25
    },
    {#State 75
        ACTIONS => {
            'IDENT' => 127
        },
        DEFAULT => -88,
        GOTOS => {
            'meta' => 125,
            'metadata' => 129,
            'blockargs' => 173
        }
    },
    {#State 76
        DEFAULT => -79,
        GOTOS => {
            '@4-2' => 174
        }
    },
    {#State 77
        DEFAULT => -7
    },
    {#State 78
        DEFAULT => -177,
        GOTOS => {
            'quoted' => 175
        }
    },
    {#State 79
        DEFAULT => -172
    },
    {#State 80
        DEFAULT => -160
    },
    {#State 81
        DEFAULT => -173
    },
    {#State 82
        ACTIONS => {
            'IDENT' => 176,
            "\${" => 40,
            "\$" => 53
        },
        GOTOS => {
            'item' => 61,
            'node' => 54,
            'ident' => 177
        }
    },
    {#State 83
        ACTIONS => {
            "(" => 179,
            "+" => 178
        },
        DEFAULT => -157,
        GOTOS => {
            'args' => 180
        }
    },
    {#State 84
        DEFAULT => -175
    },
    {#State 85
        DEFAULT => -159
    },
    {#State 86
        ACTIONS => {
            ";" => 181
        }
    },
    {#State 87
        DEFAULT => -167
    },
    {#State 88
        ACTIONS => {
            'ASSIGN' => -131
        },
        DEFAULT => -174
    },
    {#State 89
        ACTIONS => {
            'DOT' => 182
        },
        DEFAULT => -169
    },
    {#State 90
        ACTIONS => {
            'ASSIGN' => 183
        }
    },
    {#State 91
        ACTIONS => {
            'ASSIGN' => -162
        },
        DEFAULT => -170
    },
    {#State 92
        DEFAULT => -76
    },
    {#State 93
        ACTIONS => {
            "\$" => 53,
            'LITERAL' => 94,
            "\${" => 40,
            'IDENT' => 29,
            'COMMA' => 184
        },
        DEFAULT => -119,
        GOTOS => {
            'param' => 185,
            'item' => 97
        }
    },
    {#State 94
        ACTIONS => {
            'ASSIGN' => 186
        }
    },
    {#State 95
        ACTIONS => {
            "}" => 187
        }
    },
    {#State 96
        DEFAULT => -123
    },
    {#State 97
        ACTIONS => {
            'ASSIGN' => 188
        }
    },
    {#State 98
        ACTIONS => {
            'REF' => 52,
            "(" => 18,
            "\${" => 40,
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "{" => 6,
            "\$" => 53,
            'LITERAL' => 100,
            "\"" => 72,
            "[" => 46
        },
        GOTOS => {
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99,
            'expr' => 189
        }
    },
    {#State 99
        ACTIONS => {
            'DOT' => 103
        },
        DEFAULT => -110
    },
    {#State 100
        DEFAULT => -113
    },
    {#State 101
        ACTIONS => {
            'CMPOP' => 164,
            'DIV' => 165,
            'BINOP' => 161,
            'MOD' => 162,
            "+" => 158,
            'CAT' => 163,
            "/" => 159
        },
        DEFAULT => -143
    },
    {#State 102
        ACTIONS => {
            "\"" => 72,
            'NEXT' => 34,
            'TRY' => 73,
            'NUMBER' => 35,
            'FOR' => 36,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21,
            'STOP' => 28,
            'BLOCK' => 190,
            'UNLESS' => 23,
            'INSERT' => 24,
            'IDENT' => 29,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'SWITCH' => 10,
            'REF' => 52,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            "\${" => 40,
            'GET' => 41,
            'FILTER' => 4,
            'RETURN' => 44,
            'INCLUDE' => 43,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8
        },
        GOTOS => {
            'item' => 61,
            'atomdir' => 60,
            'mdir' => 192,
            'filter' => 45,
            'expr' => 193,
            'directive' => 191,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'switch' => 42,
            'node' => 54,
            'javascript' => 17,
            'atomexpr' => 15,
            'try' => 74,
            'term' => 32,
            'ident' => 115,
            'assign' => 69,
            'setlist' => 67,
            'loop' => 33,
            'condition' => 65
        }
    },
    {#State 103
        ACTIONS => {
            'NUMBER' => 194,
            'IDENT' => 29,
            "\$" => 53,
            "\${" => 40
        },
        GOTOS => {
            'node' => 195,
            'item' => 61
        }
    },
    {#State 104
        ACTIONS => {
            "?" => 167,
            'OR' => 166,
            'CMPOP' => 164,
            'BINOP' => 161,
            'MOD' => 162,
            'AND' => 160,
            'CAT' => 163,
            "/" => 159,
            "+" => 158,
            'DIV' => 165,
            ";" => 196
        }
    },
    {#State 105
        DEFAULT => -75
    },
    {#State 106
        ACTIONS => {
            "\"" => 78,
            'LITERAL' => 91,
            "\$" => 82,
            "\${" => 40,
            'IDENT' => 88,
            'NUMBER' => 84,
            'FILENAME' => 81
        },
        GOTOS => {
            'filepart' => 79,
            'lvalue' => 90,
            'names' => 83,
            'filename' => 89,
            'name' => 87,
            'lnameargs' => 197,
            'nameargs' => 85,
            'item' => 80
        }
    },
    {#State 107
        ACTIONS => {
            'REF' => 52,
            "\${" => 40,
            'IDENT' => 136,
            'NUMBER' => 35,
            "\"" => 72,
            "{" => 6,
            'LITERAL' => 100,
            "\$" => 53,
            "[" => 46
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'term' => 135,
            'loopvar' => 198,
            'item' => 61,
            'sterm' => 58,
            'node' => 54
        }
    },
    {#State 108
        ACTIONS => {
            "(" => 18,
            "\${" => 40,
            'REF' => 52,
            "[" => 46,
            "{" => 6,
            "\$" => 53,
            'LITERAL' => 100,
            "\"" => 72,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54,
            'expr' => 199
        }
    },
    {#State 109
        ACTIONS => {
            "\"" => 72,
            'LITERAL' => 100,
            "\$" => 53,
            "{" => 6,
            "[" => 46,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8,
            "(" => 18,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'expr' => 200,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99
        }
    },
    {#State 110
        ACTIONS => {
            "\${" => 40,
            "(" => 18,
            'REF' => 52,
            "[" => 46,
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            "\"" => 72,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29
        },
        GOTOS => {
            'expr' => 201,
            'lterm' => 39,
            'ident' => 99,
            'term' => 32,
            'item' => 61,
            'sterm' => 58,
            'node' => 54
        }
    },
    {#State 111
        ACTIONS => {
            "\"" => 120,
            "\$" => 119,
            'LITERAL' => 116,
            'IDENT' => 117,
            'NUMBER' => 84,
            'FILENAME' => 81
        },
        GOTOS => {
            'nameargs' => 202,
            'names' => 83,
            'filepart' => 79,
            'filename' => 89,
            'name' => 87
        }
    },
    {#State 112
        ACTIONS => {
            'CMPOP' => 164,
            'DIV' => 165,
            "?" => 167,
            'OR' => 166,
            'BINOP' => 161,
            'CAT' => 163,
            "/" => 159,
            'AND' => 160,
            "+" => 158,
            'MOD' => 162
        },
        DEFAULT => -31
    },
    {#State 113
        ACTIONS => {
            ")" => 203
        }
    },
    {#State 114
        ACTIONS => {
            'CMPOP' => 164,
            'BINOP' => 161,
            "?" => 167,
            'OR' => 166,
            ")" => 204,
            'DIV' => 165,
            'CAT' => 163,
            "/" => 159,
            'AND' => 160,
            "+" => 158,
            'MOD' => 162
        }
    },
    {#State 115
        ACTIONS => {
            'ASSIGN' => 205,
            'DOT' => 103
        },
        DEFAULT => -110
    },
    {#State 116
        DEFAULT => -170
    },
    {#State 117
        DEFAULT => -174
    },
    {#State 118
        DEFAULT => -37
    },
    {#State 119
        ACTIONS => {
            "\$" => 53,
            "\${" => 40,
            'IDENT' => 29
        },
        GOTOS => {
            'item' => 61,
            'node' => 54,
            'ident' => 177
        }
    },
    {#State 120
        DEFAULT => -177,
        GOTOS => {
            'quoted' => 206
        }
    },
    {#State 121
        ACTIONS => {
            'BINOP' => 161,
            'CMPOP' => 164,
            'OR' => 166,
            "?" => 167,
            'DIV' => 165,
            ";" => 207,
            'MOD' => 162,
            "+" => 158,
            "/" => 159,
            'AND' => 160,
            'CAT' => 163
        }
    },
    {#State 122
        ACTIONS => {
            'MOD' => 162,
            "/" => 159,
            'CAT' => 163,
            'AND' => 160,
            "+" => 158,
            'DIV' => 165,
            ";" => 208,
            "?" => 167,
            'OR' => 166,
            'CMPOP' => 164,
            'BINOP' => 161
        }
    },
    {#State 123
        DEFAULT => -34
    },
    {#State 124
        ACTIONS => {
            'REF' => 52,
            'SWITCH' => 10,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'CALL' => 16,
            'DEFAULT' => 56,
            'LAST' => 55,
            "\$" => 53,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'NEXT' => 34,
            "\"" => 72,
            'THROW' => 21,
            'IF' => 22,
            "(" => 211,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'WHILE' => 31,
            'IDENT' => 29,
            'INSERT' => 24,
            'UNLESS' => 23,
            'STOP' => 28,
            'BLOCK' => 190
        },
        GOTOS => {
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'switch' => 42,
            'mdir' => 209,
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'expr' => 210,
            'directive' => 191,
            'term' => 32,
            'ident' => 115,
            'assign' => 69,
            'loop' => 33,
            'setlist' => 67,
            'condition' => 65,
            'node' => 54,
            'javascript' => 17,
            'atomexpr' => 15,
            'try' => 74
        }
    },
    {#State 125
        DEFAULT => -100
    },
    {#State 126
        ACTIONS => {
            'COMMA' => 212,
            'IDENT' => 127
        },
        DEFAULT => -18,
        GOTOS => {
            'meta' => 213
        }
    },
    {#State 127
        ACTIONS => {
            'ASSIGN' => 214
        }
    },
    {#State 128
        DEFAULT => -84
    },
    {#State 129
        ACTIONS => {
            'COMMA' => 212,
            'IDENT' => 127
        },
        DEFAULT => -87,
        GOTOS => {
            'meta' => 213
        }
    },
    {#State 130
        ACTIONS => {
            'ASSIGN' => 214
        },
        DEFAULT => -174
    },
    {#State 131
        ACTIONS => {
            'DOT' => 182
        },
        DEFAULT => -85
    },
    {#State 132
        DEFAULT => -86
    },
    {#State 133
        ACTIONS => {
            ";" => 215
        }
    },
    {#State 134
        ACTIONS => {
            "?" => 167,
            'OR' => 166,
            'BINOP' => 161,
            'CMPOP' => 164,
            "+" => 158,
            "/" => 159,
            'AND' => 160,
            'CAT' => 163,
            'MOD' => 162,
            ";" => 216,
            'DIV' => 165
        }
    },
    {#State 135
        DEFAULT => -157,
        GOTOS => {
            'args' => 217
        }
    },
    {#State 136
        ACTIONS => {
            'IN' => 218,
            'ASSIGN' => 219
        },
        DEFAULT => -131
    },
    {#State 137
        ACTIONS => {
            ";" => 220
        }
    },
    {#State 138
        ACTIONS => {
            "}" => 221
        }
    },
    {#State 139
        ACTIONS => {
            "+" => 158,
            'AND' => 160,
            'CAT' => 163,
            "/" => 159,
            'MOD' => 162,
            'BINOP' => 161,
            'OR' => 166,
            "?" => 167,
            'DIV' => 165,
            'CMPOP' => 164
        },
        DEFAULT => -30
    },
    {#State 140
        DEFAULT => -35
    },
    {#State 141
        ACTIONS => {
            'TO' => 222
        },
        DEFAULT => -105
    },
    {#State 142
        ACTIONS => {
            "\${" => 40,
            'REF' => 52,
            'COMMA' => 225,
            "[" => 46,
            "\"" => 72,
            "{" => 6,
            'LITERAL' => 100,
            "\$" => 53,
            'IDENT' => 29,
            'NUMBER' => 35,
            "]" => 224
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'term' => 223,
            'item' => 61,
            'node' => 54,
            'sterm' => 58
        }
    },
    {#State 143
        DEFAULT => -108
    },
    {#State 144
        DEFAULT => -117
    },
    {#State 145
        ACTIONS => {
            "]" => 226
        }
    },
    {#State 146
        ACTIONS => {
            'ASSIGN' => 205,
            'DOT' => 103
        }
    },
    {#State 147
        ACTIONS => {
            'ASSIGN' => 98
        }
    },
    {#State 148
        ACTIONS => {
            "\$" => 53,
            'LITERAL' => 147,
            'IDENT' => 29,
            "\${" => 40,
            'COMMA' => 168
        },
        DEFAULT => -32,
        GOTOS => {
            'assign' => 169,
            'ident' => 146,
            'node' => 54,
            'item' => 61
        }
    },
    {#State 149
        DEFAULT => -43
    },
    {#State 150
        ACTIONS => {
            ";" => 227
        }
    },
    {#State 151
        ACTIONS => {
            'DOT' => 103
        },
        DEFAULT => -111
    },
    {#State 152
        DEFAULT => -133
    },
    {#State 153
        ACTIONS => {
            "\${" => 40,
            'COMMA' => 168,
            "\$" => 53,
            'LITERAL' => 147,
            'IDENT' => 29
        },
        DEFAULT => -33,
        GOTOS => {
            'item' => 61,
            'node' => 54,
            'ident' => 146,
            'assign' => 169
        }
    },
    {#State 154
        DEFAULT => 0
    },
    {#State 155
        DEFAULT => -157,
        GOTOS => {
            'args' => 228
        }
    },
    {#State 156
        DEFAULT => -36
    },
    {#State 157
        ACTIONS => {
            ";" => 229
        }
    },
    {#State 158
        ACTIONS => {
            'REF' => 52,
            "(" => 18,
            "\${" => 40,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29,
            "[" => 46,
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            "\"" => 72
        },
        GOTOS => {
            'expr' => 230,
            'ident' => 99,
            'lterm' => 39,
            'sterm' => 58,
            'node' => 54,
            'term' => 32,
            'item' => 61
        }
    },
    {#State 159
        ACTIONS => {
            "\"" => 72,
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            "[" => 46,
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "\${" => 40,
            "(" => 18,
            'REF' => 52
        },
        GOTOS => {
            'ident' => 99,
            'lterm' => 39,
            'node' => 54,
            'sterm' => 58,
            'item' => 61,
            'term' => 32,
            'expr' => 231
        }
    },
    {#State 160
        ACTIONS => {
            "[" => 46,
            "\"" => 72,
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8,
            "(" => 18,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'expr' => 232,
            'term' => 32,
            'item' => 61,
            'node' => 54,
            'sterm' => 58,
            'lterm' => 39,
            'ident' => 99
        }
    },
    {#State 161
        ACTIONS => {
            "[" => 46,
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            "\"" => 72,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29,
            "(" => 18,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'lterm' => 39,
            'ident' => 99,
            'term' => 32,
            'item' => 61,
            'sterm' => 58,
            'node' => 54,
            'expr' => 233
        }
    },
    {#State 162
        ACTIONS => {
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            'LITERAL' => 100,
            "\$" => 53,
            "{" => 6,
            'REF' => 52,
            "\${" => 40,
            "(" => 18
        },
        GOTOS => {
            'expr' => 234,
            'term' => 32,
            'item' => 61,
            'node' => 54,
            'sterm' => 58,
            'lterm' => 39,
            'ident' => 99
        }
    },
    {#State 163
        ACTIONS => {
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "{" => 6,
            'LITERAL' => 100,
            "\$" => 53,
            "\"" => 72,
            "[" => 46,
            'REF' => 52,
            "(" => 18,
            "\${" => 40
        },
        GOTOS => {
            'expr' => 235,
            'ident' => 99,
            'lterm' => 39,
            'node' => 54,
            'sterm' => 58,
            'item' => 61,
            'term' => 32
        }
    },
    {#State 164
        ACTIONS => {
            "[" => 46,
            "\"" => 72,
            "\$" => 53,
            "{" => 6,
            'LITERAL' => 100,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8,
            "(" => 18,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'term' => 32,
            'item' => 61,
            'sterm' => 58,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99,
            'expr' => 236
        }
    },
    {#State 165
        ACTIONS => {
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            "\"" => 72,
            "[" => 46,
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "(" => 18,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'expr' => 237,
            'lterm' => 39,
            'ident' => 99,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54
        }
    },
    {#State 166
        ACTIONS => {
            'REF' => 52,
            "(" => 18,
            "\${" => 40,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29,
            'LITERAL' => 100,
            "\$" => 53,
            "{" => 6,
            "\"" => 72,
            "[" => 46
        },
        GOTOS => {
            'sterm' => 58,
            'node' => 54,
            'item' => 61,
            'term' => 32,
            'ident' => 99,
            'lterm' => 39,
            'expr' => 238
        }
    },
    {#State 167
        ACTIONS => {
            "(" => 18,
            "\${" => 40,
            'REF' => 52,
            "[" => 46,
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            "\"" => 72,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29
        },
        GOTOS => {
            'expr' => 239,
            'ident' => 99,
            'lterm' => 39,
            'node' => 54,
            'sterm' => 58,
            'term' => 32,
            'item' => 61
        }
    },
    {#State 168
        DEFAULT => -149
    },
    {#State 169
        DEFAULT => -148
    },
    {#State 170
        DEFAULT => -4
    },
    {#State 171
        ACTIONS => {
            "\"" => 244,
            ";" => 243,
            "\$" => 53,
            'TEXT' => 242,
            "\${" => 40,
            'IDENT' => 29
        },
        GOTOS => {
            'quotable' => 241,
            'item' => 61,
            'node' => 54,
            'ident' => 240
        }
    },
    {#State 172
        ACTIONS => {
            'TRY' => 73,
            'NUMBER' => 35,
            'FOR' => 36,
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18,
            'IDENT' => 29,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'rawperl' => 59,
            'META' => 26,
            'MACRO' => 25,
            'BLOCK' => 27,
            'STOP' => 28,
            'INSERT' => 24,
            'UNLESS' => 23,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'USE' => 11,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'CALL' => 16,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'FILTER' => 4,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'GET' => 41,
            "\${" => 40,
            'NOT' => 8,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46
        },
        DEFAULT => -3,
        GOTOS => {
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'atomexpr' => 15,
            'anonblock' => 37,
            'javascript' => 17,
            'defblockname' => 75,
            'try' => 74,
            'block' => 245,
            'term' => 32,
            'ident' => 9,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'condition' => 65,
            'macro' => 51,
            'loop' => 33,
            'setlist' => 67,
            'raw' => 66,
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'use' => 20,
            'switch' => 42
        }
    },
    {#State 173
        ACTIONS => {
            ";" => 246
        }
    },
    {#State 174
        ACTIONS => {
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'USE' => 11,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'GET' => 41,
            "\${" => 40,
            'FILTER' => 4,
            'RAW' => 5,
            'RETURN' => 44,
            'INCLUDE' => 43,
            "\"" => 72,
            ";" => -19,
            'NEXT' => 34,
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            'rawperl' => 59,
            'META' => 26,
            'MACRO' => 25,
            'BLOCK' => 27,
            'STOP' => 28,
            'INSERT' => 24,
            'UNLESS' => 23,
            'IDENT' => 29,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21
        },
        DEFAULT => -3,
        GOTOS => {
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30,
            'statement' => 3,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'use' => 20,
            'switch' => 42,
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'defblock' => 71,
            'defblockname' => 75,
            'javascript' => 17,
            'atomexpr' => 15,
            'anonblock' => 37,
            'block' => 247,
            'try' => 74,
            'term' => 32,
            'ident' => 9,
            'assign' => 69,
            'chunk' => 70,
            'chunks' => 68,
            'setlist' => 67,
            'loop' => 33,
            'raw' => 66,
            'macro' => 51,
            'condition' => 65
        }
    },
    {#State 175
        ACTIONS => {
            'IDENT' => 29,
            "\${" => 40,
            'TEXT' => 242,
            "\$" => 53,
            ";" => 243,
            "\"" => 248
        },
        GOTOS => {
            'ident' => 240,
            'node' => 54,
            'item' => 61,
            'quotable' => 241
        }
    },
    {#State 176
        ACTIONS => {
            'ASSIGN' => -133
        },
        DEFAULT => -131
    },
    {#State 177
        ACTIONS => {
            'DOT' => 103
        },
        DEFAULT => -157,
        GOTOS => {
            'args' => 249
        }
    },
    {#State 178
        ACTIONS => {
            "\"" => 120,
            'LITERAL' => 116,
            'FILENAME' => 81,
            'IDENT' => 117,
            'NUMBER' => 84
        },
        GOTOS => {
            'filename' => 89,
            'filepart' => 79,
            'name' => 250
        }
    },
    {#State 179
        DEFAULT => -157,
        GOTOS => {
            'args' => 251
        }
    },
    {#State 180
        ACTIONS => {
            'REF' => 52,
            "\"" => 72,
            "\$" => 53,
            'NUMBER' => 35,
            "\${" => 40,
            "(" => 18,
            'COMMA' => 252,
            'LITERAL' => 257,
            "{" => 6,
            "[" => 46,
            'IDENT' => 29,
            'NOT' => 8
        },
        DEFAULT => -164,
        GOTOS => {
            'expr' => 254,
            'param' => 255,
            'node' => 54,
            'item' => 253,
            'ident' => 256,
            'lterm' => 39,
            'sterm' => 58,
            'term' => 32
        }
    },
    {#State 181
        ACTIONS => {
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'IDENT' => 29,
            'META' => 26,
            'MACRO' => 25,
            'BLOCK' => 27,
            'STOP' => 28,
            'UNLESS' => 23,
            'INSERT' => 24,
            'rawperl' => 59,
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'RAW' => 5,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'USE' => 11,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'CALL' => 16,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53
        },
        DEFAULT => -3,
        GOTOS => {
            'ident' => 9,
            'term' => 32,
            'condition' => 65,
            'loop' => 33,
            'macro' => 51,
            'setlist' => 67,
            'raw' => 66,
            'chunks' => 68,
            'chunk' => 70,
            'assign' => 69,
            'defblock' => 71,
            'capture' => 12,
            'node' => 54,
            'view' => 13,
            'try' => 74,
            'block' => 258,
            'atomexpr' => 15,
            'anonblock' => 37,
            'defblockname' => 75,
            'javascript' => 17,
            'wrapper' => 38,
            'lterm' => 39,
            'sterm' => 58,
            'statement' => 3,
            'use' => 20,
            'switch' => 42,
            'filter' => 45,
            'atomdir' => 60,
            'item' => 61,
            'directive' => 30,
            'expr' => 64
        }
    },
    {#State 182
        ACTIONS => {
            'IDENT' => 117,
            'NUMBER' => 84,
            'FILENAME' => 81
        },
        GOTOS => {
            'filepart' => 259
        }
    },
    {#State 183
        ACTIONS => {
            "\"" => 120,
            "\$" => 119,
            'LITERAL' => 116,
            'FILENAME' => 81,
            'IDENT' => 117,
            'NUMBER' => 84
        },
        GOTOS => {
            'filename' => 89,
            'filepart' => 79,
            'names' => 83,
            'name' => 87,
            'nameargs' => 260
        }
    },
    {#State 184
        DEFAULT => -122
    },
    {#State 185
        DEFAULT => -121
    },
    {#State 186
        ACTIONS => {
            'REF' => 52,
            "(" => 18,
            "\${" => 40,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8,
            "[" => 46,
            "\"" => 72,
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6
        },
        GOTOS => {
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99,
            'expr' => 261
        }
    },
    {#State 187
        DEFAULT => -109
    },
    {#State 188
        ACTIONS => {
            'REF' => 52,
            "\${" => 40,
            "(" => 18,
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "\$" => 53,
            "{" => 6,
            'LITERAL' => 100,
            "\"" => 72,
            "[" => 46
        },
        GOTOS => {
            'term' => 32,
            'item' => 61,
            'node' => 54,
            'sterm' => 58,
            'lterm' => 39,
            'ident' => 99,
            'expr' => 262
        }
    },
    {#State 189
        ACTIONS => {
            'DIV' => 165,
            'CMPOP' => 164,
            'CAT' => 163,
            "/" => 159,
            'AND' => 160,
            "+" => 158,
            'MOD' => 162,
            'BINOP' => 161,
            'OR' => 166,
            "?" => 167
        },
        DEFAULT => -152
    },
    {#State 190
        ACTIONS => {
            ";" => 263
        }
    },
    {#State 191
        DEFAULT => -93
    },
    {#State 192
        DEFAULT => -90
    },
    {#State 193
        ACTIONS => {
            'BINOP' => 161,
            "?" => 167,
            'OR' => 166,
            ";" => -151,
            "\$" => -151,
            'MOD' => 162,
            "+" => 158,
            'CAT' => 163,
            'AND' => 160,
            "/" => 159,
            "\${" => -151,
            'CMPOP' => 164,
            'COMMA' => -151,
            'DIV' => 165,
            'LITERAL' => -151,
            'IDENT' => -151
        },
        DEFAULT => -28
    },
    {#State 194
        DEFAULT => -127
    },
    {#State 195
        DEFAULT => -126
    },
    {#State 196
        ACTIONS => {
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'IDENT' => 29,
            'META' => 26,
            'BLOCK' => 27,
            'STOP' => 28,
            'MACRO' => 25,
            'INSERT' => 24,
            'UNLESS' => 23,
            'rawperl' => 59,
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18,
            'CALL' => 16,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53,
            'USE' => 11,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'FILTER' => 4,
            'GET' => 41,
            "\${" => 40,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1
        },
        DEFAULT => -3,
        GOTOS => {
            'macro' => 51,
            'setlist' => 67,
            'loop' => 33,
            'raw' => 66,
            'condition' => 65,
            'chunk' => 70,
            'assign' => 69,
            'chunks' => 68,
            'ident' => 9,
            'term' => 32,
            'block' => 264,
            'try' => 74,
            'javascript' => 17,
            'defblockname' => 75,
            'atomexpr' => 15,
            'anonblock' => 37,
            'capture' => 12,
            'defblock' => 71,
            'view' => 13,
            'node' => 54,
            'use' => 20,
            'switch' => 42,
            'lterm' => 39,
            'wrapper' => 38,
            'statement' => 3,
            'sterm' => 58,
            'directive' => 30,
            'expr' => 64,
            'filter' => 45,
            'item' => 61,
            'atomdir' => 60
        }
    },
    {#State 197
        DEFAULT => -82
    },
    {#State 198
        DEFAULT => -60
    },
    {#State 199
        ACTIONS => {
            "+" => 158,
            'CAT' => 163,
            "/" => 159,
            'AND' => 160,
            'MOD' => 162,
            'DIV' => 165,
            'OR' => 166,
            "?" => 167,
            'BINOP' => 161,
            'CMPOP' => 164
        },
        DEFAULT => -63
    },
    {#State 200
        ACTIONS => {
            'CMPOP' => 164,
            'BINOP' => 161,
            "?" => 167,
            'OR' => 166,
            'DIV' => 165,
            'MOD' => 162,
            "/" => 159,
            'AND' => 160,
            'CAT' => 163,
            "+" => 158
        },
        DEFAULT => -49
    },
    {#State 201
        ACTIONS => {
            'CMPOP' => 164,
            'BINOP' => 161,
            "?" => 167,
            'OR' => 166,
            'DIV' => 165,
            "/" => 159,
            'AND' => 160,
            'CAT' => 163,
            "+" => 158,
            'MOD' => 162
        },
        DEFAULT => -47
    },
    {#State 202
        DEFAULT => -68
    },
    {#State 203
        DEFAULT => -145
    },
    {#State 204
        DEFAULT => -146
    },
    {#State 205
        ACTIONS => {
            "\${" => 40,
            "(" => 18,
            'REF' => 52,
            "\"" => 72,
            "{" => 6,
            'LITERAL' => 100,
            "\$" => 53,
            "[" => 46,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8
        },
        GOTOS => {
            'expr' => 265,
            'ident' => 99,
            'lterm' => 39,
            'node' => 54,
            'sterm' => 58,
            'item' => 61,
            'term' => 32
        }
    },
    {#State 206
        ACTIONS => {
            "\"" => 266,
            ";" => 243,
            "\$" => 53,
            'TEXT' => 242,
            "\${" => 40,
            'IDENT' => 29
        },
        GOTOS => {
            'quotable' => 241,
            'item' => 61,
            'node' => 54,
            'ident' => 240
        }
    },
    {#State 207
        ACTIONS => {
            'THROW' => 21,
            'IF' => 22,
            "(" => 18,
            'TEXT' => 19,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31,
            'IDENT' => 29,
            'UNLESS' => 23,
            'INSERT' => 24,
            'MACRO' => 25,
            'STOP' => 28,
            'BLOCK' => 27,
            'META' => 26,
            'rawperl' => 59,
            'FOR' => 36,
            'NUMBER' => 35,
            'TRY' => 73,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'RAW' => 5,
            'FILTER' => 4,
            'GET' => 41,
            "\${" => 40,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            'NOT' => 8,
            "[" => 46,
            "{" => 6,
            'LITERAL' => 7,
            'USE' => 11,
            'VIEW' => 50,
            'SWITCH' => 10,
            'REF' => 52,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'CALL' => 16,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53
        },
        DEFAULT => -3,
        GOTOS => {
            'use' => 20,
            'switch' => 42,
            'statement' => 3,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'expr' => 64,
            'directive' => 30,
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45,
            'assign' => 69,
            'chunk' => 70,
            'chunks' => 68,
            'setlist' => 67,
            'loop' => 33,
            'raw' => 66,
            'macro' => 51,
            'condition' => 65,
            'term' => 32,
            'ident' => 9,
            'javascript' => 17,
            'defblockname' => 75,
            'atomexpr' => 15,
            'anonblock' => 37,
            'block' => 267,
            'try' => 74,
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'defblock' => 71
        }
    },
    {#State 208
        ACTIONS => {
            'DEFAULT' => 56,
            'LAST' => 55,
            "\$" => 53,
            'CALL' => 16,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'USE' => 11,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'NOT' => 8,
            'GET' => 41,
            "\${" => 40,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'FILTER' => 4,
            'NEXT' => 34,
            "\"" => 72,
            ";" => -19,
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'STOP' => 28,
            'BLOCK' => 27,
            'MACRO' => 25,
            'META' => 26,
            'UNLESS' => 23,
            'INSERT' => 24,
            'rawperl' => 59,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'IDENT' => 29,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21
        },
        DEFAULT => -3,
        GOTOS => {
            'term' => 32,
            'ident' => 9,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'condition' => 65,
            'loop' => 33,
            'raw' => 66,
            'setlist' => 67,
            'macro' => 51,
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'atomexpr' => 15,
            'anonblock' => 37,
            'defblockname' => 75,
            'javascript' => 17,
            'try' => 74,
            'block' => 268,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'switch' => 42,
            'use' => 20,
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30
        }
    },
    {#State 209
        DEFAULT => -92
    },
    {#State 210
        ACTIONS => {
            'MOD' => 162,
            'AND' => 160,
            'CAT' => 163,
            "/" => 159,
            "+" => 158,
            'BINOP' => 161,
            "?" => 167,
            'OR' => 166,
            'DIV' => 165,
            'CMPOP' => 164
        },
        DEFAULT => -28
    },
    {#State 211
        ACTIONS => {
            'IDENT' => 270,
            'NOT' => 8,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            'LITERAL' => 7,
            "\$" => 53,
            "{" => 6,
            'REF' => 52,
            "(" => 18,
            "\${" => 40
        },
        GOTOS => {
            'expr' => 114,
            'node' => 54,
            'item' => 61,
            'margs' => 269,
            'assign' => 113,
            'ident' => 115,
            'lterm' => 39,
            'sterm' => 58,
            'term' => 32
        }
    },
    {#State 212
        DEFAULT => -99
    },
    {#State 213
        DEFAULT => -98
    },
    {#State 214
        ACTIONS => {
            'NUMBER' => 272,
            "\"" => 271,
            'LITERAL' => 273
        }
    },
    {#State 215
        ACTIONS => {
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'USE' => 11,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53,
            'CALL' => 16,
            'GET' => 41,
            "\${" => 40,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'RAW' => 5,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'FILTER' => 4,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'NOT' => 8,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'FOR' => 36,
            'NUMBER' => 35,
            'TRY' => 73,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21,
            'STOP' => 28,
            'MACRO' => 25,
            'META' => 26,
            'BLOCK' => 27,
            'UNLESS' => 23,
            'INSERT' => 24,
            'rawperl' => 59,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'IDENT' => 29
        },
        DEFAULT => -3,
        GOTOS => {
            'directive' => 30,
            'expr' => 64,
            'filter' => 45,
            'item' => 61,
            'atomdir' => 60,
            'use' => 20,
            'switch' => 42,
            'wrapper' => 38,
            'lterm' => 39,
            'sterm' => 58,
            'statement' => 3,
            'try' => 74,
            'block' => 274,
            'anonblock' => 37,
            'atomexpr' => 15,
            'defblockname' => 75,
            'javascript' => 17,
            'defblock' => 71,
            'capture' => 12,
            'node' => 54,
            'view' => 13,
            'condition' => 65,
            'loop' => 33,
            'macro' => 51,
            'setlist' => 67,
            'raw' => 66,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'ident' => 9,
            'term' => 32
        }
    },
    {#State 216
        DEFAULT => -61,
        GOTOS => {
            '@2-3' => 275
        }
    },
    {#State 217
        ACTIONS => {
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "\"" => 72,
            'LITERAL' => 257,
            "\$" => 53,
            "{" => 6,
            "[" => 46,
            'REF' => 52,
            'COMMA' => 252,
            "(" => 18,
            "\${" => 40
        },
        DEFAULT => -66,
        GOTOS => {
            'expr' => 254,
            'item' => 253,
            'node' => 54,
            'param' => 255,
            'term' => 32,
            'sterm' => 58,
            'lterm' => 39,
            'ident' => 256
        }
    },
    {#State 218
        ACTIONS => {
            "\$" => 53,
            'LITERAL' => 100,
            "{" => 6,
            "\"" => 72,
            "[" => 46,
            'NUMBER' => 35,
            'IDENT' => 29,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'sterm' => 58,
            'node' => 54,
            'term' => 276,
            'item' => 61,
            'ident' => 99,
            'lterm' => 39
        }
    },
    {#State 219
        ACTIONS => {
            'IDENT' => 29,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            'REF' => 52,
            "\${" => 40
        },
        GOTOS => {
            'node' => 54,
            'sterm' => 58,
            'item' => 61,
            'term' => 277,
            'ident' => 99,
            'lterm' => 39
        }
    },
    {#State 220
        DEFAULT => -58,
        GOTOS => {
            '@1-3' => 278
        }
    },
    {#State 221
        DEFAULT => -132
    },
    {#State 222
        ACTIONS => {
            "\$" => 53,
            'LITERAL' => 100,
            "\"" => 72,
            "\${" => 40,
            'NUMBER' => 35,
            'IDENT' => 29,
            'REF' => 52
        },
        GOTOS => {
            'ident' => 99,
            'node' => 54,
            'sterm' => 279,
            'item' => 61
        }
    },
    {#State 223
        DEFAULT => -115
    },
    {#State 224
        DEFAULT => -106
    },
    {#State 225
        DEFAULT => -116
    },
    {#State 226
        DEFAULT => -107
    },
    {#State 227
        DEFAULT => -77,
        GOTOS => {
            '@3-3' => 280
        }
    },
    {#State 228
        ACTIONS => {
            'LITERAL' => 257,
            "\$" => 53,
            "{" => 6,
            "\"" => 72,
            "[" => 46,
            ")" => 281,
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "\${" => 40,
            "(" => 18,
            'COMMA' => 252,
            'REF' => 52
        },
        GOTOS => {
            'param' => 255,
            'node' => 54,
            'item' => 253,
            'expr' => 254,
            'ident' => 256,
            'lterm' => 39,
            'sterm' => 58,
            'term' => 32
        }
    },
    {#State 229
        ACTIONS => {
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'TRY' => 73,
            'NUMBER' => 35,
            'FOR' => 36,
            'rawperl' => 59,
            'UNLESS' => 23,
            'INSERT' => 24,
            'META' => 26,
            'STOP' => 28,
            'MACRO' => 25,
            'BLOCK' => 27,
            'IDENT' => 29,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31,
            "(" => 18,
            'TEXT' => 19,
            'THROW' => 21,
            'IF' => 22,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'VIEW' => 50,
            'SWITCH' => 10,
            'REF' => 52,
            'USE' => 11,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            "\${" => 40,
            'GET' => 41,
            'FILTER' => 4,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'RAW' => 5
        },
        DEFAULT => -3,
        GOTOS => {
            'chunk' => 70,
            'assign' => 69,
            'chunks' => 68,
            'macro' => 51,
            'setlist' => 67,
            'raw' => 66,
            'loop' => 33,
            'condition' => 65,
            'term' => 32,
            'ident' => 9,
            'defblockname' => 75,
            'javascript' => 17,
            'anonblock' => 37,
            'atomexpr' => 15,
            'block' => 282,
            'try' => 74,
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'defblock' => 71,
            'switch' => 42,
            'use' => 20,
            'statement' => 3,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'expr' => 64,
            'directive' => 30,
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45
        }
    },
    {#State 230
        ACTIONS => {
            'MOD' => 162,
            "/" => 159,
            'DIV' => 165
        },
        DEFAULT => -136
    },
    {#State 231
        ACTIONS => {
            'DIV' => 165,
            'MOD' => 162
        },
        DEFAULT => -135
    },
    {#State 232
        ACTIONS => {
            'CMPOP' => 164,
            'DIV' => 165,
            'BINOP' => 161,
            'MOD' => 162,
            "+" => 158,
            "/" => 159,
            'CAT' => 163
        },
        DEFAULT => -141
    },
    {#State 233
        ACTIONS => {
            'DIV' => 165,
            'MOD' => 162,
            "/" => 159,
            "+" => 158
        },
        DEFAULT => -134
    },
    {#State 234
        DEFAULT => -138
    },
    {#State 235
        ACTIONS => {
            'CMPOP' => 164,
            'DIV' => 165,
            'BINOP' => 161,
            'MOD' => 162,
            "+" => 158,
            "/" => 159
        },
        DEFAULT => -140
    },
    {#State 236
        ACTIONS => {
            "+" => 158,
            "/" => 159,
            'MOD' => 162,
            'BINOP' => 161,
            'DIV' => 165
        },
        DEFAULT => -139
    },
    {#State 237
        ACTIONS => {
            'MOD' => 162
        },
        DEFAULT => -137
    },
    {#State 238
        ACTIONS => {
            'BINOP' => 161,
            'MOD' => 162,
            "+" => 158,
            "/" => 159,
            'CAT' => 163,
            'CMPOP' => 164,
            'DIV' => 165
        },
        DEFAULT => -142
    },
    {#State 239
        ACTIONS => {
            'CMPOP' => 164,
            'BINOP' => 161,
            ":" => 283,
            'OR' => 166,
            "?" => 167,
            'DIV' => 165,
            'MOD' => 162,
            'AND' => 160,
            "/" => 159,
            'CAT' => 163,
            "+" => 158
        }
    },
    {#State 240
        ACTIONS => {
            'DOT' => 103
        },
        DEFAULT => -178
    },
    {#State 241
        DEFAULT => -176
    },
    {#State 242
        DEFAULT => -179
    },
    {#State 243
        DEFAULT => -180
    },
    {#State 244
        DEFAULT => -112
    },
    {#State 245
        ACTIONS => {
            'FINAL' => 286,
            'CATCH' => 285
        },
        DEFAULT => -74,
        GOTOS => {
            'final' => 284
        }
    },
    {#State 246
        ACTIONS => {
            'TRY' => 73,
            'NUMBER' => 35,
            'FOR' => 36,
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18,
            'IDENT' => 29,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'rawperl' => 59,
            'META' => 26,
            'BLOCK' => 27,
            'STOP' => 28,
            'MACRO' => 25,
            'INSERT' => 24,
            'UNLESS' => 23,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            'USE' => 11,
            'perl' => 48,
            'SET' => 47,
            'DEBUG' => 49,
            'CALL' => 16,
            "\$" => 53,
            'LAST' => 55,
            'DEFAULT' => 56,
            'FILTER' => 4,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            "\${" => 40,
            'GET' => 41,
            'NOT' => 8,
            'LITERAL' => 7,
            "{" => 6,
            "[" => 46
        },
        DEFAULT => -3,
        GOTOS => {
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'javascript' => 17,
            'atomexpr' => 15,
            'block' => 14,
            'template' => 287,
            'ident' => 9,
            'macro' => 51,
            'filter' => 45,
            'statement' => 3,
            'lterm' => 39,
            'wrapper' => 38,
            'switch' => 42,
            'defblock' => 71,
            'defblockname' => 75,
            'anonblock' => 37,
            'try' => 74,
            'term' => 32,
            'assign' => 69,
            'chunk' => 70,
            'chunks' => 68,
            'loop' => 33,
            'setlist' => 67,
            'raw' => 66,
            'condition' => 65,
            'atomdir' => 60,
            'item' => 61,
            'expr' => 64,
            'directive' => 30,
            'sterm' => 58,
            'use' => 20
        }
    },
    {#State 247
        ACTIONS => {
            'END' => 288
        }
    },
    {#State 248
        ACTIONS => {
            'ASSIGN' => -161
        },
        DEFAULT => -168
    },
    {#State 249
        ACTIONS => {
            'NUMBER' => 35,
            "\$" => 53,
            "\"" => 72,
            'REF' => 52,
            'NOT' => 8,
            'IDENT' => 29,
            "[" => 46,
            "{" => 6,
            'LITERAL' => 257,
            'COMMA' => 252,
            "\${" => 40,
            "(" => 18
        },
        DEFAULT => -163,
        GOTOS => {
            'sterm' => 58,
            'term' => 32,
            'ident' => 256,
            'lterm' => 39,
            'node' => 54,
            'item' => 253,
            'param' => 255,
            'expr' => 254
        }
    },
    {#State 250
        DEFAULT => -166
    },
    {#State 251
        ACTIONS => {
            "{" => 6,
            "\$" => 53,
            'LITERAL' => 257,
            "\"" => 72,
            ")" => 289,
            "[" => 46,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29,
            "(" => 18,
            "\${" => 40,
            'COMMA' => 252,
            'REF' => 52
        },
        GOTOS => {
            'node' => 54,
            'item' => 253,
            'param' => 255,
            'expr' => 254,
            'sterm' => 58,
            'term' => 32,
            'ident' => 256,
            'lterm' => 39
        }
    },
    {#State 252
        DEFAULT => -156
    },
    {#State 253
        ACTIONS => {
            "(" => 155,
            'ASSIGN' => 188
        },
        DEFAULT => -129
    },
    {#State 254
        ACTIONS => {
            'MOD' => 162,
            "+" => 158,
            'CAT' => 163,
            'AND' => 160,
            "/" => 159,
            'BINOP' => 161,
            "?" => 167,
            'OR' => 166,
            'DIV' => 165,
            'CMPOP' => 164
        },
        DEFAULT => -153
    },
    {#State 255
        DEFAULT => -154
    },
    {#State 256
        ACTIONS => {
            'DOT' => 103,
            'ASSIGN' => 290
        },
        DEFAULT => -110
    },
    {#State 257
        ACTIONS => {
            'ASSIGN' => 186
        },
        DEFAULT => -113
    },
    {#State 258
        ACTIONS => {
            'END' => 291
        }
    },
    {#State 259
        DEFAULT => -171
    },
    {#State 260
        DEFAULT => -158
    },
    {#State 261
        ACTIONS => {
            'BINOP' => 161,
            'CAT' => 163,
            "/" => 159,
            "+" => 158,
            'MOD' => 162,
            "?" => 167,
            'OR' => 166,
            'AND' => 160,
            'CMPOP' => 164,
            'DIV' => 165
        },
        DEFAULT => -124
    },
    {#State 262
        ACTIONS => {
            'DIV' => 165,
            'CMPOP' => 164,
            'AND' => 160,
            "?" => 167,
            'OR' => 166,
            "+" => 158,
            'CAT' => 163,
            "/" => 159,
            'MOD' => 162,
            'BINOP' => 161
        },
        DEFAULT => -125
    },
    {#State 263
        ACTIONS => {
            'CALL' => 16,
            'DEFAULT' => 56,
            'LAST' => 55,
            "\$" => 53,
            'USE' => 11,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'DEBUG' => 49,
            'perl' => 48,
            'SET' => 47,
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'RAW' => 5,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'FOR' => 36,
            'NUMBER' => 35,
            'TRY' => 73,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'IDENT' => 29,
            'META' => 26,
            'STOP' => 28,
            'MACRO' => 25,
            'BLOCK' => 27,
            'INSERT' => 24,
            'UNLESS' => 23,
            'rawperl' => 59,
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18
        },
        DEFAULT => -3,
        GOTOS => {
            'switch' => 42,
            'use' => 20,
            'lterm' => 39,
            'wrapper' => 38,
            'statement' => 3,
            'sterm' => 58,
            'directive' => 30,
            'expr' => 64,
            'filter' => 45,
            'atomdir' => 60,
            'item' => 61,
            'setlist' => 67,
            'loop' => 33,
            'raw' => 66,
            'macro' => 51,
            'condition' => 65,
            'chunk' => 70,
            'assign' => 69,
            'chunks' => 68,
            'ident' => 9,
            'term' => 32,
            'block' => 292,
            'try' => 74,
            'javascript' => 17,
            'defblockname' => 75,
            'anonblock' => 37,
            'atomexpr' => 15,
            'capture' => 12,
            'defblock' => 71,
            'view' => 13,
            'node' => 54
        }
    },
    {#State 264
        ACTIONS => {
            'CASE' => 293
        },
        DEFAULT => -57,
        GOTOS => {
            'case' => 294
        }
    },
    {#State 265
        ACTIONS => {
            'AND' => 160,
            "/" => 159,
            'CAT' => 163,
            "+" => 158,
            'MOD' => 162,
            "?" => 167,
            'OR' => 166,
            'BINOP' => 161,
            'DIV' => 165,
            'CMPOP' => 164
        },
        DEFAULT => -151
    },
    {#State 266
        DEFAULT => -168
    },
    {#State 267
        ACTIONS => {
            'ELSE' => 295,
            'ELSIF' => 297
        },
        DEFAULT => -52,
        GOTOS => {
            'else' => 296
        }
    },
    {#State 268
        ACTIONS => {
            'ELSIF' => 297,
            'ELSE' => 295
        },
        DEFAULT => -52,
        GOTOS => {
            'else' => 298
        }
    },
    {#State 269
        ACTIONS => {
            ")" => 300,
            'IDENT' => 301,
            'COMMA' => 299
        }
    },
    {#State 270
        ACTIONS => {
            'IDENT' => -97,
            ")" => -97,
            'COMMA' => -97
        },
        DEFAULT => -131
    },
    {#State 271
        ACTIONS => {
            'TEXT' => 302
        }
    },
    {#State 272
        DEFAULT => -103
    },
    {#State 273
        DEFAULT => -101
    },
    {#State 274
        ACTIONS => {
            'END' => 303
        }
    },
    {#State 275
        ACTIONS => {
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'RAW' => 5,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            'CALL' => 16,
            'DEFAULT' => 56,
            'LAST' => 55,
            "\$" => 53,
            'USE' => 11,
            'VIEW' => 50,
            'SWITCH' => 10,
            'REF' => 52,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31,
            'IDENT' => 29,
            'INSERT' => 24,
            'UNLESS' => 23,
            'BLOCK' => 27,
            'STOP' => 28,
            'META' => 26,
            'MACRO' => 25,
            'rawperl' => 59,
            'THROW' => 21,
            'IF' => 22,
            "(" => 18,
            'TEXT' => 19,
            'FOR' => 36,
            'NUMBER' => 35,
            'TRY' => 73,
            'NEXT' => 34,
            "\"" => 72,
            ";" => -19
        },
        DEFAULT => -3,
        GOTOS => {
            'term' => 32,
            'ident' => 9,
            'assign' => 69,
            'chunk' => 70,
            'chunks' => 68,
            'setlist' => 67,
            'raw' => 66,
            'loop' => 33,
            'macro' => 51,
            'condition' => 65,
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'defblock' => 71,
            'javascript' => 17,
            'defblockname' => 75,
            'atomexpr' => 15,
            'anonblock' => 37,
            'block' => 304,
            'try' => 74,
            'statement' => 3,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'use' => 20,
            'switch' => 42,
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30
        }
    },
    {#State 276
        DEFAULT => -157,
        GOTOS => {
            'args' => 305
        }
    },
    {#State 277
        DEFAULT => -157,
        GOTOS => {
            'args' => 306
        }
    },
    {#State 278
        ACTIONS => {
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'FOR' => 36,
            'NUMBER' => 35,
            'TRY' => 73,
            'BLOCK' => 27,
            'STOP' => 28,
            'META' => 26,
            'MACRO' => 25,
            'UNLESS' => 23,
            'INSERT' => 24,
            'rawperl' => 59,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'IDENT' => 29,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53,
            'CALL' => 16,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'USE' => 11,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            "[" => 46,
            "{" => 6,
            'LITERAL' => 7,
            'NOT' => 8,
            "\${" => 40,
            'GET' => 41,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'FILTER' => 4
        },
        DEFAULT => -3,
        GOTOS => {
            'chunks' => 68,
            'chunk' => 70,
            'assign' => 69,
            'condition' => 65,
            'loop' => 33,
            'setlist' => 67,
            'macro' => 51,
            'raw' => 66,
            'term' => 32,
            'ident' => 9,
            'atomexpr' => 15,
            'anonblock' => 37,
            'defblockname' => 75,
            'javascript' => 17,
            'try' => 74,
            'block' => 307,
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'use' => 20,
            'switch' => 42,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'expr' => 64,
            'directive' => 30,
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45
        }
    },
    {#State 279
        DEFAULT => -118
    },
    {#State 280
        ACTIONS => {
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'IDENT' => 29,
            'BLOCK' => 27,
            'STOP' => 28,
            'MACRO' => 25,
            'META' => 26,
            'INSERT' => 24,
            'UNLESS' => 23,
            'rawperl' => 59,
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18,
            'CALL' => 16,
            'DEFAULT' => 56,
            'LAST' => 55,
            "\$" => 53,
            'USE' => 11,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'NOT' => 8,
            "[" => 46,
            "{" => 6,
            'LITERAL' => 7,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'switch' => 42,
            'use' => 20,
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'atomexpr' => 15,
            'anonblock' => 37,
            'defblockname' => 75,
            'javascript' => 17,
            'try' => 74,
            'block' => 308,
            'term' => 32,
            'ident' => 9,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'condition' => 65,
            'loop' => 33,
            'macro' => 51,
            'setlist' => 67,
            'raw' => 66
        }
    },
    {#State 281
        DEFAULT => -130
    },
    {#State 282
        ACTIONS => {
            'END' => 309
        }
    },
    {#State 283
        ACTIONS => {
            "(" => 18,
            "\${" => 40,
            'REF' => 52,
            "[" => 46,
            "\"" => 72,
            'LITERAL' => 100,
            "\$" => 53,
            "{" => 6,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8
        },
        GOTOS => {
            'expr' => 310,
            'ident' => 99,
            'lterm' => 39,
            'node' => 54,
            'sterm' => 58,
            'item' => 61,
            'term' => 32
        }
    },
    {#State 284
        ACTIONS => {
            'END' => 311
        }
    },
    {#State 285
        ACTIONS => {
            'IDENT' => 117,
            'NUMBER' => 84,
            'FILENAME' => 81,
            ";" => 313,
            'DEFAULT' => 314
        },
        GOTOS => {
            'filepart' => 79,
            'filename' => 312
        }
    },
    {#State 286
        ACTIONS => {
            ";" => 315
        }
    },
    {#State 287
        ACTIONS => {
            'END' => 316
        }
    },
    {#State 288
        DEFAULT => -80
    },
    {#State 289
        DEFAULT => -165
    },
    {#State 290
        ACTIONS => {
            'REF' => 52,
            "(" => 18,
            "\${" => 40,
            'IDENT' => 29,
            'NUMBER' => 35,
            'NOT' => 8,
            "\"" => 72,
            'LITERAL' => 100,
            "{" => 6,
            "\$" => 53,
            "[" => 46
        },
        GOTOS => {
            'expr' => 317,
            'item' => 61,
            'term' => 32,
            'sterm' => 58,
            'node' => 54,
            'lterm' => 39,
            'ident' => 99
        }
    },
    {#State 291
        DEFAULT => -81
    },
    {#State 292
        ACTIONS => {
            'END' => 318
        }
    },
    {#State 293
        ACTIONS => {
            "\$" => 53,
            "{" => 6,
            'LITERAL' => 100,
            ";" => 320,
            "\"" => 72,
            "[" => 46,
            'DEFAULT' => 321,
            'NUMBER' => 35,
            'IDENT' => 29,
            "\${" => 40,
            'REF' => 52
        },
        GOTOS => {
            'sterm' => 58,
            'node' => 54,
            'term' => 319,
            'item' => 61,
            'ident' => 99,
            'lterm' => 39
        }
    },
    {#State 294
        ACTIONS => {
            'END' => 322
        }
    },
    {#State 295
        ACTIONS => {
            ";" => 323
        }
    },
    {#State 296
        ACTIONS => {
            'END' => 324
        }
    },
    {#State 297
        ACTIONS => {
            'REF' => 52,
            "\${" => 40,
            "(" => 18,
            'NUMBER' => 35,
            'NOT' => 8,
            'IDENT' => 29,
            "{" => 6,
            "\$" => 53,
            'LITERAL' => 100,
            "\"" => 72,
            "[" => 46
        },
        GOTOS => {
            'sterm' => 58,
            'node' => 54,
            'term' => 32,
            'item' => 61,
            'ident' => 99,
            'lterm' => 39,
            'expr' => 325
        }
    },
    {#State 298
        ACTIONS => {
            'END' => 326
        }
    },
    {#State 299
        DEFAULT => -96
    },
    {#State 300
        ACTIONS => {
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            "\"" => 72,
            'NEXT' => 34,
            'IDENT' => 29,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31,
            'INSERT' => 24,
            'UNLESS' => 23,
            'BLOCK' => 190,
            'STOP' => 28,
            'THROW' => 21,
            'IF' => 22,
            "(" => 18,
            'CALL' => 16,
            "\$" => 53,
            'LAST' => 55,
            'DEFAULT' => 56,
            'REF' => 52,
            'SWITCH' => 10,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'NOT' => 8,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'FILTER' => 4,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            "\${" => 40,
            'GET' => 41
        },
        GOTOS => {
            'sterm' => 58,
            'wrapper' => 38,
            'lterm' => 39,
            'switch' => 42,
            'item' => 61,
            'mdir' => 327,
            'atomdir' => 60,
            'filter' => 45,
            'expr' => 210,
            'directive' => 191,
            'term' => 32,
            'ident' => 115,
            'assign' => 69,
            'condition' => 65,
            'loop' => 33,
            'setlist' => 67,
            'node' => 54,
            'atomexpr' => 15,
            'javascript' => 17,
            'try' => 74
        }
    },
    {#State 301
        DEFAULT => -95
    },
    {#State 302
        ACTIONS => {
            "\"" => 328
        }
    },
    {#State 303
        DEFAULT => -89
    },
    {#State 304
        ACTIONS => {
            'END' => 329
        }
    },
    {#State 305
        ACTIONS => {
            'IDENT' => 29,
            'NOT' => 8,
            'NUMBER' => 35,
            "[" => 46,
            "\"" => 72,
            "{" => 6,
            "\$" => 53,
            'LITERAL' => 257,
            'REF' => 52,
            'COMMA' => 252,
            "(" => 18,
            "\${" => 40
        },
        DEFAULT => -65,
        GOTOS => {
            'param' => 255,
            'item' => 253,
            'node' => 54,
            'expr' => 254,
            'lterm' => 39,
            'ident' => 256,
            'term' => 32,
            'sterm' => 58
        }
    },
    {#State 306
        ACTIONS => {
            'NOT' => 8,
            'NUMBER' => 35,
            'IDENT' => 29,
            "[" => 46,
            'LITERAL' => 257,
            "\$" => 53,
            "{" => 6,
            "\"" => 72,
            'COMMA' => 252,
            'REF' => 52,
            "(" => 18,
            "\${" => 40
        },
        DEFAULT => -64,
        GOTOS => {
            'lterm' => 39,
            'ident' => 256,
            'term' => 32,
            'sterm' => 58,
            'param' => 255,
            'item' => 253,
            'node' => 54,
            'expr' => 254
        }
    },
    {#State 307
        ACTIONS => {
            'END' => 330
        }
    },
    {#State 308
        ACTIONS => {
            'END' => 331
        }
    },
    {#State 309
        DEFAULT => -67
    },
    {#State 310
        ACTIONS => {
            'CAT' => 163,
            "/" => 159,
            "+" => 158,
            'MOD' => 162,
            'BINOP' => 161,
            'DIV' => 165,
            'CMPOP' => 164,
            'AND' => 160,
            "?" => 167,
            'OR' => 166
        },
        DEFAULT => -144
    },
    {#State 311
        DEFAULT => -69
    },
    {#State 312
        ACTIONS => {
            'DOT' => 182,
            ";" => 332
        }
    },
    {#State 313
        ACTIONS => {
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'NEXT' => 34,
            "\"" => 72,
            ";" => -19,
            'IF' => 22,
            'THROW' => 21,
            'TEXT' => 19,
            "(" => 18,
            'WHILE' => 31,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'IDENT' => 29,
            'BLOCK' => 27,
            'META' => 26,
            'MACRO' => 25,
            'STOP' => 28,
            'UNLESS' => 23,
            'INSERT' => 24,
            'rawperl' => 59,
            'USE' => 11,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'CALL' => 16,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6
        },
        DEFAULT => -3,
        GOTOS => {
            'term' => 32,
            'ident' => 9,
            'chunks' => 68,
            'chunk' => 70,
            'assign' => 69,
            'condition' => 65,
            'raw' => 66,
            'setlist' => 67,
            'loop' => 33,
            'macro' => 51,
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'anonblock' => 37,
            'atomexpr' => 15,
            'javascript' => 17,
            'defblockname' => 75,
            'try' => 74,
            'block' => 333,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'switch' => 42,
            'use' => 20,
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30
        }
    },
    {#State 314
        ACTIONS => {
            ";" => 334
        }
    },
    {#State 315
        ACTIONS => {
            'perl' => 48,
            'SET' => 47,
            'DEBUG' => 49,
            'VIEW' => 50,
            'REF' => 52,
            'SWITCH' => 10,
            'USE' => 11,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            'GET' => 41,
            "\${" => 40,
            'FILTER' => 4,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'RAW' => 5,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            "(" => 18,
            'TEXT' => 19,
            'THROW' => 21,
            'IF' => 22,
            'rawperl' => 59,
            'INSERT' => 24,
            'UNLESS' => 23,
            'META' => 26,
            'MACRO' => 25,
            'BLOCK' => 27,
            'STOP' => 28,
            'IDENT' => 29,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31
        },
        DEFAULT => -3,
        GOTOS => {
            'try' => 74,
            'block' => 335,
            'atomexpr' => 15,
            'anonblock' => 37,
            'javascript' => 17,
            'defblockname' => 75,
            'defblock' => 71,
            'capture' => 12,
            'node' => 54,
            'view' => 13,
            'condition' => 65,
            'loop' => 33,
            'macro' => 51,
            'raw' => 66,
            'setlist' => 67,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'ident' => 9,
            'term' => 32,
            'directive' => 30,
            'expr' => 64,
            'filter' => 45,
            'item' => 61,
            'atomdir' => 60,
            'use' => 20,
            'switch' => 42,
            'wrapper' => 38,
            'lterm' => 39,
            'sterm' => 58,
            'statement' => 3
        }
    },
    {#State 316
        DEFAULT => -83
    },
    {#State 317
        ACTIONS => {
            "?" => 167,
            'OR' => 166,
            'BINOP' => 161,
            'MOD' => 162,
            "/" => 159,
            'AND' => 160,
            'CAT' => 163,
            "+" => 158,
            'CMPOP' => 164,
            'DIV' => 165
        },
        DEFAULT => -155
    },
    {#State 318
        DEFAULT => -94
    },
    {#State 319
        ACTIONS => {
            ";" => 336
        }
    },
    {#State 320
        ACTIONS => {
            'STOP' => 28,
            'BLOCK' => 27,
            'MACRO' => 25,
            'META' => 26,
            'UNLESS' => 23,
            'INSERT' => 24,
            'rawperl' => 59,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'IDENT' => 29,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21,
            'NEXT' => 34,
            "\"" => 72,
            ";" => -19,
            'FOR' => 36,
            'NUMBER' => 35,
            'TRY' => 73,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'NOT' => 8,
            "\${" => 40,
            'GET' => 41,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'RAW' => 5,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'FILTER' => 4,
            'DEFAULT' => 56,
            'LAST' => 55,
            "\$" => 53,
            'CALL' => 16,
            'DEBUG' => 49,
            'SET' => 47,
            'perl' => 48,
            'USE' => 11,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50
        },
        DEFAULT => -3,
        GOTOS => {
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'anonblock' => 37,
            'atomexpr' => 15,
            'javascript' => 17,
            'defblockname' => 75,
            'try' => 74,
            'block' => 337,
            'term' => 32,
            'ident' => 9,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'condition' => 65,
            'loop' => 33,
            'raw' => 66,
            'macro' => 51,
            'setlist' => 67,
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'switch' => 42,
            'use' => 20
        }
    },
    {#State 321
        ACTIONS => {
            ";" => 338
        }
    },
    {#State 322
        DEFAULT => -53
    },
    {#State 323
        ACTIONS => {
            'rawperl' => 59,
            'UNLESS' => 23,
            'INSERT' => 24,
            'BLOCK' => 27,
            'MACRO' => 25,
            'STOP' => 28,
            'META' => 26,
            'IDENT' => 29,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'WHILE' => 31,
            "(" => 18,
            'TEXT' => 19,
            'THROW' => 21,
            'IF' => 22,
            "\"" => 72,
            ";" => -19,
            'NEXT' => 34,
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            "\${" => 40,
            'GET' => 41,
            'FILTER' => 4,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'RAW' => 5,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'VIEW' => 50,
            'REF' => 52,
            'SWITCH' => 10,
            'USE' => 11
        },
        DEFAULT => -3,
        GOTOS => {
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30,
            'statement' => 3,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'switch' => 42,
            'use' => 20,
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'defblock' => 71,
            'defblockname' => 75,
            'javascript' => 17,
            'atomexpr' => 15,
            'anonblock' => 37,
            'block' => 339,
            'try' => 74,
            'term' => 32,
            'ident' => 9,
            'assign' => 69,
            'chunk' => 70,
            'chunks' => 68,
            'loop' => 33,
            'raw' => 66,
            'macro' => 51,
            'setlist' => 67,
            'condition' => 65
        }
    },
    {#State 324
        DEFAULT => -46
    },
    {#State 325
        ACTIONS => {
            ";" => 340,
            'DIV' => 165,
            "+" => 158,
            "/" => 159,
            'CAT' => 163,
            'AND' => 160,
            'MOD' => 162,
            'BINOP' => 161,
            'CMPOP' => 164,
            'OR' => 166,
            "?" => 167
        }
    },
    {#State 326
        DEFAULT => -48
    },
    {#State 327
        DEFAULT => -91
    },
    {#State 328
        DEFAULT => -102
    },
    {#State 329
        DEFAULT => -62
    },
    {#State 330
        DEFAULT => -59
    },
    {#State 331
        DEFAULT => -78
    },
    {#State 332
        ACTIONS => {
            'CALL' => 16,
            'LAST' => 55,
            'DEFAULT' => 56,
            "\$" => 53,
            'USE' => 11,
            'VIEW' => 50,
            'REF' => 52,
            'SWITCH' => 10,
            'DEBUG' => 49,
            'perl' => 48,
            'SET' => 47,
            'NOT' => 8,
            "[" => 46,
            'LITERAL' => 7,
            "{" => 6,
            'RETURN' => 44,
            'INCLUDE' => 43,
            'RAW' => 5,
            'FILTER' => 4,
            "\${" => 40,
            'GET' => 41,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            'FOR' => 36,
            'TRY' => 73,
            'NUMBER' => 35,
            'NEXT' => 34,
            ";" => -19,
            "\"" => 72,
            'WRAPPER' => 63,
            'PROCESS' => 62,
            'WHILE' => 31,
            'IDENT' => 29,
            'UNLESS' => 23,
            'INSERT' => 24,
            'STOP' => 28,
            'BLOCK' => 27,
            'META' => 26,
            'MACRO' => 25,
            'rawperl' => 59,
            'THROW' => 21,
            'IF' => 22,
            "(" => 18,
            'TEXT' => 19
        },
        DEFAULT => -3,
        GOTOS => {
            'view' => 13,
            'node' => 54,
            'capture' => 12,
            'defblock' => 71,
            'javascript' => 17,
            'defblockname' => 75,
            'anonblock' => 37,
            'atomexpr' => 15,
            'block' => 341,
            'try' => 74,
            'term' => 32,
            'ident' => 9,
            'chunk' => 70,
            'assign' => 69,
            'chunks' => 68,
            'loop' => 33,
            'setlist' => 67,
            'macro' => 51,
            'raw' => 66,
            'condition' => 65,
            'atomdir' => 60,
            'item' => 61,
            'filter' => 45,
            'expr' => 64,
            'directive' => 30,
            'statement' => 3,
            'sterm' => 58,
            'lterm' => 39,
            'wrapper' => 38,
            'use' => 20,
            'switch' => 42
        }
    },
    {#State 333
        ACTIONS => {
            'FINAL' => 286,
            'CATCH' => 285
        },
        DEFAULT => -74,
        GOTOS => {
            'final' => 342
        }
    },
    {#State 334
        ACTIONS => {
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'TRY' => 73,
            'NUMBER' => 35,
            'FOR' => 36,
            'rawperl' => 59,
            'UNLESS' => 23,
            'INSERT' => 24,
            'META' => 26,
            'MACRO' => 25,
            'STOP' => 28,
            'BLOCK' => 27,
            'IDENT' => 29,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'WHILE' => 31,
            "(" => 18,
            'TEXT' => 19,
            'THROW' => 21,
            'IF' => 22,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'perl' => 48,
            'SET' => 47,
            'DEBUG' => 49,
            'VIEW' => 50,
            'SWITCH' => 10,
            'REF' => 52,
            'USE' => 11,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'JAVASCRIPT' => 1,
            'CLEAR' => 2,
            'GET' => 41,
            "\${" => 40,
            'FILTER' => 4,
            'INCLUDE' => 43,
            'RETURN' => 44,
            'RAW' => 5
        },
        DEFAULT => -3,
        GOTOS => {
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'condition' => 65,
            'raw' => 66,
            'loop' => 33,
            'macro' => 51,
            'setlist' => 67,
            'term' => 32,
            'ident' => 9,
            'anonblock' => 37,
            'atomexpr' => 15,
            'defblockname' => 75,
            'javascript' => 17,
            'try' => 74,
            'block' => 343,
            'node' => 54,
            'view' => 13,
            'defblock' => 71,
            'capture' => 12,
            'switch' => 42,
            'use' => 20,
            'sterm' => 58,
            'statement' => 3,
            'wrapper' => 38,
            'lterm' => 39,
            'expr' => 64,
            'directive' => 30,
            'item' => 61,
            'atomdir' => 60,
            'filter' => 45
        }
    },
    {#State 335
        DEFAULT => -73
    },
    {#State 336
        ACTIONS => {
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'perl' => 48,
            'SET' => 47,
            'DEBUG' => 49,
            'SWITCH' => 10,
            'REF' => 52,
            'VIEW' => 50,
            'USE' => 11,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'GET' => 41,
            "\${" => 40,
            'FILTER' => 4,
            'RAW' => 5,
            'RETURN' => 44,
            'INCLUDE' => 43,
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'TRY' => 73,
            'NUMBER' => 35,
            'FOR' => 36,
            'rawperl' => 59,
            'META' => 26,
            'BLOCK' => 27,
            'STOP' => 28,
            'MACRO' => 25,
            'INSERT' => 24,
            'UNLESS' => 23,
            'IDENT' => 29,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21
        },
        DEFAULT => -3,
        GOTOS => {
            'setlist' => 67,
            'raw' => 66,
            'macro' => 51,
            'loop' => 33,
            'condition' => 65,
            'assign' => 69,
            'chunk' => 70,
            'chunks' => 68,
            'ident' => 9,
            'term' => 32,
            'block' => 344,
            'try' => 74,
            'defblockname' => 75,
            'javascript' => 17,
            'anonblock' => 37,
            'atomexpr' => 15,
            'capture' => 12,
            'defblock' => 71,
            'view' => 13,
            'node' => 54,
            'use' => 20,
            'switch' => 42,
            'lterm' => 39,
            'wrapper' => 38,
            'statement' => 3,
            'sterm' => 58,
            'directive' => 30,
            'expr' => 64,
            'filter' => 45,
            'atomdir' => 60,
            'item' => 61
        }
    },
    {#State 337
        DEFAULT => -56
    },
    {#State 338
        ACTIONS => {
            "\"" => 72,
            ";" => -19,
            'NEXT' => 34,
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            'rawperl' => 59,
            'MACRO' => 25,
            'BLOCK' => 27,
            'META' => 26,
            'STOP' => 28,
            'INSERT' => 24,
            'UNLESS' => 23,
            'IDENT' => 29,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21,
            "\$" => 53,
            'DEFAULT' => 56,
            'LAST' => 55,
            'CALL' => 16,
            'perl' => 48,
            'SET' => 47,
            'DEBUG' => 49,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            'USE' => 11,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'GET' => 41,
            "\${" => 40,
            'FILTER' => 4,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44
        },
        DEFAULT => -3,
        GOTOS => {
            'lterm' => 39,
            'wrapper' => 38,
            'statement' => 3,
            'sterm' => 58,
            'use' => 20,
            'switch' => 42,
            'filter' => 45,
            'atomdir' => 60,
            'item' => 61,
            'directive' => 30,
            'expr' => 64,
            'ident' => 9,
            'term' => 32,
            'loop' => 33,
            'macro' => 51,
            'raw' => 66,
            'setlist' => 67,
            'condition' => 65,
            'chunk' => 70,
            'assign' => 69,
            'chunks' => 68,
            'capture' => 12,
            'defblock' => 71,
            'view' => 13,
            'node' => 54,
            'block' => 345,
            'try' => 74,
            'javascript' => 17,
            'defblockname' => 75,
            'atomexpr' => 15,
            'anonblock' => 37
        }
    },
    {#State 339
        DEFAULT => -51
    },
    {#State 340
        ACTIONS => {
            "\$" => 53,
            'LAST' => 55,
            'DEFAULT' => 56,
            'CALL' => 16,
            'SET' => 47,
            'perl' => 48,
            'DEBUG' => 49,
            'REF' => 52,
            'SWITCH' => 10,
            'VIEW' => 50,
            'USE' => 11,
            "{" => 6,
            'LITERAL' => 7,
            "[" => 46,
            'NOT' => 8,
            'CLEAR' => 2,
            'JAVASCRIPT' => 1,
            'GET' => 41,
            "\${" => 40,
            'FILTER' => 4,
            'RAW' => 5,
            'INCLUDE' => 43,
            'RETURN' => 44,
            ";" => -19,
            "\"" => 72,
            'NEXT' => 34,
            'NUMBER' => 35,
            'TRY' => 73,
            'FOR' => 36,
            'rawperl' => 59,
            'MACRO' => 25,
            'STOP' => 28,
            'BLOCK' => 27,
            'META' => 26,
            'UNLESS' => 23,
            'INSERT' => 24,
            'IDENT' => 29,
            'WHILE' => 31,
            'PROCESS' => 62,
            'WRAPPER' => 63,
            'TEXT' => 19,
            "(" => 18,
            'IF' => 22,
            'THROW' => 21
        },
        DEFAULT => -3,
        GOTOS => {
            'directive' => 30,
            'expr' => 64,
            'filter' => 45,
            'atomdir' => 60,
            'item' => 61,
            'switch' => 42,
            'use' => 20,
            'wrapper' => 38,
            'lterm' => 39,
            'sterm' => 58,
            'statement' => 3,
            'try' => 74,
            'block' => 346,
            'atomexpr' => 15,
            'anonblock' => 37,
            'defblockname' => 75,
            'javascript' => 17,
            'defblock' => 71,
            'capture' => 12,
            'node' => 54,
            'view' => 13,
            'condition' => 65,
            'setlist' => 67,
            'raw' => 66,
            'macro' => 51,
            'loop' => 33,
            'chunks' => 68,
            'assign' => 69,
            'chunk' => 70,
            'ident' => 9,
            'term' => 32
        }
    },
    {#State 341
        ACTIONS => {
            'CATCH' => 285,
            'FINAL' => 286
        },
        DEFAULT => -74,
        GOTOS => {
            'final' => 347
        }
    },
    {#State 342
        DEFAULT => -72
    },
    {#State 343
        ACTIONS => {
            'FINAL' => 286,
            'CATCH' => 285
        },
        DEFAULT => -74,
        GOTOS => {
            'final' => 348
        }
    },
    {#State 344
        ACTIONS => {
            'CASE' => 293
        },
        DEFAULT => -57,
        GOTOS => {
            'case' => 349
        }
    },
    {#State 345
        DEFAULT => -55
    },
    {#State 346
        ACTIONS => {
            'ELSE' => 295,
            'ELSIF' => 297
        },
        DEFAULT => -52,
        GOTOS => {
            'else' => 350
        }
    },
    {#State 347
        DEFAULT => -70
    },
    {#State 348
        DEFAULT => -71
    },
    {#State 349
        DEFAULT => -54
    },
    {#State 350
        DEFAULT => -50
    }
]; 



$RULES = [
    [#Rule 0
         '$start', 2, undef
    ],
    [#Rule 1
         'template', 1,
sub
{ $factory->template($_[1])           }
    ],
    [#Rule 2
         'block', 1,
sub
{ $factory->block($_[1])              }
    ],
    [#Rule 3
         'block', 0,
sub
{ $factory->block()                   }
    ],
    [#Rule 4
         'chunks', 2,
sub
{ push(@{$_[1]}, $_[2]) 
                    if defined $_[2]; $_[1]           }
    ],
    [#Rule 5
         'chunks', 1,
sub
{ defined $_[1] ? [ $_[1] ] : [ ]     }
    ],
    [#Rule 6
         'chunk', 1,
sub
{ $factory->textblock($_[1])          }
    ],
    [#Rule 7
         'chunk', 2,
sub
{ return '' unless $_[1];
                           $_[0]->location() . $_[1];
                         }
    ],
    [#Rule 8
         'statement', 1, undef
    ],
    [#Rule 9
         'statement', 1, undef
    ],
    [#Rule 10
         'statement', 1, undef
    ],
    [#Rule 11
         'statement', 1, undef
    ],
    [#Rule 12
         'statement', 1, undef
    ],
    [#Rule 13
         'statement', 1, undef
    ],
    [#Rule 14
         'statement', 1, undef
    ],
    [#Rule 15
         'statement', 1, undef
    ],
    [#Rule 16
         'statement', 1, undef
    ],
    [#Rule 17
         'statement', 1,
sub
{ $factory->get($_[1])                }
    ],
    [#Rule 18
         'statement', 2,
sub
{ $_[0]->add_metadata($_[2]);         }
    ],
    [#Rule 19
         'statement', 0, undef
    ],
    [#Rule 20
         'directive', 1,
sub
{ $factory->set($_[1])                }
    ],
    [#Rule 21
         'directive', 1, undef
    ],
    [#Rule 22
         'directive', 1, undef
    ],
    [#Rule 23
         'directive', 1, undef
    ],
    [#Rule 24
         'directive', 1, undef
    ],
    [#Rule 25
         'directive', 1, undef
    ],
    [#Rule 26
         'directive', 1, undef
    ],
    [#Rule 27
         'directive', 1, undef
    ],
    [#Rule 28
         'atomexpr', 1,
sub
{ $factory->get($_[1])                }
    ],
    [#Rule 29
         'atomexpr', 1, undef
    ],
    [#Rule 30
         'atomdir', 2,
sub
{ $factory->get($_[2])                }
    ],
    [#Rule 31
         'atomdir', 2,
sub
{ $factory->call($_[2])               }
    ],
    [#Rule 32
         'atomdir', 2,
sub
{ $factory->set($_[2])                }
    ],
    [#Rule 33
         'atomdir', 2,
sub
{ $factory->default($_[2])            }
    ],
    [#Rule 34
         'atomdir', 2,
sub
{ $factory->insert($_[2])             }
    ],
    [#Rule 35
         'atomdir', 2,
sub
{ $factory->include($_[2])            }
    ],
    [#Rule 36
         'atomdir', 2,
sub
{ $factory->process($_[2])            }
    ],
    [#Rule 37
         'atomdir', 2,
sub
{ $factory->throw($_[2])              }
    ],
    [#Rule 38
         'atomdir', 1,
sub
{ $factory->return()                  }
    ],
    [#Rule 39
         'atomdir', 1,
sub
{ $factory->stop()                    }
    ],
    [#Rule 40
         'atomdir', 1,
sub
{ $factory->clear()                   }
    ],
    [#Rule 41
         'atomdir', 1,
sub
{ $factory->break()                   }
    ],
    [#Rule 42
         'atomdir', 1,
sub
{ $factory->next()                    }
    ],
    [#Rule 43
         'atomdir', 2,
sub
{ if ($_[2]->[0]->[0] =~ /^'(on|off)'$/) {
                          $_[0]->{ DEBUG_DIRS } = ($1 eq 'on');
                      $factory->debug($_[2]);
                      }
                      else {
                      $_[0]->{ DEBUG_DIRS } ? $factory->debug($_[2]) : '';
                      }
                    }
    ],
    [#Rule 44
         'atomdir', 1, undef
    ],
    [#Rule 45
         'atomdir', 1, undef
    ],
    [#Rule 46
         'condition', 6,
sub
{ $factory->if(@_[2, 4, 5])           }
    ],
    [#Rule 47
         'condition', 3,
sub
{ $factory->if(@_[3, 1])              }
    ],
    [#Rule 48
         'condition', 6,
sub
{ $factory->if("tt2_not($_[2])", @_[4, 5])  }
    ],
    [#Rule 49
         'condition', 3,
sub
{ $factory->if("tt2_not($_[3])", $_[1])     }
    ],
    [#Rule 50
         'else', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]);
                      $_[5];                              }
    ],
    [#Rule 51
         'else', 3,
sub
{ [ $_[3] ]                           }
    ],
    [#Rule 52
         'else', 0,
sub
{ [ undef ]                           }
    ],
    [#Rule 53
         'switch', 6,
sub
{ $factory->switch(@_[2, 5])          }
    ],
    [#Rule 54
         'case', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]); 
                      $_[5];                              }
    ],
    [#Rule 55
         'case', 4,
sub
{ [ $_[4] ]                           }
    ],
    [#Rule 56
         'case', 3,
sub
{ [ $_[3] ]                           }
    ],
    [#Rule 57
         'case', 0,
sub
{ [ undef ]                           }
    ],
    [#Rule 58
         '@1-3', 0,
sub
{ $_[0]->{ INFOR }++                  }
    ],
    [#Rule 59
         'loop', 6,
sub
{ $_[0]->{ INFOR }--;
                      $factory->foreach(@{$_[2]}, $_[5])  }
    ],
    [#Rule 60
         'loop', 3,
sub
{ $factory->foreach(@{$_[3]}, $_[1])  }
    ],
    [#Rule 61
         '@2-3', 0,
sub
{ $_[0]->{ INWHILE }++                }
    ],
    [#Rule 62
         'loop', 6,
sub
{ $_[0]->{ INWHILE }--;
                                      $factory->while(@_[2, 5])           }
    ],
    [#Rule 63
         'loop', 3,
sub
{ $factory->while(@_[3, 1])           }
    ],
    [#Rule 64
         'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
    ],
    [#Rule 65
         'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
    ],
    [#Rule 66
         'loopvar', 2,
sub
{ [ 0, @_[1, 2] ]                     }
    ],
    [#Rule 67
         'wrapper', 5,
sub
{ $factory->wrapper(@_[2, 4])         }
    ],
    [#Rule 68
         'wrapper', 3,
sub
{ $factory->wrapper(@_[3, 1])         }
    ],
    [#Rule 69
         'try', 5,
sub
{ $factory->try(@_[3, 4])             }
    ],
    [#Rule 70
         'final', 5,
sub
{ unshift(@{$_[5]}, [ @_[2,4] ]);
                      $_[5];                              }
    ],
    [#Rule 71
         'final', 5,
sub
{ unshift(@{$_[5]}, [ undef, $_[4] ]);
                      $_[5];                              }
    ],
    [#Rule 72
         'final', 4,
sub
{ unshift(@{$_[4]}, [ undef, $_[3] ]);
                      $_[4];                              }
    ],
    [#Rule 73
         'final', 3,
sub
{ [ $_[3] ]                           }
    ],
    [#Rule 74
         'final', 0,
sub
{ [ 0 ] }
    ],
    [#Rule 75
         'use', 2,
sub
{ $factory->use($_[2])                }
    ],
    [#Rule 76
         'raw', 2,
sub
{ $factory->raw($_[2])                }
    ],
    [#Rule 77
         '@3-3', 0,
sub
{ $_[0]->push_defblock();         }
    ],
    [#Rule 78
         'view', 6,
sub
{ $factory->view(@_[2,5], 
                             $_[0]->pop_defblock) }
    ],
    [#Rule 79
         '@4-2', 0,
sub
{ ${$_[0]->{ INJAVASCRIPT }}++;             }
    ],
    [#Rule 80
         'javascript', 5,
sub
{ ${$_[0]->{ INJAVASCRIPT }}--;
                      $_[0]->{ EVAL_JAVASCRIPT } 
                      ? $factory->javascript($_[4])             
                      : $factory->no_javascript();              }
    ],
    [#Rule 81
         'filter', 5,
sub
{ $factory->filter(@_[2,4])           }
    ],
    [#Rule 82
         'filter', 3,
sub
{ $factory->filter(@_[3,1])           }
    ],
    [#Rule 83
         'defblock', 5,
sub
{ my $name = join('/', @{ $_[0]->{ DEFBLOCKS } });
                      pop(@{ $_[0]->{ DEFBLOCKS } });
                      $_[0]->define_block($name, $_[4]); 
                      undef
                    }
    ],
    [#Rule 84
         'defblockname', 2,
sub
{ push(@{ $_[0]->{ DEFBLOCKS } }, $_[2]);
                      $_[2];
                    }
    ],
    [#Rule 85
         'blockname', 1, undef
    ],
    [#Rule 86
         'blockname', 1,
sub
{ $_[1] =~ s/^'(.*)'$/$1/; $_[1]      }
    ],
    [#Rule 87
         'blockargs', 1, undef
    ],
    [#Rule 88
         'blockargs', 0, undef
    ],
    [#Rule 89
         'anonblock', 5,
sub
{ local $" = ', ';
                      print STDERR "experimental block args: [@{ $_[2] }]\n"
                      if $_[2];
                      $factory->anon_block($_[4])         }
    ],
    [#Rule 90
         'capture', 3,
sub
{ $factory->capture(@_[1, 3])         }
    ],
    [#Rule 91
         'macro', 6,
sub
{ $factory->macro(@_[2, 6, 4])        }
    ],
    [#Rule 92
         'macro', 3,
sub
{ $factory->macro(@_[2, 3])           }
    ],
    [#Rule 93
         'mdir', 1, undef
    ],
    [#Rule 94
         'mdir', 4,
sub
{ $_[3]                               }
    ],
    [#Rule 95
         'margs', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
    ],
    [#Rule 96
         'margs', 2,
sub
{ $_[1]                               }
    ],
    [#Rule 97
         'margs', 1,
sub
{ [ $_[1] ]                           }
    ],
    [#Rule 98
         'metadata', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
    ],
    [#Rule 99
         'metadata', 2, undef
    ],
    [#Rule 100
         'metadata', 1, undef
    ],
    [#Rule 101
         'meta', 3,
sub
{ for ($_[3]) { s/^'//; s/'$//; 
                               s/\\'/'/g  }; 
                     [ @_[1,3] ] }
    ],
    [#Rule 102
         'meta', 5,
sub
{ [ @_[1,4] ] }
    ],
    [#Rule 103
         'meta', 3,
sub
{ [ @_[1,3] ] }
    ],
    [#Rule 104
         'term', 1, undef
    ],
    [#Rule 105
         'term', 1, undef
    ],
    [#Rule 106
         'lterm', 3,
sub
{ "{ $_[2] }"                         }
    ],
    [#Rule 107
         'lterm', 3,
sub
{ "{ $_[2] }"                         }
    ],
    [#Rule 108
         'lterm', 2,
sub
{ "{ }"                               }
    ],
    [#Rule 109
         'lterm', 3,
sub
{ "{ $_[2]  }"                        }
    ],
    [#Rule 110
         'sterm', 1,
sub
{ $factory->ident($_[1])              }
    ],
    [#Rule 111
         'sterm', 2,
sub
{ $factory->identref($_[2])           }
    ],
    [#Rule 112
         'sterm', 3,
sub
{ $factory->quoted($_[2])             }
    ],
    [#Rule 113
         'sterm', 1, undef
    ],
    [#Rule 114
         'sterm', 1, undef
    ],
    [#Rule 115
         'list', 2,
sub
{ "$_[1], $_[2]"                      }
    ],
    [#Rule 116
         'list', 2, undef
    ],
    [#Rule 117
         'list', 1, undef
    ],
    [#Rule 118
         'range', 3,
sub
{ $_[1] . '..' . $_[3]                }
    ],
    [#Rule 119
         'hash', 1, undef
    ],
    [#Rule 120
         'hash', 0,
sub
{ "" }
    ],
    [#Rule 121
         'params', 2,
sub
{ "$_[1], $_[2]"                      }
    ],
    [#Rule 122
         'params', 2, undef
    ],
    [#Rule 123
         'params', 1, undef
    ],
    [#Rule 124
         'param', 3,
sub
{ "[$_[1]] = $_[3]"                    }
    ],
    [#Rule 125
         'param', 3,
sub
{ "[$_[1]] = $_[3]"                    }
    ],
    [#Rule 126
         'ident', 3,
sub
{ push(@{$_[1]}, @{$_[3]}); $_[1]     }
    ],
    [#Rule 127
         'ident', 3,
sub
{ push(@{$_[1]}, 
                       map {($_, 0)} split(/\./, $_[3]));
                      $_[1];                      }
    ],
    [#Rule 128
         'ident', 1, undef
    ],
    [#Rule 129
         'node', 1,
sub
{ [ $_[1], 0 ]                        }
    ],
    [#Rule 130
         'node', 4,
sub
{ [ $_[1], $factory->args($_[3]) ]    }
    ],
    [#Rule 131
         'item', 1,
sub
{ "'$_[1]'"                           }
    ],
    [#Rule 132
         'item', 3,
sub
{ $_[2]                               }
    ],
    [#Rule 133
         'item', 2,
sub
{ $_[0]->{ V1DOLLAR }
                       ? "'$_[2]'" 
                       : $factory->ident(["'$_[2]'", 0])  }
    ],
    [#Rule 134
         'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
    ],
    [#Rule 135
         'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
    ],
    [#Rule 136
         'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
    ],
    [#Rule 137
         'expr', 3,
sub
{ "math_floor($_[1] / $_[3])"         }
    ],
    [#Rule 138
         'expr', 3,
sub
{ "$_[1] % $_[3]"                     }
    ],
    [#Rule 139
         'expr', 3,
sub
{ "$_[1] $CMPOP{ $_[2] } $_[3]"       }
    ],
    [#Rule 140
         'expr', 3,
sub
{ "$_[1] .. $_[3]"                    }
    ],
    [#Rule 141
         'expr', 3,
sub
{ "tt2_true($_[1]) and tt2_true($_[3])"                   }
    ],
    [#Rule 142
         'expr', 3,
sub
{ "tt2_true($_[1]) or tt2_true($_[3])"                    }
    ],
    [#Rule 143
         'expr', 2,
sub
{ "tt2_not($_[2])"                         }
    ],
    [#Rule 144
         'expr', 5,
sub
{ "tt2_true($_[1]) and $_[3] or $_[5]"          }
    ],
    [#Rule 145
         'expr', 3,
sub
{ $factory->assign(@{$_[2]})          }
    ],
    [#Rule 146
         'expr', 3,
sub
{ "($_[2])"                           }
    ],
    [#Rule 147
         'expr', 1, undef
    ],
    [#Rule 148
         'setlist', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
    ],
    [#Rule 149
         'setlist', 2, undef
    ],
    [#Rule 150
         'setlist', 1, undef
    ],
    [#Rule 151
         'assign', 3,
sub
{ [ $_[1], $_[3] ]                    }
    ],
    [#Rule 152
         'assign', 3,
sub
{ [ @_[1,3] ]                         }
    ],
    [#Rule 153
         'args', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
    ],
    [#Rule 154
         'args', 2,
sub
{ push(@{$_[1]->[0]}, $_[2]); $_[1]   }
    ],
    [#Rule 155
         'args', 4,
sub
{ push(@{$_[1]->[0]}, "'', " . 
                      $factory->assign(@_[2,4])); $_[1]  }
    ],
    [#Rule 156
         'args', 2,
sub
{ $_[1]                               }
    ],
    [#Rule 157
         'args', 0,
sub
{ [ [ ] ]                             }
    ],
    [#Rule 158
         'lnameargs', 3,
sub
{ push(@{$_[3]}, $_[1]); $_[3]        }
    ],
    [#Rule 159
         'lnameargs', 1, undef
    ],
    [#Rule 160
         'lvalue', 1, undef
    ],
    [#Rule 161
         'lvalue', 3,
sub
{ $factory->quoted($_[2])             }
    ],
    [#Rule 162
         'lvalue', 1, undef
    ],
    [#Rule 163
         'nameargs', 3,
sub
{ [ [$factory->ident($_[2])], $_[3] ]   }
    ],
    [#Rule 164
         'nameargs', 2,
sub
{ [ @_[1,2] ] }
    ],
    [#Rule 165
         'nameargs', 4,
sub
{ [ @_[1,3] ] }
    ],
    [#Rule 166
         'names', 3,
sub
{ push(@{$_[1]}, $_[3]); $_[1] }
    ],
    [#Rule 167
         'names', 1,
sub
{ [ $_[1] ]                    }
    ],
    [#Rule 168
         'name', 3,
sub
{ $factory->quoted($_[2])  }
    ],
    [#Rule 169
         'name', 1,
sub
{ "'$_[1]'" }
    ],
    [#Rule 170
         'name', 1, undef
    ],
    [#Rule 171
         'filename', 3,
sub
{ "$_[1].$_[3]" }
    ],
    [#Rule 172
         'filename', 1, undef
    ],
    [#Rule 173
         'filepart', 1, undef
    ],
    [#Rule 174
         'filepart', 1, undef
    ],
    [#Rule 175
         'filepart', 1, undef
    ],
    [#Rule 176
         'quoted', 2,
sub
{ push(@{$_[1]}, $_[2]) 
                          if defined $_[2]; $_[1]         }
    ],
    [#Rule 177
         'quoted', 0,
sub
{ [ ]                                 }
    ],
    [#Rule 178
         'quotable', 1,
sub
{ $factory->ident($_[1])              }
    ],
    [#Rule 179
         'quotable', 1,
sub
{ $factory->text($_[1])               }
    ],
    [#Rule 180
         'quotable', 1,
sub
{ undef                               }
    ]
];

1;

}
#
# Inline include of Lemplate/Parser.pm
#
BEGIN { $INC{'Lemplate/Parser.pm'} = 'dummy/Lemplate/Parser.pm'; }
BEGIN {
#line 0 "Lemplate/Parser.pm"
package Lemplate::Parser;
use strict;
use warnings;
use base 'Template::Parser';


use Lemplate::Grammar;
use Lemplate::Directive;

sub new {
    my $class = shift;
    my $parser = $class->SUPER::new(
        GRAMMAR => Lemplate::Grammar->new(),
        FACTORY => 'Lemplate::Directive',
        @_,
    );

    # flags passed from Lemplate object
    my %args = @_;

    # eval-javascript is default "on"
    $parser->{EVAL_JAVASCRIPT} = exists $args{EVAL_JAVASCRIPT}
      ? $args{EVAL_JAVASCRIPT} : 1;

    # tie the parser state-variable to the global Directive var
    $parser->{INJAVASCRIPT} = \$Lemplate::Directive::INJAVASCRIPT;

    return $parser;
}

1;


}
#
# Inline include of Lemplate.pm
#
BEGIN { $INC{'Lemplate.pm'} = 'dummy/Lemplate.pm'; }
BEGIN {
#line 0 "Lemplate.pm"


package Lemplate;
use strict;
use warnings;
use Template 2.14;
use Getopt::Long;


use Lemplate::Parser;


our %ExtraTemplates;
our %ProcessedTemplates;
our $TemplateName;

sub usage {
    <<'...';
Usage:

    lemplate --runtime [runtime-opt]

    lemplate --compile [compile-opt] <template-list>

    lemplate --runtime [runtime-opt] --compile [compile-opt] <template-list>

    lemplate --list <template-list>

Where "--runtime" and "runtime-opt" can include:

    --runtime           Equivalent to --ajax=ilinsky --json=json2
    --runtime=standard

    --runtime=lite      Same as --ajax=none --json=none
    --runtime=jquery    Same as --ajax=jquery --json=none
    --runtime=yui       Same as --ajax=yui --json=yui
    --runtime=legacy    Same as --ajax=gregory --json=json2

    --json              By itself, equivalent to --json=json2
    --json=json2        Include http://www.json.org/json2.js for parsing/stringifying
    --json=yui          Use YUI: YAHOO.lang.JSON (requires external YUI)
    --json=none         Doesn't provide any JSON functionality except a warning

    --ajax              By itself, equivalent to --ajax=xhr
    --ajax=jquery       Use jQuery for Ajax get and post (requires external jQuery)
    --ajax=yui          Use YUI: yui/connection/connection.js (requires external YUI)
    --ajax=xhr          Use XMLHttpRequest (will automatically use --xhr=ilinsky if --xhr is not set)
    --ajax=none         Doesn't provide any Ajax functionality except a warning

    --xhr               By itself, equivalent to --xhr=ilinsky
    --xhr=ilinsky       Include http://code.google.com/p/xmlhttprequest/
    --xhr=gregory       Include http://www.scss.com.au/family/andrew/webdesign/xmlhttprequest/

    --xxx               Include XXX and JJJ helper functions

    --compact           Use the YUICompressor compacted version of the runtime

Where "compile-opt" can include:

    --include_path=DIR  Add directory to INCLUDE_PATH

    --start-tag
    --end-tag
    --pre-chomp
    --post-chomp
    --trim
    --any-case
    --eval
    --noeval
    -s, --source
    --exclude

For more information use:
    perldoc lemplate
...
}

sub main {
    my $class = shift;

    my @argv = @_;

    my ($template_options, $lemplate_options) = get_options(@argv);
    my ($runtime, $compile, $list) = @$lemplate_options{qw/runtime compile list/};

    if ($runtime) {
        print runtime_source_code(@$lemplate_options{qw/runtime ajax json xhr xxx compact/});
        return unless $compile;
    }

    my $templates = make_file_list($lemplate_options->{exclude}, @argv);
    print_usage_and_exit() unless @$templates;

    if ($list) {
        foreach (@$templates) {
            print STDOUT $_->{short} . "\n";
        }
        return;
    }

    if ($compile) {
        my $lemplate = Lemplate->new(%$template_options);
        print STDOUT $lemplate->_preamble;
        for (my $i = 0; $i < @$templates; $i++) {
            my $template = $templates->[$i];
            #warn "processing $template->{short}";
            my $content = slurp($template->{full});
            if ($content) {
                %ExtraTemplates = ();
                print STDOUT $lemplate->compile_template_content(
                    $content,
                    $template->{short}
                );
                my @new_files;
                for my $new_template (keys %ExtraTemplates) {
                    if (!$ProcessedTemplates{$new_template}) {
                        if (!-f $new_template) {
                            $new_template = "t/data/" . $new_template;
                        }
                        #warn $new_template;
                        if (-f $new_template) {
                            #warn "adding new template $new_template";
                            push @new_files, $new_template;
                        }
                    }
                }
                push @$templates, @{ make_file_list({}, @new_files) };
            }
        }
        print STDOUT "return _M\n";
        return;
    }

    print_usage_and_exit();
}

sub get_options {
    local @ARGV = @_;

    my $runtime;
    my $compile = 0;
    my $list = 0;

    my $start_tag = exists $ENV{LEMPLATE_START_TAG}
        ? $ENV{LEMPLATE_START_TAG}
        : undef;
    my $end_tag = exists $ENV{LEMPLATE_END_TAG}
        ? $ENV{LEMPLATE_END_TAG}
        : undef;
    my $pre_chomp = exists $ENV{LEMPLATE_PRE_CHOMP}
        ? $ENV{LEMPLATE_PRE_CHOMP}
        : undef;
    my $post_chomp = exists $ENV{LEMPLATE_POST_CHOMP}
        ? $ENV{LEMPLATE_POST_CHOMP}
        : undef;
    my $trim = exists $ENV{LEMPLATE_TRIM}
        ? $ENV{LEMPLATE_TRIM}
        : undef;
    my $anycase = exists $ENV{LEMPLATE_ANYCASE}
        ? $ENV{LEMPLATE_ANYCASE}
        : undef;
    my $eval_javascript = exists $ENV{LEMPLATE_EVAL_JAVASCRIPT}
        ? $ENV{LEMPLATE_EVAL_JAVASCRIPT}
        : 1;

    my $source  = 0;
    my $exclude = 0;
    my ($ajax, $json, $xxx, $xhr, $compact, $minify);

    my $help = 0;
    my @include_paths;

    GetOptions(
        "compile|c"     => \$compile,
        "list|l"        => \$list,
        "runtime|r:s"   => \$runtime,

        "start-tag=s"   => \$start_tag,
        "end-tag=s"     => \$end_tag,
        "trim=s"        => \$trim,
        "pre-chomp"     => \$pre_chomp,
        "post-chomp"    => \$post_chomp,
        "any-case"      => \$anycase,
        "eval!"         => \$eval_javascript,

        "source|s"      => \$source,
        "exclude=s"     => \$exclude,

        "ajax:s"        => \$ajax,
        "json:s"        => \$json,
        "xxx"           => \$xxx,
        "xhr:s"         => \$xhr,

        "include_path"  => \@include_paths,
        "compact"       => \$compact,
        "minify:s"      => \$minify,

        "help|?"        => \$help,
    ) or print_usage_and_exit();

    if ($help) {
        print_usage_and_exit();
    }

    ($runtime, $ajax, $json, $xxx, $xhr, $minify) = map { defined $_ && ! length $_ ? 1 : $_ } ($runtime, $ajax, $json, $xxx, $xhr, $minify);
    $runtime = "standard" if $runtime && $runtime eq 1;

    print_usage_and_exit("Don't understand '--runtime $runtime'") if defined $runtime && ! grep { $runtime =~ m/$_/ } qw/standard lite jquery yui legacy/;
    print_usage_and_exit("Can't specify --list with a --runtime and/or the --compile option") if $list && ($runtime || $compile);
    print_usage_and_exit() unless $list || $runtime || $compile;

    my $command =
        $runtime ? 'runtime' :
        $compile ? 'compile' :
        $list ? 'list' :
        print_usage_and_exit();

    my $options = {};
    $options->{START_TAG} = $start_tag if defined $start_tag;
    $options->{END_TAG} = $end_tag if defined $end_tag;
    $options->{PRE_CHOMP} = $pre_chomp if defined $pre_chomp;
    $options->{POST_CHOMP} = $post_chomp if defined $post_chomp;
    $options->{TRIM} = $trim if defined $trim;
    $options->{ANYCASE} = $anycase if defined $anycase;
    $options->{EVAL_JAVASCRIPT} = $eval_javascript if defined $eval_javascript;
    $options->{INCLUDE_PATH} = \@include_paths;

    return (
        $options,
        { compile => $compile, runtime => $runtime, list => $list,
            source => $source,
            exclude => $exclude,
            ajax => $ajax, json => $json, xxx => $xxx, xhr => $xhr,
            compact => $compact, minify => $minify },
    );
}


sub slurp {
    my $filepath = shift;
    open(F, '<', $filepath) or die "Can't open '$filepath' for input:\n$!";
    my $contents = do {local $/; <F>};
    close(F);
    return $contents;
}

sub recurse_dir {
    require File::Find::Rule;

    my $dir = shift;
    my @files;
    foreach ( File::Find::Rule->file->in( $dir ) ) {
        if ( m{/\.[^\.]+} ) {} # Skip ".hidden" files or directories
        else {
            push @files, $_;
        }
    }
    return @files;
}

sub make_file_list {
    my ($exclude, @args) = @_;

    my @list;

    foreach my $arg (@args) {
        unless (-e $arg) { next; } # file exists
        unless (-s $arg or -d $arg) { next; } # file size > 0 or directory (for Win platform)
        if ($exclude and $arg =~ m/$exclude/) { next; } # file matches exclude regex

        if (-d $arg) {
            foreach my $full ( recurse_dir($arg) ) {
                $full =~ /$arg(\/|)(.*)/;
                my $short = $2;
                push(@list, {full=>$full, short=>$short} );
            }
        }
        else {
            my $full = $arg;
            my $short = $full;
            $short =~ s/.*[\/\\]//;
            push(@list, {full=>$arg, short=>$short} );
        }
    }

    return [ sort { $a->{short} cmp $b->{short} } @list ];
}

sub print_usage_and_exit {
    print STDOUT join "\n", "", @_, "Aborting!", "\n" if @_;
    print STDOUT usage();
    exit;
}

sub runtime_source_code {
    require Lemplate::Runtime;
    require Lemplate::Runtime::Compact;

    unshift @_, "standard" unless @_;

    my ($runtime, $ajax, $json, $xhr, $xxx, $compact) = map { defined $_ ? lc $_ : "" } @_[0 .. 5];

    my $Lemplate_Runtime = $compact ? "Lemplate::Runtime::Compact" : "Lemplate::Runtime";

    if ($runtime eq "standard") {
        $ajax ||= "xhr";
        $json ||= "json2";
        $xhr ||= "ilinsky";
    }
    elsif ($runtime eq "jquery") {
        $ajax ||= "jquery";
    }
    elsif ($runtime eq "yui") {
        $ajax ||= "yui";
        $json ||= "yui";
    }
    elsif ($runtime eq "legacy") {
        $ajax ||= "xhr";
        $json ||= "json2";
        $xhr ||= "gregory";
        $xxx = 1;
    }
    elsif ($runtime eq "lite") {
    }

    $ajax = "xhr" if $ajax eq 1;
    $xhr ||= 1 if $ajax eq "xhr";
    $json = "json2" if $json eq 1;
    $xhr = "ilinsky" if $xhr eq 1;

    my @runtime;

    push @runtime, $Lemplate_Runtime->kernel if $runtime;

    push @runtime, $Lemplate_Runtime->json2 if $json =~ m/^json2?$/i;

    push @runtime, $Lemplate_Runtime->ajax_xhr if $ajax eq "xhr";
    push @runtime, $Lemplate_Runtime->ajax_jquery if $ajax eq "jquery";
    push @runtime, $Lemplate_Runtime->ajax_yui if $ajax eq "yui";

    push @runtime, $Lemplate_Runtime->json_json2 if $json =~ m/^json2?$/i;
    push @runtime, $Lemplate_Runtime->json_json2_internal if $json =~ m/^json2?[_-]?internal$/i;
    push @runtime, $Lemplate_Runtime->json_yui if $json eq "yui";

    push @runtime, $Lemplate_Runtime->xhr_ilinsky if $xhr eq "ilinsky";
    push @runtime, $Lemplate_Runtime->xhr_gregory if $xhr eq "gregory";

    push @runtime, $Lemplate_Runtime->xxx if $xxx;

    return join ";", @runtime;
}


sub new {
    my $class = shift;
    return bless { @_ }, $class;
}

sub compile_module {
    my ($self, $module_path, $template_file_paths) = @_;
    my $result = $self->compile_template_files(@$template_file_paths)
      or return;
    open MODULE, "> $module_path"
        or die "Can't open '$module_path' for output:\n$!";
    print MODULE $result;
    close MODULE;
    return 1;
}

sub compile_module_cached {
    my ($self, $module_path, $template_file_paths) = @_;
    my $m = -M $module_path;
    return 0 unless grep { -M($_) < $m } @$template_file_paths;
    return $self->compile_module($module_path, $template_file_paths);
}

sub compile_template_files {
    my $self = shift;
    my $output = $self->_preamble;
    for my $filepath (@_) {
        my $filename = $filepath;
        $filename =~ s/.*[\/\\]//;
        open FILE, $filepath
          or die "Can't open '$filepath' for input:\n$!";
        my $template_input = do {local $/; <FILE>};
        close FILE;
        $output .=
            $self->compile_template_content($template_input, $filename);
    }
    return $output;
}

sub compile_template_content {
    die "Invalid arguments in call to Lemplate->compile_template_content"
      unless @_ == 3;
    my ($self, $template_content, $template_name) = @_;
    $TemplateName = $template_name;
    my $parser = Lemplate::Parser->new( ref($self) ? %$self : () );
    my $parse_tree = $parser->parse(
        $template_content, {name => $template_name}
    ) or die $parser->error;
    my $output =
        "-- $template_name\n" .
        "template_map['$template_name'] = " .
        $parse_tree->{BLOCK} .
        "\n";
    for my $function_name (sort keys %{$parse_tree->{DEFBLOCKS}}) {
        my $name = "$template_name/$function_name";
        next if $ProcessedTemplates{$name};
        #warn "seen $name";
        $ProcessedTemplates{$name} = 1;
        $output .=
            "template_map['$name'] = " .
            $parse_tree->{DEFBLOCKS}{$function_name} .
            "\n";
    }
    return $output;
}

sub _preamble {
    return <<'...';
--[[
   This Lua code was generated by Lemplate, the Lua
   Template Toolkit. Any changes made to this file will be lost the next
   time the templates are compiled.

   Copyright 2016 - Yichun Zhang (agentzh) - All rights reserved.

   Copyright 2006-2014 - Ingy döt Net - All rights reserved.
]]

local gsub = ngx.re.gsub
local concat = table.concat
local type = type
local math_floor = math.floor
local table_maxn = table.maxn

local _M = {
    version = '0.03'
}

local template_map = {}

local function tt2_true(v)
    return v and v ~= 0 and v ~= "" and v ~= '0'
end

local function tt2_not(v)
    return not v or v == 0 or v == "" or v == '0'
end

local context_meta = {}

function context_meta.plugin(context, name, args)
    if name == "iterator" then
        local list = args[1]
        local count = table_maxn(list)
        return { list = list, count = 1, max = count - 1, index = 0, size = count, first = true, last = false, prev = "" }
    else
        return error("unknown iterator: " .. name)
    end
end

function context_meta.process(context, file)
    local f = template_map[file]
    if not f then
        return error("file error - " .. file .. ": not found")
    end
    return f(context)
end

function context_meta.include(context, file)
    local f = template_map[file]
    if not f then
        return error("file error - " .. file .. ": not found")
    end
    return f(context)
end

context_meta = { __index = context_meta }

local function stash_get(stash, k)
    local v
    if type(k) == "table" then
        v = stash
        for i = 1, #k, 2 do
            local key = k[i]
            local typ = k[i + 1]
            if type(typ) == "table" then
                local value = v[key]
                if type(value) == "function" then
                    return value(unpack(typ))
                end
                if value then
                    return value
                end
                if key == "size" then
                    if type(v) == "table" then
                        return #v
                    else
                        return 1
                    end
                else
                    return error("virtual method " .. key .. " not supported")
                end
            end
            if type(key) == "number" and key == math_floor(key) and key >= 0 then
                key = key + 1
            end
            if type(v) ~= "table" then
                return ''
            end
            v = v[key]
        end
    else
        v = stash[k]
    end
    if type(v) == "function" then
        return v()
    end
    return v or ''
end

local function stash_set(stash, k, v, default)
    if default then
        local old = stash[k]
        if old == nil then
            stash[k] = v
        end
    else
        stash[k] = v
    end
end

function _M.process(file, params)
    local stash = params
    local context = {
        stash = stash,
        filter = function (bits, name, params)
            local s = concat(bits)
            if name == "html" then
                s = gsub(s, "&", '&amp;', "jo")
                s = gsub(s, "<", '&lt;', "jo");
                s = gsub(s, ">", '&gt;', "jo");
                s = gsub(s, '"', '&quot;', "jo"); -- " end quote for emacs
                return s
            end
        end
    }
    context = setmetatable(context, context_meta)
    local f = template_map[file]
    if not f then
        return error("file error - " .. file .. ": not found")
    end
    return f(context)
end
...
}

1;


}
#BOOTSTRAP-END

# VERSION

Lemplate->main(@ARGV);

__END__

=encoding UTF-8

=head1 Usage:

    lemplate --runtime [runtime-opt]

    lemplate --compile [compile-opt] template-list

    lemplate --runtime [runtime-opt] --compile [compile-opt] template-list

    lemplate --list template-list

Where C<--runtime> and C<runtime-opt> can include:

    --runtime           Equivalent to --ajax=ilinsky --json=json2
    --runtime=standard

    --runtime=lite      Same as --ajax=none --json=none
    --runtime=jquery    Same as --ajax=jquery --json=none
    --runtime=yui       Same as --ajax=yui --json=yui
    --runtime=legacy    Same as --ajax=gregory --json=json2

    --json              By itself, equivalent to --json=json2
    --json=json2        Include http://www.json.org/json2.js for parsing/stringifying
    --json=yui          Use YUI: YAHOO.lang.JSON (requires external YUI)
    --json=none         Doesn't provide any JSON functionality except a warning
    
    --ajax              By itself, equivalent to --ajax=xhr
    --ajax=jquery       Use jQuery for Ajax get and post (requires external jQuery)
    --ajax=yui          Use YUI: yui/connection/connection.js (requires external YUI)
    --ajax=xhr          Use XMLHttpRequest (will automatically use --xhr=ilinsky if --xhr is not set)
    --ajax=none         Doesn't provide any Ajax functionality except a warning

    --xhr               By itself, equivalent to --xhr=ilinsky
    --xhr=ilinsky       Include http://code.google.com/p/xmlhttprequest/
    --xhr=gregory       Include http://www.scss.com.au/family/andrew/webdesign/xmlhttprequest/

    --xxx               Include XXX and JJJ helper functions

    --compact           Use the YUICompressor compacted version of the runtime

Where C<compile-opt> can include:

    --start-tag
    --end-tag
    --pre-chomp
    --post-chomp
    --trim
    --any-case
    --eval
    --noeval
    -s, --source
    --exclude

    See below for more information
    
=head2 Example:

Write the Lemplate runtime code into Lemplate.js, then
compile all the template files in the templates/ directory and put
the output in my-lemplate.js.

    lemplate --runtime > Lemplate.js
    lemplate --compile templates/* > my-lemplate.js

Do the same thing, but put the output into one file.

    lemplate --runtime > my-lemplate.js
    lemplate --compile templates/* >> my-lemplate.js

=head2 template-list:

The template-list is the list of template files that will be compiled.
If something in the list is a file, then the template name will be just
the file name. If it is a directory, then all the files under that
directory will be found, and the relative paths to those files will be
the template name.

So 'template/foo/bar.tt2' will be named 'bar.tt2', but 'template/' will
find a template named 'foo/bar.tt2'.

It is important to know what Lemplate thinks the template name will be
when you are writing templates or code that refers to other templates.
Use the --list option to check this.

=head1 Commands:

    -r, --runtime
        This flag tells Lemplate to print the Lemplate JavaScript
        runtime code to STDOUT. You should redirect this output into
        a .js file.

    -c, --compile
        The --compile flag tells Lemplate to actually compile templates.
        The output is written to STDOUT.

    -l, --list
        Just print (STDOUT) the template names that Lemplate would use
        from the template-list.

=head1 Template Toolkit Compile Options:

Lemplate allows you to specify the following Template Toolkit compile
time options. Full descriptions of these options are available at
L<http://www.template-toolkit.org/docs/plain/Manual/Config.html>.

These options may either be set as JEMPLATE_* environment variables or as
command line switches.

    --start-tag (JEMPLATE_START_TAG)
        Specify the starting template delimiter to use. Default is '[%'.

    --end-tag (JEMPLATE_END_TAG)
        Specify the ending template delimiter to use. Default is '%]'.

    --pre-chomp (JEMPLATE_PRE_CHOMP)
        Chomp leading whitespace automatically. Default is off.

    --post-chomp (JEMPLATE_POST_CHOMP)
        Chomp trailing whitespace automatically. Default is off.

    --trim (JEMPLATE_TRIM)
        Trim leading and trailing whitespace. Default is off.

    --any-case (JEMPLATE_ANYCASE)
        Allow lower or mixed case for template directives. Default is off.

    --eval (--noeval) (JEMPLATE_EVAL_JAVASCRIPT)
        Allow the execution of raw JavaScript. Default is on.
        Use --noeval to disallow it.

=head1 Lemplate Options:

These compile time options are specific to Lemplate.

    -s, --source
        Include the original template source code as a JavaScript
        comment next to each compiled template.

    --exclude
        Exclude any file matching the given regular expression.

=cut
